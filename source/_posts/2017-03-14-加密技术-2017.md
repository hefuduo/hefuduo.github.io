---
layout:     post
title:      "加密技术"
subtitle:   "Android安全加密"
date:       2017-03-24 11:16:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
    - 密码学
    - 安全
---

[TOC]



> 写在前面
>
> 1. 对称加密与非对称加密结合使用实现了秘钥交换，之后通信双方使用该秘钥进行对称加密通信。
> 2. 消息摘要与非对称加密实现了数字签名，根证书机构对目标证书进行签名，在校验的时候，根证书用公钥对其进行校验。若校验成功，则说明该证书是受信任的。
> 3. Keytool 工具可以创建证书，之后交给根证书机构认证后直接使用自签名证书，还可以输出证书的RFC格式信息等。
> 4. 数字签名技术实现了身份认证与数据完整性保证。
> 5. 加密技术保证了数据的保密性，消息摘要算法保证了数据的完整性，对称加密的高效保证了数据处理的可靠性，数字签名技术保证了操作的不可否认性。

# 第一章 对称加密

## 1.1 对称加密

### 凯撒密码

#### 简介

> 古罗马时期，《高卢战纪》描述凯撒曾经使用密码来传递信息，所以称之为“凯撒密码”。

凯撒密码是一种替代密码，即通过字母按顺序后退n位起到加密作用。例如当偏移量是3的时候，所有的字母A都将被替换成D，B将变成E，由此可见，位数就是凯撒密码加密和解密的密钥。



![凯撒加密](http://files.jb51.net/file_images/article/201609/201691392456135.jpg?201681392511)

#### 实现

```java
public class CaeserEncryption{

	public static String encrypt(String src,int key){
		char[] array = src.toCharArray();
		for (int i = 0; i < array.length ; i++ ) {
			array[i] = (char)(array[i] + key);
		}
		return new String(array);
	}

	public static String decrypt(String src,int key){
		char[] array = src.toCharArray();
		for (int i = 0; i < array.length ; i++ ) {
			array[i] = (char)(array[i] + key);			
		}
		return new String(array);
	}

}
```



#### 破解

> 凯撒密码的加密强度很低，使用频度分析法就可以破解。

在任何一种书面语言中，不同的字母或字母组合出现的频率各不相同。而且，对于以这种语言书写的任意一段文本，都具有大致相同的特征字母分布。比如，在英语中，字母E出现的频率很高，而X则出现得较少。类似地，ST、NG、TH，以及QU等双字母组合出现的频率非常高，NZ、QJ组合则极少。英语中出现频率最高的12个字母可以简记为“ETAOIN SHRDLU”。

破解过程

1. 统计密文里出现次数最多的字符，例如出现次数最多的字符是是'h'。
2. 计算字符'h'到'e'的偏移量，值为3，则表示原文偏移了3 个位置。
3. 将密文所有字符恢复偏移3 个位置

详细代码不再赘述



### 对称加密

#### 介绍

> 加密和解密都是会用一把秘钥，这种加密的方法称为对称加密，也成为单密钥加密。简单理解就是加密解密用的都是同一把钥匙.

凯撒密码就属于对称加密，秘钥为字符的偏移量。

#### 对称加密常用算法

AES、DES、3DES、TDEA、Blowfish、RC2、RC4、IDEA。SKIPJACK等

**AES**：高级加密标准（Advanced Encryption Standard），在密码学中又称为Rijndael 加密。是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001 年11 月26 日发布于FIPS PUB 197，并在2002 年5 月26 日成为有效的标准。2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一。

**DES**：全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。

**3DES**：也叫Triple DES，是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES 加密算法。由于计算机运算能力的增强，原版DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法**。**

**原理**

DES 加密原理（对比特位进行操作，交换位置，异或等等，无需详细了解）

![DES](http://files.jb51.net/file_images/article/201609/201691393457780.jpg?201681393512)

#### 对称加密应用场景

1. 本地数据加密，例如SharedPreferences中的敏感数据
2. 网络传输：post请求参数加密
3. 序列化对象到本地磁盘
4. 网页交互数据加密（https）

#### Android中的算法实现

```java
import java.lang.reflect.Array;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        try {
            //1. get cipher obj
            Cipher cipher = Cipher.getInstance("DES");
            //2. get a secret key
            SecretKey key = KeyGenerator.getInstance("DES").generateKey();
            //3. set the operation mode (encrypt or decrypt)
            cipher.init(Cipher.ENCRYPT_MODE, key);
            //4. do the operation
            
            //the fllowing test

            byte[] src = "hello world".getBytes();
            
            byte[] result = cipher.doFinal(src);
            
            cipher.init(Cipher.DECRYPT_MODE,key);
            
            byte[] result2 = cipher.doFinal(result);

            System.out.println(Arrays.toString(src));
            
            System.out.println(Arrays.toString(result));

            System.out.println(new String(result2));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

AES 算法代码实现同上，只需要把DES参数换成AES参数即可。

BASE64算法：可以参考这篇文章 [让你完全理解BASE64](https://segmentfault.com/a/1190000004533485?_ea=657625)

加密后的结果是字节数组，这些被加密后的字节在码表（例如UTF-8 码表）上找不到对应字符，会出现乱码，当乱码字符串再次转换为字节数组时，长度会变化，导致解密失败，所以转换后的数据是不安全的**。**

使用Base64 对字节数组进行编码，任何字节都能映射成对应的Base64 字符，之后能恢复到字节数组，利于加密后数据的保存于传输，所以转换是安全的**。**同样，字节数组转换成16 进制字符串也是安全的。

密文转换成Base64 编码后的输出结果：

![img](http://files.jb51.net/file_images/article/201609/201691393712753.jpg?201681393727)

密文转换成16 进制编码后的输出结果：

![img](http://files.jb51.net/file_images/article/201609/201691393744142.jpg?20168139381)

Java 里没有直接提供Base64 以及字节数组转16 进制的Api，开发中一般是自己手写或直接使用第三方提供的成熟稳定的工具类（例如apache 的commons-codec）**。**

![Base64码表](http://files.jb51.net/file_images/article/201609/201691393833735.jpg?201681393849)



使用自定义秘钥的方式：

```java
//创建密钥写法1
KeySpec keySpec = new DESKeySpec(key.getBytes());
SecretKey secretKey = SecretKeyFactory.getInstance(ALGORITHM).
generateSecret(keySpec);
//创建密钥写法2
//SecretKey secretKey = new SecretKeySpec(key.getBytes(), KEY_ALGORITHM);
Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
cipher.init(Cipher.DECRYPT_MODE, secretKey);
//得到key 后，后续代码就是Cipher 的写法，此处省略...


```

==注意==：

把秘钥写入代码中是有一定的风险的，当别人反编译代码的时候，可能会看到秘钥。

因此，Android 开发里建议用JNI 把秘钥值写到C 代码里，甚至拆分成几份，最后再组合成真正的秘钥。

算法/工作模式/填充模式

初始化cipher 对象时，参数可以直接传算法名：例如：

Cipher c = Cipher.getInstance("DES");

也可以指定更详细的参数，格式：”algorithm/mode/padding” ，即”算法/工作模式/填充模式”

Cipher c = Cipher.getInstance("DES/CBC/PKCS5Padding");



#### 密码块工作模式

块密码工作模式(Block cipher mode of operation)，是对于按块处理密码的加密方式的一种扩充，不仅仅适用于AES，包括DES, RSA 等加密方法同样适用。

![填充模式](http://files.jb51.net/file_images/article/201609/201691393958309.jpg?201681394014)

#### 填充模式

填充(Padding)，是对需要按块处理的数据，当数据长度不符合块处理需求时，按照一定方法填充满块长的一种规则。

![填充模式](http://files.jb51.net/file_images/article/201609/201691394044499.jpg?20168139413)



```java
	
//秘钥算法
private static final String KEY_ALGORITHM = "DES";
//加密算法：algorithm/mode/padding 算法/工作模式/填充模式
private static final String CIPHER_ALGORITHM = "DES/ECB/PKCS5Padding";
//秘钥
private static final String KEY = "12345678";//DES 秘钥长度必须是8 位或以上
//private static final String KEY = "1234567890123456";//AES 秘钥长度必须是16 位
//初始化秘钥
SecretKey secretKey = new SecretKeySpec(KEY.getBytes(), KEY_ALGORITHM);
Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
//加密
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
byte[] result = cipher.doFinal(input.getBytes());
//注意：AES、DES 在CBC 操作模式下需要iv 参数

//AES、DES 在CBC 操作模式下需要iv 参数
IvParameterSpec iv = new IvParameterSpec(key.getBytes());
//加密
cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
```

#### 总结

DES 安全度在现代已经不够高，后来又出现的3DES 算法强度提高了很多，但是其执行效率低下，AES算法加密强度大，执行效率高，使用简单，实际开发中建议选择AES 算法**。**实际android 开发中可以用对称加密（例如选择AES 算法）来解决很多问题，例如：

1. 做一个管理密码的app，我们在不同的网站里使用不同账号密码，很难记住，想做个app 统一管理，但是账号密码保存在手机里，一旦丢失了容易造成安全隐患，所以需要一种加密算法，将账号密码信息加密起来保管，这时候如果使用对称加密算法，将数据进行加密，秘钥我们自己记在心里，只需要记住一个密码**。**需要的时候可以还原信息。
2. android 里需要把一些敏感数据保存到SharedPrefrence 里的时候，也可以使用对称加密，这样可以在需要的时候还原**。**
3. 请求网络接口的时候，我们需要上传一些敏感数据，同样也可以使用对称加密，服务端使用同样的算法就可以解密**。**或者服务端需要给客户端传递数据，同样也可以先加密，然后客户端使用同样算法解密.


## 1.2 非对称加密

### 介绍

> 因j加密与解密的过程中使用的是两个不同的密钥，因此这种加密算法叫做非对称加密。

非对称加密的算法需要两个密钥，即公钥(public key)与私钥(private key)。公钥与私钥是一对的，用公钥加密的数据只能对应的私钥可以解密，反之亦然。

加密过程图：

![非对称加密示意图](http://files.jb51.net/file_images/article/201609/201691395826126.jpg?201681395841)

### 常见算法

#### RSA

> 历史：RSA[公钥](http://baike.baidu.com/item/%E5%85%AC%E9%92%A5)[加密算法](http://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)是1977年由[罗纳德·李维斯特](http://baike.baidu.com/item/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9)（Ron Rivest）、[阿迪·萨莫尔](http://baike.baidu.com/item/%E9%98%BF%E8%BF%AA%C2%B7%E8%90%A8%E8%8E%AB%E5%B0%94)（Adi Shamir）和[伦纳德·阿德曼](http://baike.baidu.com/item/%E4%BC%A6%E7%BA%B3%E5%BE%B7%C2%B7%E9%98%BF%E5%BE%B7%E6%9B%BC)（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。
>
> RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥[数据加密标准](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)。
>
> 今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在[分布式计算](http://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97)和[量子计算机](http://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA)理论日趋成熟的今天，RSA加密安全性受到了挑战。
>
> RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
>
> ​                  								来自百度百科



质因数、欧拉函数、模反元素

Java当中的代码示例

```java
 public static void asymmetricEncription(){
        
        String content =  "hello asymmetricEncription";
        
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            KeyPair keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();

            PublicKey publicKey = keyPair.getPublic();
            PrivateKey privateKey = keyPair.getPrivate();
            
            cipher.init(Cipher.ENCRYPT_MODE,publicKey);
            byte[] result = cipher.doFinal(content.getBytes());

            System.out.println("加密结果:" + new String(result));
            
            cipher.init(Cipher.DECRYPT_MODE,privateKey);
            result = cipher.doFinal(result);

            System.out.println("解密结果:" + new String(result));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

==注意：一次性加密的数据长度不能大于117字节，一次性解密的数据长度不能大于128字节==

```java
private static final int ENCRYPT_BLOCK_MAX = 117;
private static final int DECRYPT_BLOCK_MAX = 128;
```



分批操作：

```java
public static byte[] doFinnalWithBatch(byte[] content,Cipher cipher, int blockSize) throws Exception{
        int offset = 0;
        int length = content.length;
        byte[] tmp;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        while (length - offset > 0){
            if (length - offset >= blockSize){
                tmp = cipher.doFinal(content,offset,blockSize);
            }else {
                tmp = cipher.doFinal(content,offset,length - offset);
            }
            baos.write(tmp);
            offset += blockSize;
        }
        baos.close();
        return baos.toByteArray();
    }
```



#### 非对称加密的用途

##### 身份认证

> 一条加密后的信息如果能以A的公钥解密，那么这条信息一定是以A的私钥加密的，能够确定该用户是A。

![身份认证](http://files.jb51.net/file_images/article/201609/2016913100004909.jpg?201681310024)

##### 陌生人的安全通信

> A和B两个互不相识，A和B之间相互交换各自的公钥，则双方可以通过对方的公钥加密信息通信。C虽然能够截获到A和B的公钥，但是他解不开密文。

![陌生人安全通信](http://files.jb51.net/file_images/article/201609/2016913100051922.jpg?20168131013)



##### 秘钥的交换

> 通过非对称加密对称加密的秘钥，安全得到对称秘钥后，使用对称加密通信。

如下图：

![混合加密](/img/encryption/混合加密.png)

即使他人获取了二者的公钥，由于没有A和B的私钥，无法解密就无法获取加密后的密钥。

##### 综述

非对称加密一般不会单独使用，其目的并不是取代对称加密而出现的，非对称加密速度比对称加密慢很多，极端情况慢1000倍，所以一般不会用来加密大量数据，通常将对称与非对称两种技术混合起来，即上文所述的密钥交换。



## 1.3 消息摘要（Message Digest）

### 常见算法

MD5，SHA，CRC等。

### 使用场景

1. 用户密码md5加密后保存到数据库里
2. 软件下载站，使用消息摘要计算文件指纹，防止被篡改（各种ROM啊之类的以前就是这样）。
3. 数字签名
4. 百度云，360云盘的网盘的秒传功能用的是sha1值
5. Eclipse和Android Studio开发工具根据sha1值来判断v4，v7包是否冲突
6. 银行密码MD5加密



### 介绍

#### MD5

>Message Digest Algorithm MD5（中文名为[消息摘要算法](http://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95)第五版）为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。该算法的文件号为RFC 1321（R.Rivest,MIT Laboratory for Computer Science and RSA Data Security Inc. April 1992）。
>
>**MD5**即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译[摘要算法](http://baike.baidu.com/item/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95)、[哈希算法](http://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、[MD3](http://baike.baidu.com/item/MD3)和[MD4](http://baike.baidu.com/item/MD4)。
>
>MD5算法具有以下特点：
>
>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
>
>2、容易计算：从原数据计算出MD5值很容易。
>
>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
>
>4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
>
>MD5的作用是让大容量信息在用[数字签名](http://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D)软件签署私人[密钥](http://baike.baidu.com/item/%E5%AF%86%E9%92%A5)前被"[压缩](http://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9/13032501)"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的[十六进制](http://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6)数字串）。除了MD5以外，其中比较有名的还有[sha-1](http://baike.baidu.com/item/sha-1)、[RIPEMD](http://baike.baidu.com/item/RIPEMD)以及Haval等。

MD5有很多应用，其典型应用是对一段信息（message）产生信息摘要（message-digest），以防止被篡改。比如在Unix下有很多软件在下载的时候都哟一个文件名相同，扩展文为.md5的文件，其中的文本是该软件压缩包的md5值，防止软件包被篡改。此外还用在数字签名上，也可以广泛用于操作系统的登录认证上。



#### SHA

>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种“[指纹](http://baike.baidu.com/item/%E6%8C%87%E7%BA%B9)”或是“摘要”所以对散列值的[数字签名](http://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D)就可以视为对此明文的数字签名。

#### CRC

>循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。

在数据传输过程中，无论传输系统的设计再怎么完美，差错总会存在，这种差错可能会导致在链路上传输的一个或者多个帧被破坏(出现比特差错，0变为1，或者1变为0)，从而接受方接收到错误的数据。为尽量提高接受方收到数据的正确率，在接收方接收数据之前需要对数据进行差错检测，当且仅当检测的结果为正确时接收方才真正收下数据。检测的方式有多种，常见的有奇偶校验、因特网校验和循环冗余校验等。



#### 使用

```java
 
    public static void HexCode(){
        byte[] src = "hello MD5!".getBytes();
        String result = null;
        try {
            MessageDigest md5digest = MessageDigest.getInstance("MD5");
            MessageDigest shadigest = MessageDigest.getInstance("SHA1");
            byte[] target1 = md5digest.digest(src);
            byte[] target2 = shadigest.digest(src);
            System.out.println(new String(target1));
            System.out.println("===================");
            System.out.println(new String(target2));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
```

消息摘要后的结果是固定的长度，无论源数据多大，摘要后的结果都是固定长度的。



#### 数字摘要原理

>数字摘要是将任意长度的消息变成固定长度的短消息，它类似于一个自变量是消息的函数，也就是Hash函数。数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。



```java
//获取实例
MessageDigest digest = MessageDigest.getInstance("MD5");
digest.update(key.getBytes());
byte[] bytes = digest.digest(key.getBytes());
StringBuilder sb = new StringBuilder();
for (int i = 0; i < bytes.length; i++) {
 String hex = Integer.toHexString(bytes[i]&0xff);
 if (hex.length() == 1){
 sb.append("0");
 }
 sb.append(hex);
}
String hexstring = sb.toString();

```





## 1.3 数字签名

### 概述

数字签名是非对称加密与数字摘要的组合应用

### 应用场景

校验身份

>使用私钥签名，公钥校验，只要用公钥能校验通过，则该信息一定是私钥持有者发布的。

校验数据完整性

> 用解密后的消息摘要与原文的消息摘要进行对比



### 签名的过程

“发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。

数字签名有两种功效：一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。二是数字签名能确定消息的完整性。因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。一次数字签名涉及到一个哈希函数、发送者的公钥、发送者的私钥。”

![图解签名过程](http://files.jb51.net/file_images/article/201609/2016913102609050.png?2016813102649)



```java
//获取signature 对象，初始化算法：MD2withRSA, MD5withRSA, or SHA1withRSA
Signature signature = Signature.getInstance("MD5withRSA");
//创建私钥（从磁盘上读取）
PrivateKey privateKey = (PrivateKey)SerializableUtil.readObject(
"heima.privateKey");
//使用私钥进行初始化
signature.initSign(privateKey);
//传入需要签名的数据
signature.update(content.getBytes());
//执行签名
byte[] sign = signature.sign();
 
//创建公钥（从磁盘上读取）
PublicKey publicKey = (PublicKey) SerializableUtil.readObject(
"heima.publicKey");
//使用公钥进行初始化
signature.initVerify(publicKey);
//传入需要校验的数据（即上面的原文）
signature.update(content.getBytes());
//执行校验
boolean verify = signature.verify(sign);

```

###  总结

数字签名一般不单独使用，基本都是用在数字证书里实现SSL 通信协议。



## 1.4 数字证书

### 概述

数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet 上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA 机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。



### 应用场景

交易者身份的确定性、不可否认性、不可修改性
对应用进行签名认证（例如Android 的apk）



### 数字证书格式

![图解数字证书格式](http://files.jb51.net/file_images/article/201609/2016913102801570.png?2016813102815)

数字证书的格式普遍采用的是X.509V3 国际标准，一个标准的X.509 数字证书包含以下一些内容：

1. 证书的版本信息；
2. 证书的序列号，每个证书都有一个唯一的证书序列号；
3. 证书所使用的签名算法；
4. 证书的发行机构名称，命名规则一般采用X.500 格式；
5. 证书的有效期，通用的证书一般采用UTC 时间格式，它的计时范围为1950-2049；
6. 证书所有人的名称，命名规则一般采用X.500 格式；
7. 证书所有人的公开密钥；
8. 证书发行者对证书的签名。



### 数字证书原理

![原理图解](http://files.jb51.net/file_images/article/201609/2016913102838397.png?2016813102852)



数字证书是安全领域里的终极武器，SSL 通信协议里最核心的东西就是数字证书。他涉及到前面提到的所有知识：对称加密、非对称加密、消息摘要、数字签名等。

数字证书可以通过java 自带的KeyTool 工具生成，生成后的数字证书一般保管在KeyStore 里。KeyStore可以叫做秘钥仓库。

秘钥仓库可以保管3 种类型的数据：KeyStore.PrivateKeyEntry（非对称机密里的私钥）、KeyStore.SecretKeyEntry （对称加密里的秘钥）、KeyStore.TrustedCertificateEntry（受信任的证书）



### 工具

keytool 

### Android中的keystore相关知识

debug.keystore 的别名（alias）及密码: 
别名：androiddebugkey，密码：android

签名命令(jdk1.6)：

jarsigner -verbose -keystore debug.keystore -signedjar 1signed.apk 1.apk androiddebugkey

签名命令(jdk1.7)：

jarsigner -verbose -keystore debug.keystore -signedjar 1signed.apk 1.apk androiddebugkey -digestalg
SHA1 -sigalg MD5withRSA

优化命令：

zipalign -v 4 1signed.apk 1signedaligned.apk

验证签名是否成功：

jarsigner -verify 1signed.apk



### 签名证书

#### 签名证书

由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性 

例如根证书机构Symantec 颁发给百度的就是签名证书，是受信任的。

![img](http://files.jb51.net/file_images/article/201609/2016913103158061.png?2016813103212)

**自签名证书：**

由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同. 

例如中铁集团（SRCA）办法给12306 的证书就是自签名证书，自己给自己颁发的。

![img](http://files.jb51.net/file_images/article/201609/2016913103238930.png?2016813103254)



## 1.5 Https

### 概述

SSL(Secure Sockets Layer 安全套接层)，为网景公司(Netscape)所研发，用以保障在Internet 上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。一般通用之规格为40 bit 之安全标准，美国则已推出128 bit 之更高安全标准，但限制出境。只要3.0 版本以上之I.E.或Netscape 浏览器即可支持SSL。

TLS（Transport Layer Security 传输层安全），用于在两个通信应用程序之间提供保密性和数据完整性。TLS 是SSL 的标准化后的产物，有1.0 ，1.1 ，1.2 三个版本，默认使用1.0。TLS1.0 和SSL3.0 几乎没 
有区别，事实上我们现在用的都是TLS，但因为历史上习惯了SSL 这个称呼。

SSL通信简单图示：

![图示](http://files.jb51.net/file_images/article/201609/2016913103906880.png?2016813103922)

SSL 通信详细图示：

![详细图示](http://files.jb51.net/file_images/article/201609/2016913103944100.png?2016813103959)



当请求使用自签名证书的网站数据时，例如请求12306 的客运服务页面：[https://kyfw.12306.cn/otn/](https://kyfw.12306.cn/otn/)，则会报下面的错误，原因是客户端的根认证机构不能识别该证书错误信息：unable to find valid certification path to requested target



```java
public static void main(String[] args) throws Exception {
//协议传输层安全TLS(transport layer secure)
SSLContext sslContext = SSLContext.getInstance("TLS");
//创建信任管理器（TrustManager 负责校验证书是否可信）
TrustManager[] tm = new TrustManager[]{new EmptyX509TrustManager()};
//使用自定义的信任管理器初始化SSL 上下文对象
sslContext.init(null, tm, null);
//设置全局的SSLSocketFactory 工厂（对所有ssl 链接都产生影响）
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
 
 //URL url = new URL("https://www.baidu.com");
 URL url = new URL("https://kyfw.12306.cn/otn/");
 HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
 InputStream in = conn.getInputStream();
 System.out.println(Util.inputstream2String(in));
 }
 
 /**
 * 自定义一个什么都不做的信任管理器，所有证书都不做校验，一律放行
 */
 private static class EmptyX509TrustManager implements X509TrustManager{
 @Override
 public void checkClientTrusted(X509Certificate[] chain, String authType)
 throws CertificateException {
 }
 
 @Override
 public void checkServerTrusted(X509Certificate[] chain, String authType)
 throws CertificateException {
 }
 
 @Override
 public X509Certificate[] getAcceptedIssuers() {
 return null;
 }
}

```





12306 服务器出示的证书是中铁集团SRCA 给他颁发的，所以SRCA 的证书是能够识别12306 的证书的，所以只需要把SRCA 证书导入系统的KeyStore 里，之后交给TrustManagerFactory 进行初始化，则可把SRCA 添加至根证书认证机构，之后校验的时候，SRCA 对12306 证书校验时就能通过认证。

这种解决方案有两种使用方式：一是直接使用SRCA.cer 文件，二是使用改文件的RFC 格式数据，将其写在代码里。









```java
//12306 证书的RFC 格式（注意要记得手动添加两个换行符）
 private static final String CERT_12306_RFC = "-----BEGIN CERTIFICATE-----\n"+
"MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn"+
"BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X"+
"DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp"+
"bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3"+
"DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2"+
"9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6"+
"D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle"+
"tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov"+
"LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt"+
"x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV"+
"23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ"+ 
"og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A=="+ 
"-----END CERTIFICATE-----\n";
 public static void main(String[] args) throws Exception {
 // 使用传输层安全协议TLS(transport layer secure)
 SSLContext sslContext = SSLContext.getInstance("TLS");
 //使用SRCA.cer 文件的形式
 
//FileInputStream certInputStream = new FileInputStream(new File("srca.cer"));
//也可以通过RFC 字符串的形式使用证书
ByteArrayInputStream certInputStream = new
ByteArrayInputStream(CERT_12306_RFC.getBytes());
// 初始化keyStore，用来导入证书
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
//参数null 表示使用系统默认keystore，也可使用其他keystore（需事先将srca.cer 证书导入
keystore 里）
keyStore.load(null);
//通过流创建一个证书
Certificate certificate = CertificateFactory.getInstance("X.509")
.generateCertificate(certInputStream);
// 把srca.cer 这个证书导入到KeyStore 里，别名叫做srca
keyStore.setCertificateEntry("srca", certificate);
// 设置使用keyStore 去进行证书校验
TrustManagerFactory trustManagerFactory = TrustManagerFactory
.getInstance(TrustManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init(keyStore);
//用我们设定好的TrustManager 去做ssl 通信协议校验，即证书校验
sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext
.getSocketFactory());
URL url = new URL("https://kyfw.12306.cn/otn/");
HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
InputStream in = conn.getInputStream();
System.out.println(Util.inputstream2String(in));
}

```









### Android中的Https请求



把scra.cer 文件考到assets 或raw 目录下，或者直接使用证书的RFC 格式，接下来的做法和java工程代码一样

```java
//ByteArrayInputStream in = new ByteArrayInputStream("rfc".getBytes());
CertificateFactory cf = CertificateFactory.getInstance("X.509");
InputStream caInput = new BufferedInputStream(new FileInputStream("load-der.crt"));
Certificate ca;
try {
 ca = cf.generateCertificate(caInput);
 System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());
} finally {
 caInput.close();
}
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry("ca", ca);
 
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);
 
SSLContext context = SSLContext.getInstance("TLS");
context.init(null, tmf.getTrustManagers(), null);
 
URL url = new URL("https://certs.cac.washington.edu/CAtest/");
HttpsURLConnection urlConnection =
 (HttpsURLConnection)url.openConnection();
urlConnection.setSSLSocketFactory(context.getSocketFactory());
InputStream in = urlConnection.getInputStream();
copyInputStreamToOutputStream(in, System.out);

```

双向验证

```java
CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore.load(null);
 
SSLContext sslContext = SSLContext.getInstance("TLS");
TrustManagerFactory trustManagerFactory = TrustManagerFactory.
 getInstance(TrustManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init(keyStore);
 
//初始化keystore
KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
clientKeyStore.load(getAssets().open("client.bks"), "123456".toCharArray());
 
KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(clientKeyStore, "123456".toCharArray());
 
sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());

```



### 什么是SSH，它和SSL有什么区别和联系？

http://blog.csdn.net/ocean1010/article/details/6950924

SSH = security shell它就是个shell

github使用ssh就是为了验证你的身份是合法的，SSHKEY就是保证每次传输都是安全的。否则你每次需要输入账户和密码。SSH用的是非对称加密。





















## 参考文档与其他知识链接

[英格玛与图灵](https://www.zhihu.com/question/28397034)

[数字签名](http://www.2cto.com/article/201407/315433.html)

[What is a Digital Signature](http://www.youdzone.com/signature.html)(图解数字证书)

[数字证书原理](http://www.2cto.com/article/201203/122095.html)



