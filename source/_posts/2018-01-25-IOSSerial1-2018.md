---
layout:     post
title:      "IOSç³»åˆ—æ•™ç¨‹1"
subtitle:   "Swift Basics"
date:       2018-01-25 13:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - IOS
    - Swift4.0.3	
---



[TOC]

# The Basics

 `Swift`æ˜¯ç±»`C`ä¸`OC`è¯­è¨€,æä¾›äº†è‡ªå·±çš„ä¸€äº›ç±»å‹,åŒ…æ‹¬åŸºæœ¬ç±»å‹,ä¾‹å¦‚`Int,String,Double`,æ­¤å¤–,è¿˜æä¾›äº†å¼ºå¤§çš„ä¸‰ç§åŸç”Ÿé›†åˆç±»å‹`Array,Set`ä¸`Dictionary`.

 `Swift`æ˜¯ç±»å‹å®‰å…¨çš„è¯­è¨€,è¿™å°±æ„å‘³ç€è¯­è¨€æœ¬èº«ä¼šå¸®åŠ©ä½ å†™å‡ºæ›´åŠ å®‰å…¨çš„ä»£ç .åœ¨ç¼–è¯‘é˜¶æ®µå°±èƒ½å¤Ÿæå‰æŒ‡å‡ºé”™è¯¯.

## Constants and Variables

### Declaring Constants and Variables

```swift
let maximumNumberOfLoginAttempts = 10 //å£°æ˜ä¸€ä¸ªå¸¸é‡,ç±»å‹æ¨æ–­ä¸ºInt,æ³¨æ„ä¹¦å†™æ ¼å¼,å¯ä»¥çœç•¥åˆ†å·
var currentLoginTemp = 0    //å£°æ˜ä¸€ä¸ªå˜é‡
var x = 1.0, y = 0.0, z = 0.0 //åŒæ—¶å£°æ˜å¤šä¸ªå˜é‡
```

> NOTE
>
> å¦‚æœå£°æ˜ä¸€ä¸ªå¸¸é‡,å°½é‡ä½¿ç”¨`let`å£°æ˜ä¸€ä¸ªå¸¸é‡.æ³¨æ„è¿™ä¸ªå¸¸é‡æ˜¯å­˜å‚¨ä¸€ä¸ªå€¼,è€Œä¸æ˜¯ä¸€ä¸ªå¼•ç”¨

### Type Annotations

æ˜¾ç¤ºçš„æŒ‡å®šä¸€ä¸ªå˜é‡çš„ç±»å‹,å¯ä»¥ä½¿ç”¨ç±»å‹é™å®š,æˆ–è€…å«åšç±»å‹æ ‡æ³¨.

```swift
var welcomeMessage: String   //ç±»å‹é™å®š,ä¸Kotlinæ˜¯ä¸€æ ·çš„.
welcomeMessage = "hello"
var red, green, blue: Double
```

> NOTE
>
> å®é™…ç¼–ç ä¸­,å¾ˆå°‘ä¼šç”¨åˆ°æ˜¾ç¤ºæŒ‡å®šç±»å‹,å½“ä½ ä¸ºä¸€ä¸ªå˜é‡æˆ–å¸¸é‡åˆå§‹åŒ–ä¸€ä¸ªå€¼çš„æ—¶å€™.`Swfit`å¯ä»¥æ¨æ–­å‡ºå˜é‡çš„ç±»å‹.

### Naming Constants and Variables

å˜é‡å’Œå¸¸é‡å¯ä»¥åŒ…å«å‡ ä¹ä»»æ„çš„å­—ç¬¦,åŒ…æ‹¬`Unicode`å­—ç¬¦:

```swift
let Ï€ = 3.14159 // å£°æ˜äº†ä¸‰ä¸ªå¸¸é‡,å¯¹åº”Kotlinä¸­çš„val
let ä½ å¥½ = "ä½ å¥½ä¸–ç•Œ"
let ğŸ¶ğŸ® = "dogcow"
```

å˜é‡å’Œå¸¸é‡çš„åç§°ä¸èƒ½åŒ…å«ç©ºæ ¼,æ•°å­¦ç¬¦å·,ç®­å¤´æˆ–æ— æ•ˆçš„`Unicode`å­—ç¬¦ç­‰,å˜é‡å’Œå¸¸é‡åªèƒ½è¢«å£°æ˜ä¸€æ¬¡,å¹¶ä¸”æ— æ³•å˜æ›´å…¶å¯å˜æ€§.

>NOTE
>
>å¯ä»¥ä½¿ç”¨"``"å°†å…³é”®å­—æˆ–è€…åŒåçš„å˜é‡æˆ–å¸¸é‡åŒºåˆ†å¼€æ¥,ä½†æ˜¯å°½é‡ä¸è¦è¿™ä¹ˆåš.

```swift
var `class` = 100
print(`class`)
```

### Printing Constants and Variables

`print`å‡½æ•°æ˜¯ä¸€ä¸ªå…¨å±€å‡½æ•°èƒ½å¤Ÿæ‰“å°ä¸€ä¸ªæˆ–å¤šä¸ªvalueåˆ°åˆé€‚çš„è¾“å‡º. ä½¿ç”¨å ä½ç¬¦æ¥æ‰“å°å˜é‡

```swift
var name: String = "LeoHe"

print(name)

print("Hello World \(name)")   // ä½¿ç”¨ \(varName) è¿™ç§å½¢å¼åœ¨å­—ç¬¦ä¸²ä¸­ç«™ä½,æ‰“å°å˜é‡å€¼
print("Hello World \(1 + 2)")  // æˆ–è€…æ±‚ä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼éƒ½å¯ä»¥;
//ç±»ä¼¼Kotlinä¸­çš„"{ expression }"è¿™ç§å½¢å¼çš„ç«™ä½.
```

## Comments

æ³¨é‡Š

```swift
// This is a comment

/* This is also a comment
  but is written over multiple lines */

/* This is the start of the first multiline comment.
 /* This is the second, nested multiline comment. */
 This is the end of the first multiline comment. */
```

## Semicolons

Swift ä¸å¼ºåˆ¶è¦æ±‚å†™åˆ†å·,ä½†æ˜¯å½“ä¸¤ä¸ªè¡¨è¾¾å¼éœ€è¦å†™åœ¨ä¸€è¡Œçš„æ—¶å€™,è¿˜æ˜¯éœ€è¦å†™åˆ†å·.è·ŸKotlinä¸€æ ·.

```swift
let cat = "ğŸ±"; print(cat)
// Prints "ğŸ±"
```

## Integers

Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type `UInt8`, and a 32-bit signed integer is of type `Int32`. Like all types in Swift, these integer types have capitalized names.

æ³¨æ„æ•´æ•°çš„å¹³å°ç›¸å…³æ€§,ä»¥åŠæœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´æ•°çš„åŒºåˆ«

### Integer Bounds

```swift
let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
```

### Int

In most cases, you donâ€™t need to pick a specific size of integer to use in your code. Swift provides an additional integer type, `Int`, which has the same size as the current platformâ€™s native word size:

- On a 32-bit platform, `Int` is the same size as `Int32`.
- On a 64-bit platform, `Int` is the same size as `Int64`.

### UInt

Swift also provides an unsigned integer type, `UInt`, which has the same size as the current platformâ€™s native word size:

- On a 32-bit platform, `UInt` is the same size as `UInt32`.
- On a 64-bit platform, `UInt` is the same size as `UInt64`.

>NOTE
>
>Use `UInt` only when you specifically need an unsigned integer type with the same size as the platformâ€™s native word size. If this isnâ€™t the case, `Int` is preferred, even when the values to be stored are known to be nonnegative. A consistent use of `Int` for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in [Type Safety and Type Inference](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID322).

## Floating-Point Numbers

æ³¨æ„æµ®ç‚¹æ•°çš„å°æ•°ç‚¹åæœ‰å‡ ä½,å¦‚æœéœ€æ±‚ç²¾åº¦ä¸é«˜,å¯ä»¥ä½¿ç”¨float

Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an `Int`. Swift provides two signed floating-point number types:

- `Double` represents a 64-bit floating-point number.
- `Float` represents a 32-bit floating-point number.

>NOTE
>
>`Double` has a precision of at least 15 decimal digits, whereas the precision of `Float` can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, `Double` is preferred.



## Type Safety and Type Inference

`Swfit`ä½¿ç”¨ç±»å‹æ¨æ–­æ¥åœ¨ç¼–è¯‘é˜¶æ®µæ¨å‡ºå˜é‡æˆ–å¸¸é‡çš„ç±»å‹ä¿¡æ¯.

```swift
let pi = 3.14159
// pi is inferred to be of type Double
let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double
```

## Numeric Literals

Integer literals can be written as:

- A *decimal* number, with no prefix åè¿›åˆ¶,æ— å‰ç¼€
- A *binary* number, with a `0b` prefix äºŒè¿›åˆ¶
- An *octal* number, with a `0o` prefix å…«è¿›åˆ¶
- A *hexadecimal* number, with a `0x` prefix åå…­è¿›åˆ¶

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
```

ç§‘å­¦è®¡æ•°æ³•

For decimal numbers with an exponent of `exp`, the base number is multiplied by 10exp:

- `1.25e2` means $1.25 * 10^2$, or `125.0`.
- `1.25e-2` means $1.25 * 10^{-2}$, or `0.0125`.

For hexadecimal numbers with an exponent of `exp`, the base number is multiplied by 2exp:

- `0xFp2` means $15 * 2^2$, or `60.0`.
- `0xFp-2` means $15 * 2^{-2}$, or `3.75`.

```swift
//ä¸€ä¸‹å„ä¸ªå€¼éƒ½æ˜¯ç›¸åŒçš„12.1875
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeros and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:

ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”ä½¿å¾—æ•°å­—æ›´åŠ å®¹æ˜“è¯»(åˆè·ŸKotlinä¸€æ ·)

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```



## Numeric Type Conversion

æ€»ç»“ä¸ºä¸€å¥è¯,èƒ½ç”¨`Int`å°½é‡ç”¨,é™¤éä¸ºäº†æ€§èƒ½,æˆ–è€…æ˜¯å†…å­˜æ§åˆ¶,æˆ–è€…æ˜¯å…¶ä»–å¿…è¦çš„ä¼˜åŒ–,å†ä½¿ç”¨å…¶ä»–ç±»å‹çš„`Int`.

### Integer Conversion

The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An `Int8` constant or variable can store numbers between `-128` and `127`, whereas a `UInt8` constant or variable can store numbers between `0` and `255`. A number that wonâ€™t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 cannot store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 cannot store a number larger than its maximum value,
// and so this will also report an error
```

ä½¿ç”¨åœºæ™¯:æ¯”å¦‚ä¸€ä¸ªBitmap -ARGB-8888,æ¯ä¸ªé€šé“å°±å¯ä»¥ä½¿ç”¨UInt8æ¥è¡¨ç¤º

æ˜¾ç¤ºç±»å‹è½¬æ¢

To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant `twoThousand` is of type `UInt16`, whereas the constant `one` is of type `UInt8`. They canâ€™t be added together directly, because theyâ€™re not of the same type. Instead, this example calls `UInt16(one)` to create a new `UInt16` initialized with the value of `one`, and uses this value in place of the original:

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```



### Integer and Floating-Point Conversion

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi equals 3.14159, and is inferred to be of type Double
```

Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a `Double` or `Float` value:

```swift
let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int
```

Floating-point values are always truncated when used to initialize a new integer value in this way. This means that `4.75` becomes `4`, and `-3.9` becomes `-3`.

æµ®ç‚¹æ•°å‘æ•´æ•°è½¬æ¢ä¼šæŸå¤±ç²¾åº¦.

## Type Aliases

ç±»å‹åˆ«åå°±æ˜¯ä¸ºç°æœ‰çš„ç±»å‹å®šä¹‰ä¸€ä¸ªå¯é€‰çš„åç§°,ä½¿ç”¨`typealias`å…³é”®å­—å®šä¹‰.è¿™ä¸ªå’ŒKotlinä¹Ÿæ˜¯ä¸€æ ·çš„,Kotlinå’ŒSwiftæ˜¯ä¸æ˜¯æœ‰ä¸€è…¿.

åœ¨Kotlinä¸­,ç±»å‹åˆ«åä¸€èˆ¬åœ¨å®šä¹‰æ³›å‹æˆ–è€…å‡½æ•°ç±»å‹æ—¶ç‰¹åˆ«æœ‰ç”¨,å¯ä»¥ç¼©çŸ­è¯­æ³•,çœ‹èµ·æ¥æ›´åŠ ç²¾ç‚¼,å¹¶ä¸”ä½¿å¾—å‡½æ•°ç±»å‹å‚æ•°å˜çš„æœ‰æ„ä¹‰äº†.

```swift
typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0
//Here, AudioSample is defined as an alias for UInt16. Because itâ€™s an alias, the call to AudioSample.min actually calls UInt16.min, which provides an initial value of 0 for the maxAmplitudeFound variable.

```

## Booleans

Swift has a basic *Boolean* type, called `Bool`. Boolean values are referred to as *logical*, because they can only ever be true or false. Swift provides two Boolean constant values, `true` and `false`:

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false

if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// Prints "Eww, turnips are horrible."
```

Swiftâ€™s type safety prevents non-Boolean values from being substituted for `Bool`. The following example reports a compile-time error:

ä¸å…è®¸å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå¸ƒå°”ç±»å‹

```swift
let i = 1
if i {
    // this example will not compile, and will report an error
}

let i = 1
if i == 1 {
    // this example will compile successfully
}

```

## Tupels

å…ƒç»„

*Tuples* group multiple values into a single compound value. The values within a tuple can be of any type and donâ€™t have to be of the same type as each other.

```swift
let http404Error = (404, "Not Found")
// http404Error is of type (Int, String), and equals (404, "Not Found")

//deconstruction è§£æ„å…ƒç»„
let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// Prints "The status code is 404"
print("The status message is \(statusMessage)")
// Prints "The status message is Not Found"
```

`Kotlin`ä¸­çš„å…ƒç»„åˆ†ä¸ºäºŒå…ƒ`Pair`å’Œä¸‰å…ƒ`Triple`.

```kotlin
var (a,b) = Pair(20,"hello") //è§£æ„å…ƒç»„
var (a,b,c) = Triple(200,true,"ni")
val tuple = Pair(20,"hello")
val (m,n) = tuple
//ä½¿ç”¨ä¸‹åˆ’çº¿å¿½ç•¥ä¸€ä¸ªè§£æ„
val(r,_) = tuple
```

If you only need some of the tupleâ€™s values, ignore parts of the tuple with an underscore (`_`) when you decompose the tuple:

```swift
let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// Prints "The status code is 404"
```

Alternatively, access the individual element values in a tuple using index numbers starting at zero:

ä½¿ç”¨å…ƒç»„çš„é¡ºåºç´¢å¼•å…ƒç»„å…ƒç´ .

```swift
print("The status code is \(http404Error.0)")
// Prints "The status code is 404"
print("The status message is \(http404Error.1)")
// Prints "The status message is Not Found"
```

`Kotlin`ä½¿ç”¨first,second,thirdæŒ‡å®šå…ƒç»„ä¸­å…ƒç´ çš„é¡ºåº(åœ¨Kotlinä¸­,å…ƒç»„æ˜¯ä¸€ä¸ªç±»å‹,ä½¿ç”¨å±æ€§ç´¢å¼•å…ƒç´ )

```kotlin
val v = Triple(1, 2, 3)
println("${v.first},${v.second},${v.third}")
```

You can name the individual elements in a tuple when the tuple is defined:

==å®šä¹‰å…ƒç»„çš„æ—¶å€™,å¯ä»¥é™å®šå…ƒç»„ä¸­å…ƒç´ çš„åç§°,æ³¨æ„äº†,è¿™é‡Œå’ŒKotlinä¸ä¸€æ ·äº†å•Š!==

å¯ä»¥ä½¿ç”¨å…ƒç´ åç§°ç´¢å¼•å…ƒç»„ä¸­çš„å…ƒç´ 

```swift
let http200Status = (statusCode: 200, description: "OK")
print("The status code is \(http200Status.statusCode)")
// Prints "The status code is 200"
print("The status message is \(http200Status.description)")
// Prints "The status message is OK"
```

Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the `(Int, String)` tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see [Functions with Multiple Return Values](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID164).

å…ƒç»„éå¸¸é€‚åˆä½œä¸ºå‡½æ•°çš„è¿”å›å€¼,å½“å‡½æ•°æœ‰å¤šä¸ªè¿”å›å€¼çš„æ—¶å€™,ä½¿ç”¨å…ƒç»„ä½œä¸ºè¿”å›èƒ½å¤Ÿä¸€æ¬¡æ€§è¿”å›å¤šä¸ªæ•°å€¼,è€Œçœå»äº†åŒ…è£…ä¸€ä¸ªå¯¹è±¡

```swift
//å…ƒç»„å¯ä»¥å®šä¹‰å¤šä¸ªå…ƒç´ ,Kotlinåº”è¯¥æ˜¯ç”šè‡³æœ‰äºŒå…ƒå’Œä¸‰å…ƒ.
let http200Status = (statusCode: 200, description: "OK", type: "success")
```

==Kotlinçš„ç»“æ„å£°æ˜å¯ä»¥ä½¿ç”¨åœ¨ç»“åˆçš„éå†å½“ä¸­==

==å› ä¸ºæ•°æ®ç±»è‡ªåŠ¨å£°æ˜ componentN() å‡½æ•°ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ç”¨è§£æ„å£°æ˜==

```kotlin
data class Person(val name:String, val age: Int)

val(name, age) = Person("hefuduo",29)
//or
val p = Person("Libilian",30)
val name = p.component1(); //data class has already implements the component function
val age = p.component2();
/**
è¯·æ³¨æ„ï¼ŒcomponentN() å‡½æ•°éœ€è¦ç”¨ operator å…³é”®å­—æ ‡è®°ï¼Œä»¥å…è®¸åœ¨è§£æ„å£°æ˜ä¸­ä½¿ç”¨å®ƒä»¬ã€‚

è§£æ„å£°æ˜ä¹Ÿå¯ä»¥ç”¨åœ¨ for-å¾ªç¯ä¸­ï¼šå½“ä½ å†™ï¼š

for ((a, b) in collection) { â€¦â€¦ }
å˜é‡ a å’Œ b çš„å€¼å–è‡ªå¯¹é›†åˆä¸­çš„å…ƒç´ ä¸Šè°ƒç”¨ component1() å’Œ component2() çš„è¿”å›å€¼ã€‚

*/
```



> NOTE
>
> Tuples are useful for temporary groups of related values. Theyâ€™re not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see [Classes and Structures](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82).

å…ƒç»„é€‚åˆä¸´æ—¶çš„ä¸€ç»„å˜é‡çš„å€¼,å¹¶ä¸é€‚åˆåˆ›å»ºä¸€ä¸ªå¤æ‚æ•°æ®ç»“æ„,å¹¶ä¸”æ›´é€‚åˆåœ¨ä¸€ä¸ªä¸´æ—¶åŒºåŸŸ.å¦‚æœæƒ³æ°¸ä¹…çš„ä¿å­˜ä¸€ç»„æ•°æ®,æ›´é€‚åˆç”¨ç»“æ„ä½“æˆ–ç±».



## Optionals

è¿™é‡Œç¿»è¯‘ä¸ºå¯ç©ºç±»å‹?è·ŸKotlinçš„æ„Ÿè§‰æ˜¯ä¸€è‡´çš„.

You use *optionals* in situations where a value may be absent. An optional represents two possibilities: Either there *is* a value, and you can unwrap the optional to access that value, or there *isnâ€™t* a value at all.

> NOTE
>
> The concept of optionals doesnâ€™t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return `nil` from a method that would otherwise return an object, with `nil` meaning â€œthe absence of a valid object.â€ However, this only works for objectsâ€”it doesnâ€™t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as `NSNotFound`) to indicate the absence of a value. This approach assumes that the methodâ€™s caller knows thereâ€™s a special value to test against and remembers to check for it. Swiftâ€™s optionals let you indicate the absence of a value for *any type at all*, without the need for special constants.

`nil`åªæ˜¯å¯¹äºå¯¹è±¡,å¯¹äºåŸºæœ¬`C`ç±»å‹æˆ–æšä¸¾ç±»å‹,`nil`æ˜¯ä¸èƒ½ç”¨çš„,å› æ­¤`swift`æä¾›äº†ä¸€ç§`Optinal`ç±»å‹,æ¥è¡¨ç¤ºä»»ä½•ç±»å‹çš„ç©ºå€¼.

Hereâ€™s an example of how optionals can be used to cope with the absence of a value. Swiftâ€™s `Int` type has an initializer which tries to convert a `String` value into an `Int` value. However, not every string can be converted into an integer. The string `"123"` can be converted into the numeric value `123`, but the string `"hello, world"`doesnâ€™t have an obvious numeric value to convert to.

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
//çœ‹èµ·æ¥Int?å¯¹åº”çš„å°±æ˜¯Kotlinçš„ç©ºç±»å‹,ä½†æ˜¯Kotlinçš„Int?æ˜¯åŒ…è£…ç±»å‹,ä¸æ˜¯åŸç”Ÿç±»å‹
//æ­¤å¤–,Kotlinè¿˜æä¾›äº†Unitç±»å‹å’ŒAny?,è¿˜æœ‰ä¸€ä¸ªNothingç±»å‹,æ³¨æ„Kotlinçš„Unitå’ŒJavaçš„voidæ˜¯ä¸¤å›äº‹,Unitæ˜¯ä¸€ä¸ªç±»å•ä¾‹.Nothingæ˜¯æ‰€æœ‰ç±»å‹çš„å­ç±»å‹,Unitæ˜¯Anyçš„å­ç±»å‹.è¯¦è§ä¸‹é¢Unitçš„å®šä¹‰;Nothing? æ˜¯æ‰€æœ‰å¯ç©ºç±»å‹çš„å­ç±»å‹
//Nothingå¯ä»¥ç†è§£ä¸ºæ˜¯ç¼–è¯‘æ—¶çš„ä¸€ä¸ªäº§ç‰©
```

>null æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ä¸å¯å˜åŸºæœ¬å€¼ï¼ˆæ²¡æœ‰ç»“æ„ï¼‰ï¼Œå®ƒçš„çœŸå®ç±»å‹æ˜¯ Nothing? ï¼ˆåŒæ—¶ä¹Ÿæ˜¯è¿™ä¸ªç±»å‹çš„å”¯ä¸€å€¼ï¼‰ã€‚null åŒæ—¶ä¹Ÿæ˜¯æ‰€æœ‰å¯ç©ºç±»å‹çš„åˆæ³•å€¼ï¼Œä¹Ÿæ„å‘³ç€ç›¸å¯¹åº”çš„éç©ºç±»å‹ä¸èƒ½ä¸º null ã€‚

```Kotlin
public object Unit {
    override fun toString() = "kotlin.Unit" //å•ä¾‹æ˜¯ä¸ºäº†é¿å…éé…å¤šä½™å†…å­˜
}
```

```java
/**
 * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
 */
class Any{
    //...
}
```

å›æ¥ç»§ç»­

### nil

`Kotlin`å’Œ`Swift`ä¸€å®šæœ‰ä¸€è…¿çš„,å—¯å—¯~

```swift
var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value
```

>NOTE
>
>You canâ€™t use `nil` with nonoptional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.

If you define an optional variable without providing a default value, the variable is automatically set to `nil` for you:

```swift
var surveyAnswer: String?
// surveyAnswer is automatically set to nil
```

`Swiftçš„nilä¸OCçš„nilä¸åŒ`

> NOTE
>
> Swiftâ€™s `nil` isnâ€™t the same as `nil` in Objective-C. In Objective-C, `nil` is a pointer to a nonexistent object. In Swift, `nil` isnâ€™t a pointerâ€”itâ€™s the absence of a value of a certain type. Optionals of *any* type can be set to `nil`, not just object types.

### If Statements and Forced Unwrapping

```swift
if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// Prints "convertedNumber contains some integer value."
```

Once youâ€™re sure that the optional *does* contain a value, you can access its underlying value by adding an exclamation mark (`!`) to the end of the optionalâ€™s name. The exclamation mark effectively says, â€œI know that this optional definitely has a value; please use it.â€ This is known as *forced unwrapping* of the optionalâ€™s value:

åº”è¯¥æ˜¯å’ŒKotlinä¸­çš„`!!`éç©ºæ–­è¨€ç±»ä¼¼,ä½†æ˜¯Kotlinä¸­åªè¦åˆ¤æ–­éç©º,å°±å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥å˜é‡äº†

```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).") //è¿™é‡Œè¿›è¡Œäº†éç©ºæ–­è¨€
}
// Prints "convertedNumber has an integer value of 123."
```

æˆ‘ä»¬çœ‹Kotlinæ˜¯æ€ä¹ˆåšçš„

```Kotlin
fun main(args: Array<String>) {
    var l : String? = null
    var m = l!!.toString()//è¿™é‡Œè¿›è¡Œäº†ä¸€ä¸ªéç©ºæ–­è¨€,ç›¸å½“äºè¯´æˆ‘çŸ¥é“læ˜¯éç©ºçš„
}
//ä¸Šé¢çš„ç¨‹åºä¼šç›´æ¥throw ä»¥NPEå¼‚å¸¸
```

> NOTE
>
> Trying to use `!` to access a nonexistent optional value triggers a runtime error. Always make sure that an optional contains a non-`nil` value before using `!` to force-unwrap its value.
>
> ä¸ç®¡åœ¨Koltinè¿˜æ˜¯Swiftä¸­,éƒ½è¦æ…é‡ä½¿ç”¨éç©ºæ–­è¨€

### Optional Binding

You use *optional binding* to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with `if` and `while` statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. `if` and `while` statements are described in more detail in [Control Flow](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120).

```swift
if let constantName = someOptional{
  //statement
}
```

```swift
if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"

//å¯¹äºæ¡ä»¶çš„è§£è¯»

```

â€œIf the optional `Int` returned by `Int(possibleNumber)` contains a value, set a new constant called `actualNumber` to the value contained in the optional.â€

If the conversion is successful, the `actualNumber` constant becomes available for use within the first branch of the `if` statement. It has already been initialized with the value contained *within* the optional, and so thereâ€™s no need to use the `!` suffix to access its value. In this example, `actualNumber` is simply used to print the result of the conversion.

You can use both constants and variables with optional binding. If you wanted to manipulate the value of `actualNumber` within the first branch of the `if` statement, you could write `if var actualNumber` instead, and the value contained within the optional would be made available as a variable rather than a constant.

You can include as many optional bindings and Boolean conditions in a single `if` statement as you need to, separated by commas. If any of the values in the optional bindings are `nil` or any Boolean condition evaluates to `false`, the whole `if` statementâ€™s condition is considered to be `false`. The following `if` statements are equivalent:

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"
 
if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

>NOTE
>
>Constants and variables created with optional binding in an `if` statement are available only within the body of the `if` statement. In contrast, the constants and variables created with a `guard` statement are available in the lines of code that follow the `guard` statement, as described in [Early Exit](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525).

### Implicitly Unwrapped Optionals

éšå¼æ¨æ–­è§£åŒ…å¯ç©ºç±»å‹

An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time itâ€™s accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit `String`:

```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark
 
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
```

You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever itâ€™s used. Rather than placing an exclamation mark after the optionalâ€™s name each time you use it, you place an exclamation mark after the optionalâ€™s type when you declare it.

> NOTE
>
> If an implicitly unwrapped optional is `nil` and you try to access its wrapped value, youâ€™ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesnâ€™t contain a value.

You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:

```swift
if assumedString != nil {
    print(assumedString)
}
// Prints "An implicitly unwrapped optional string."
```

 You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// Prints "An implicitly unwrapped optional string."
```



> NOTE
>
> Donâ€™t use an implicitly unwrapped optional when thereâ€™s a possibility of a variable becoming `nil` at a later point. Always use a normal optional type if you need to check for a `nil` value during the lifetime of a variable.

## Error Handling

é”™è¯¯å¤„ç†

You use *error handling* to respond to error conditions your program may encounter during execution.

```swift
func canThrowAnError throws{
    //this function may or may not throw an error
}
```

A function indicates that it can throw an error by including the `throws` keyword in its declaration. When you call a function that can throw an error, you prepend the `try` keyword to the expression.

```swift
do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
```

å¯ä»¥æ•æ‰æ›´èƒ½å¤šå¼‚å¸¸

```swift
func makeASandwich() throws {
    // ...
}
 
do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```



## Assertions and Preconditions

*Assertions* and *preconditions* are checks that happen at runtime. You use them to make sure an essential condition is satisfied before executing any further code. If the Boolean condition in the assertion or precondition evaluates to `true`, code execution continues as usual. If the condition evaluates to `false`, the current state of the program is invalid; code execution ends, and your app is terminated.

You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.

In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code. Unlike the error conditions discussed in [Error Handling](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID515) above, assertions and preconditions arenâ€™t used for recoverable or expected errors. Because a failed assertion or precondition indicates an invalid program state, thereâ€™s no way to catch a failed assertion.

Using assertions and preconditions isnâ€™t a substitute for designing your code in such a way that invalid conditions are unlikely to arise. However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps makes the problem easier to debug. Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.

The difference between assertions and preconditions is in when theyâ€™re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. In production builds, the condition inside an assertion isnâ€™t evaluated. This means you can use as many assertions as you want during your development process, without impacting performance in production.

### Debuggin with Assertions

You write an assertion by calling the `assert(_:_:file:line:)` function from the Swift standard library. You pass this function an expression that evaluates to `true` or `false` and a message to display if the result of the condition is `false`. For example:

```
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
// This assertion fails because -3 is not >= 0.
```

use assertion failure

```swift
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age > 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}

```



### Enforcing Preconditions

Use a precondition whenever a condition has the potential to be false, but must *definitely* be true for your code to continue execution. For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.

You write a precondition by calling the `precondition(_:_:file:line:)` function. You pass this function an expression that evaluates to `true` or `false` and a message to display if the result of the condition is `false`. For example.

```swift
// In the implementation of a subscript...
precondition(index > 0, "Index must be greater than zero.")
```

or u can use  `preconditionFailure(_:file:line:)` function to indicate that a failure has occurred

> NOTE
>
> If you compile in unchecked mode (`-Ounchecked`), preconditions arenâ€™t checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the `fatalError(_:file:line:)` function always halts execution, regardless of optimization settings.You can use the `fatalError(_:file:line:)` function during prototyping and early development to create stubs for functionality that hasnâ€™t been implemented yet, by writing `fatalError("Unimplemented")` as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.

