---
layout:     post
title:      "IOS系列教程1"
subtitle:   "Swift Basics"
date:       2018-01-25 13:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - IOS
    - Swift4.0.3	
---



[TOC]

# The Basics

 `Swift`是类`C`与`OC`语言,提供了自己的一些类型,包括基本类型,例如`Int,String,Double`,此外,还提供了强大的三种原生集合类型`Array,Set`与`Dictionary`.

 `Swift`是类型安全的语言,这就意味着语言本身会帮助你写出更加安全的代码.在编译阶段就能够提前指出错误.

## Constants and Variables

### Declaring Constants and Variables

```swift
let maximumNumberOfLoginAttempts = 10 //声明一个常量,类型推断为Int,注意书写格式,可以省略分号
var currentLoginTemp = 0    //声明一个变量
var x = 1.0, y = 0.0, z = 0.0 //同时声明多个变量
```

> NOTE
>
> 如果声明一个常量,尽量使用`let`声明一个常量.注意这个常量是存储一个值,而不是一个引用

### Type Annotations

显示的指定一个变量的类型,可以使用类型限定,或者叫做类型标注.

```swift
var welcomeMessage: String   //类型限定,与Kotlin是一样的.
welcomeMessage = "hello"
var red, green, blue: Double
```

> NOTE
>
> 实际编码中,很少会用到显示指定类型,当你为一个变量或常量初始化一个值的时候.`Swfit`可以推断出变量的类型.

### Naming Constants and Variables

变量和常量可以包含几乎任意的字符,包括`Unicode`字符:

```swift
let π = 3.14159 // 声明了三个常量,对应Kotlin中的val
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```

变量和常量的名称不能包含空格,数学符号,箭头或无效的`Unicode`字符等,变量和常量只能被声明一次,并且无法变更其可变性.

>NOTE
>
>可以使用"``"将关键字或者同名的变量或常量区分开来,但是尽量不要这么做.

```swift
var `class` = 100
print(`class`)
```

### Printing Constants and Variables

`print`函数是一个全局函数能够打印一个或多个value到合适的输出. 使用占位符来打印变量

```swift
var name: String = "LeoHe"

print(name)

print("Hello World \(name)")   // 使用 \(varName) 这种形式在字符串中站位,打印变量值
print("Hello World \(1 + 2)")  // 或者求一个表达式的值都可以;
//类似Kotlin中的"{ expression }"这种形式的站位.
```

## Comments

注释

```swift
// This is a comment

/* This is also a comment
  but is written over multiple lines */

/* This is the start of the first multiline comment.
 /* This is the second, nested multiline comment. */
 This is the end of the first multiline comment. */
```

## Semicolons

Swift 不强制要求写分号,但是当两个表达式需要写在一行的时候,还是需要写分号.跟Kotlin一样.

```swift
let cat = "🐱"; print(cat)
// Prints "🐱"
```

## Integers

Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type `UInt8`, and a 32-bit signed integer is of type `Int32`. Like all types in Swift, these integer types have capitalized names.

注意整数的平台相关性,以及有符号和无符号整数的区别

### Integer Bounds

```swift
let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
```

### Int

In most cases, you don’t need to pick a specific size of integer to use in your code. Swift provides an additional integer type, `Int`, which has the same size as the current platform’s native word size:

- On a 32-bit platform, `Int` is the same size as `Int32`.
- On a 64-bit platform, `Int` is the same size as `Int64`.

### UInt

Swift also provides an unsigned integer type, `UInt`, which has the same size as the current platform’s native word size:

- On a 32-bit platform, `UInt` is the same size as `UInt32`.
- On a 64-bit platform, `UInt` is the same size as `UInt64`.

>NOTE
>
>Use `UInt` only when you specifically need an unsigned integer type with the same size as the platform’s native word size. If this isn’t the case, `Int` is preferred, even when the values to be stored are known to be nonnegative. A consistent use of `Int` for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in [Type Safety and Type Inference](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID322).

## Floating-Point Numbers

注意浮点数的小数点后有几位,如果需求精度不高,可以使用float

Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an `Int`. Swift provides two signed floating-point number types:

- `Double` represents a 64-bit floating-point number.
- `Float` represents a 32-bit floating-point number.

>NOTE
>
>`Double` has a precision of at least 15 decimal digits, whereas the precision of `Float` can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, `Double` is preferred.



## Type Safety and Type Inference

`Swfit`使用类型推断来在编译阶段推出变量或常量的类型信息.

```swift
let pi = 3.14159
// pi is inferred to be of type Double
let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double
```

## Numeric Literals

Integer literals can be written as:

- A *decimal* number, with no prefix 十进制,无前缀
- A *binary* number, with a `0b` prefix 二进制
- An *octal* number, with a `0o` prefix 八进制
- A *hexadecimal* number, with a `0x` prefix 十六进制

```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
```

科学计数法

For decimal numbers with an exponent of `exp`, the base number is multiplied by 10exp:

- `1.25e2` means $1.25 * 10^2$, or `125.0`.
- `1.25e-2` means $1.25 * 10^{-2}$, or `0.0125`.

For hexadecimal numbers with an exponent of `exp`, the base number is multiplied by 2exp:

- `0xFp2` means $15 * 2^2$, or `60.0`.
- `0xFp-2` means $15 * 2^{-2}$, or `3.75`.

```swift
//一下各个值都是相同的12.1875
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```

Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeros and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:

使用下划线分隔使得数字更加容易读(又跟Kotlin一样)

```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```



## Numeric Type Conversion

总结为一句话,能用`Int`尽量用,除非为了性能,或者是内存控制,或者是其他必要的优化,再使用其他类型的`Int`.

### Integer Conversion

The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An `Int8` constant or variable can store numbers between `-128` and `127`, whereas a `UInt8` constant or variable can store numbers between `0` and `255`. A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:

```swift
let cannotBeNegative: UInt8 = -1
// UInt8 cannot store negative numbers, and so this will report an error
let tooBig: Int8 = Int8.max + 1
// Int8 cannot store a number larger than its maximum value,
// and so this will also report an error
```

使用场景:比如一个Bitmap -ARGB-8888,每个通道就可以使用UInt8来表示

显示类型转换

To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant `twoThousand` is of type `UInt16`, whereas the constant `one` is of type `UInt8`. They can’t be added together directly, because they’re not of the same type. Instead, this example calls `UInt16(one)` to create a new `UInt16` initialized with the value of `one`, and uses this value in place of the original:

```swift
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```



### Integer and Floating-Point Conversion

```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi equals 3.14159, and is inferred to be of type Double
```

Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a `Double` or `Float` value:

```swift
let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int
```

Floating-point values are always truncated when used to initialize a new integer value in this way. This means that `4.75` becomes `4`, and `-3.9` becomes `-3`.

浮点数向整数转换会损失精度.

## Type Aliases

类型别名就是为现有的类型定义一个可选的名称,使用`typealias`关键字定义.这个和Kotlin也是一样的,Kotlin和Swift是不是有一腿.

在Kotlin中,类型别名一般在定义泛型或者函数类型时特别有用,可以缩短语法,看起来更加精炼,并且使得函数类型参数变的有意义了.

```swift
typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0
//Here, AudioSample is defined as an alias for UInt16. Because it’s an alias, the call to AudioSample.min actually calls UInt16.min, which provides an initial value of 0 for the maxAmplitudeFound variable.

```

## Booleans

Swift has a basic *Boolean* type, called `Bool`. Boolean values are referred to as *logical*, because they can only ever be true or false. Swift provides two Boolean constant values, `true` and `false`:

```swift
let orangesAreOrange = true
let turnipsAreDelicious = false

if turnipsAreDelicious {
    print("Mmm, tasty turnips!")
} else {
    print("Eww, turnips are horrible.")
}
// Prints "Eww, turnips are horrible."
```

Swift’s type safety prevents non-Boolean values from being substituted for `Bool`. The following example reports a compile-time error:

不允许其他类型转换为布尔类型

```swift
let i = 1
if i {
    // this example will not compile, and will report an error
}

let i = 1
if i == 1 {
    // this example will compile successfully
}

```

## Tupels

元组

*Tuples* group multiple values into a single compound value. The values within a tuple can be of any type and don’t have to be of the same type as each other.

```swift
let http404Error = (404, "Not Found")
// http404Error is of type (Int, String), and equals (404, "Not Found")

//deconstruction 解构元组
let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// Prints "The status code is 404"
print("The status message is \(statusMessage)")
// Prints "The status message is Not Found"
```

`Kotlin`中的元组分为二元`Pair`和三元`Triple`.

```kotlin
var (a,b) = Pair(20,"hello") //解构元组
var (a,b,c) = Triple(200,true,"ni")
val tuple = Pair(20,"hello")
val (m,n) = tuple
//使用下划线忽略一个解构
val(r,_) = tuple
```

If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (`_`) when you decompose the tuple:

```swift
let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// Prints "The status code is 404"
```

Alternatively, access the individual element values in a tuple using index numbers starting at zero:

使用元组的顺序索引元组元素.

```swift
print("The status code is \(http404Error.0)")
// Prints "The status code is 404"
print("The status message is \(http404Error.1)")
// Prints "The status message is Not Found"
```

`Kotlin`使用first,second,third指定元组中元素的顺序(在Kotlin中,元组是一个类型,使用属性索引元素)

```kotlin
val v = Triple(1, 2, 3)
println("${v.first},${v.second},${v.third}")
```

You can name the individual elements in a tuple when the tuple is defined:

==定义元组的时候,可以限定元组中元素的名称,注意了,这里和Kotlin不一样了啊!==

可以使用元素名称索引元组中的元素

```swift
let http200Status = (statusCode: 200, description: "OK")
print("The status code is \(http200Status.statusCode)")
// Prints "The status code is 200"
print("The status message is \(http200Status.description)")
// Prints "The status message is OK"
```

Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the `(Int, String)` tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see [Functions with Multiple Return Values](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID164).

元组非常适合作为函数的返回值,当函数有多个返回值的时候,使用元组作为返回能够一次性返回多个数值,而省去了包装一个对象

```swift
//元组可以定义多个元素,Kotlin应该是甚至有二元和三元.
let http200Status = (statusCode: 200, description: "OK", type: "success")
```

==Kotlin的结构声明可以使用在结合的遍历当中==

==因为数据类自动声明 componentN() 函数，所以这里可以用解构声明==

```kotlin
data class Person(val name:String, val age: Int)

val(name, age) = Person("hefuduo",29)
//or
val p = Person("Libilian",30)
val name = p.component1(); //data class has already implements the component function
val age = p.component2();
/**
请注意，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们。

解构声明也可以用在 for-循环中：当你写：

for ((a, b) in collection) { …… }
变量 a 和 b 的值取自对集合中的元素上调用 component1() 和 component2() 的返回值。

*/
```



> NOTE
>
> Tuples are useful for temporary groups of related values. They’re not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see [Classes and Structures](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82).

元组适合临时的一组变量的值,并不适合创建一个复杂数据结构,并且更适合在一个临时区域.如果想永久的保存一组数据,更适合用结构体或类.



## Optionals

这里翻译为可空类型?跟Kotlin的感觉是一致的.

You use *optionals* in situations where a value may be absent. An optional represents two possibilities: Either there *is* a value, and you can unwrap the optional to access that value, or there *isn’t* a value at all.

> NOTE
>
> The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return `nil` from a method that would otherwise return an object, with `nil` meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as `NSNotFound`) to indicate the absence of a value. This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for *any type at all*, without the need for special constants.

`nil`只是对于对象,对于基本`C`类型或枚举类型,`nil`是不能用的,因此`swift`提供了一种`Optinal`类型,来表示任何类型的空值.

Here’s an example of how optionals can be used to cope with the absence of a value. Swift’s `Int` type has an initializer which tries to convert a `String` value into an `Int` value. However, not every string can be converted into an integer. The string `"123"` can be converted into the numeric value `123`, but the string `"hello, world"`doesn’t have an obvious numeric value to convert to.

```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
//看起来Int?对应的就是Kotlin的空类型,但是Kotlin的Int?是包装类型,不是原生类型
//此外,Kotlin还提供了Unit类型和Any?,还有一个Nothing类型,注意Kotlin的Unit和Java的void是两回事,Unit是一个类单例.Nothing是所有类型的子类型,Unit是Any的子类型.详见下面Unit的定义;Nothing? 是所有可空类型的子类型
//Nothing可以理解为是编译时的一个产物
```

>null 是一个特殊的不可变基本值（没有结构），它的真实类型是 Nothing? （同时也是这个类型的唯一值）。null 同时也是所有可空类型的合法值，也意味着相对应的非空类型不能为 null 。

```Kotlin
public object Unit {
    override fun toString() = "kotlin.Unit" //单例是为了避免非配多余内存
}
```

```java
/**
 * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
 */
class Any{
    //...
}
```

回来继续

### nil

`Kotlin`和`Swift`一定有一腿的,嗯嗯~

```swift
var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value
```

>NOTE
>
>You can’t use `nil` with nonoptional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.

If you define an optional variable without providing a default value, the variable is automatically set to `nil` for you:

```swift
var surveyAnswer: String?
// surveyAnswer is automatically set to nil
```

`Swift的nil与OC的nil不同`

> NOTE
>
> Swift’s `nil` isn’t the same as `nil` in Objective-C. In Objective-C, `nil` is a pointer to a nonexistent object. In Swift, `nil` isn’t a pointer—it’s the absence of a value of a certain type. Optionals of *any* type can be set to `nil`, not just object types.

### If Statements and Forced Unwrapping

```swift
if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
// Prints "convertedNumber contains some integer value."
```

Once you’re sure that the optional *does* contain a value, you can access its underlying value by adding an exclamation mark (`!`) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as *forced unwrapping* of the optional’s value:

应该是和Kotlin中的`!!`非空断言类似,但是Kotlin中只要判断非空,就可以直接使用该变量了

```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).") //这里进行了非空断言
}
// Prints "convertedNumber has an integer value of 123."
```

我们看Kotlin是怎么做的

```Kotlin
fun main(args: Array<String>) {
    var l : String? = null
    var m = l!!.toString()//这里进行了一个非空断言,相当于说我知道l是非空的
}
//上面的程序会直接throw 以NPE异常
```

> NOTE
>
> Trying to use `!` to access a nonexistent optional value triggers a runtime error. Always make sure that an optional contains a non-`nil` value before using `!` to force-unwrap its value.
>
> 不管在Koltin还是Swift中,都要慎重使用非空断言

### Optional Binding

You use *optional binding* to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with `if` and `while` statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. `if` and `while` statements are described in more detail in [Control Flow](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120).

```swift
if let constantName = someOptional{
  //statement
}
```

```swift
if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"

//对于条件的解读

```

“If the optional `Int` returned by `Int(possibleNumber)` contains a value, set a new constant called `actualNumber` to the value contained in the optional.”

If the conversion is successful, the `actualNumber` constant becomes available for use within the first branch of the `if` statement. It has already been initialized with the value contained *within* the optional, and so there’s no need to use the `!` suffix to access its value. In this example, `actualNumber` is simply used to print the result of the conversion.

You can use both constants and variables with optional binding. If you wanted to manipulate the value of `actualNumber` within the first branch of the `if` statement, you could write `if var actualNumber` instead, and the value contained within the optional would be made available as a variable rather than a constant.

You can include as many optional bindings and Boolean conditions in a single `if` statement as you need to, separated by commas. If any of the values in the optional bindings are `nil` or any Boolean condition evaluates to `false`, the whole `if` statement’s condition is considered to be `false`. The following `if` statements are equivalent:

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"
 
if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

>NOTE
>
>Constants and variables created with optional binding in an `if` statement are available only within the body of the `if` statement. In contrast, the constants and variables created with a `guard` statement are available in the lines of code that follow the `guard` statement, as described in [Early Exit](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525).

### Implicitly Unwrapped Optionals

隐式推断解包可空类型

An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it’s accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit `String`:

```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark
 
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
```

You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it’s used. Rather than placing an exclamation mark after the optional’s name each time you use it, you place an exclamation mark after the optional’s type when you declare it.

> NOTE
>
> If an implicitly unwrapped optional is `nil` and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.

You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:

```swift
if assumedString != nil {
    print(assumedString)
}
// Prints "An implicitly unwrapped optional string."
```

 You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:

```swift
if let definiteString = assumedString {
    print(definiteString)
}
// Prints "An implicitly unwrapped optional string."
```



> NOTE
>
> Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming `nil` at a later point. Always use a normal optional type if you need to check for a `nil` value during the lifetime of a variable.

## Error Handling

错误处理

You use *error handling* to respond to error conditions your program may encounter during execution.

```swift
func canThrowAnError throws{
    //this function may or may not throw an error
}
```

A function indicates that it can throw an error by including the `throws` keyword in its declaration. When you call a function that can throw an error, you prepend the `try` keyword to the expression.

```swift
do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}
```

可以捕捉更能多异常

```swift
func makeASandwich() throws {
    // ...
}
 
do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```



## Assertions and Preconditions

*Assertions* and *preconditions* are checks that happen at runtime. You use them to make sure an essential condition is satisfied before executing any further code. If the Boolean condition in the assertion or precondition evaluates to `true`, code execution continues as usual. If the condition evaluates to `false`, the current state of the program is invalid; code execution ends, and your app is terminated.

You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.

In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code. Unlike the error conditions discussed in [Error Handling](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID515) above, assertions and preconditions aren’t used for recoverable or expected errors. Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.

Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise. However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps makes the problem easier to debug. Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.

The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. In production builds, the condition inside an assertion isn’t evaluated. This means you can use as many assertions as you want during your development process, without impacting performance in production.

### Debuggin with Assertions

You write an assertion by calling the `assert(_:_:file:line:)` function from the Swift standard library. You pass this function an expression that evaluates to `true` or `false` and a message to display if the result of the condition is `false`. For example:

```
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
// This assertion fails because -3 is not >= 0.
```

use assertion failure

```swift
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age > 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}

```



### Enforcing Preconditions

Use a precondition whenever a condition has the potential to be false, but must *definitely* be true for your code to continue execution. For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.

You write a precondition by calling the `precondition(_:_:file:line:)` function. You pass this function an expression that evaluates to `true` or `false` and a message to display if the result of the condition is `false`. For example.

```swift
// In the implementation of a subscript...
precondition(index > 0, "Index must be greater than zero.")
```

or u can use  `preconditionFailure(_:file:line:)` function to indicate that a failure has occurred

> NOTE
>
> If you compile in unchecked mode (`-Ounchecked`), preconditions aren’t checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the `fatalError(_:file:line:)` function always halts execution, regardless of optimization settings.You can use the `fatalError(_:file:line:)` function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing `fatalError("Unimplemented")` as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.

