---
layout:     post
title:      "Java学习笔记12"
subtitle:   "异常处理"
date:       2016-12-21 18:00:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---

# 第12章 异常处理

> Java的基本理念是：“结构不佳的代码不能运行”。

### Java标准异常：

Throwable这个Java类被用来表示任何可以作为异常被抛出的类，Throwable对象可分为两种类型：

1. Error用来表示编译时和系统错误。
2. Exception是可以抛出的基本类型
3. 特例：RuntimeException



### 使用finally进行清理：

对于一些代码，可能会希望无论try块中的异常是否抛出，他们都能得到执行，这通常适用于内存回收之外的情况。为了达到这个目的，可以在异常处理程序后面加上**finally**子句，完整的异常处理程序看起来是这样的：

```java
try{
  //dangerous region
}catch(A a1){
  
}catch(B b1){
  
}finally{
  //activities that will always execute
}
```



为了证明finally总是可以运行的，可以试试这个程序：



```java
//因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍会执行。
class FinallyReturn{
  public static void f(String[] args){
    try{
      //something dangerous
      
      return;
    }finally{
      //must be executed
      print("this will executed no matter \"return\" statement is ahead.")
    }
  }
}
```



### 异常丢失

Java的异常也是有瑕疵的，异常作为程序的错误标志，绝不应该被忽略，但是他还是有可能被轻易忽略的，用某些特殊的方式使用finally子句，就会发生这种情况：

```java
public static void main(String[] args){
  try{
    LostMessage lm = new LostMessage();
    try{
      lm.f();
    }finally{
      lm.dispose();
    }
  }catch(Exception e){
    sout(e);
  }
}

public class LostMessage{
  void f() throws VeryImportantException{
    throw new VeryImportantException();
  }
  
  void dispose() throws HohumException{
    throw new HohumException();
  }
  
}

//这个程序的VeryImportantException不见了，他被finally子句里的HohumException所取代。这是相当严重的缺陷，因为一场可能会以一种比前面例子所示更加微妙和难以察觉的方式完全丢失。
```



### 异常的限制

当覆盖方法时，只能排除在基类方法的异常说明里列出的那些异常,这个限制意味着当基类使用的代码应用到派生类对象的时候，一样能够工作，异常也不例外。



```java
//举个🌰
abstract class Father{
  //实际上父类型没有抛出异常
  public abstract void test() throw XXException;
}

class Son extends Father{
  @Override
  public void test() throw XXException{
    //子类型覆盖父类型
    //必须强制子类型抛出异常
    
    //
    
    
    throw new XXException();
  }
}
```



异常限制对构造器不起作用，

> 派生类构造器不能捕获基类构造器抛出的异常。





### 构造器

> 有一个很重要的一点：“如果异常发生了，所有的东西能被正确的清理吗？”。
>
> 大多数情况下，由于Java的垃圾回收机制，都是安全的。但是涉及到构造器时，问题就出现了。

构造器会把对象设置成安全的初始状态，但是还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理，如果构造器内部抛出了异常，这些清理行为也许就不能正常工作了，这就意味着编写构造器的时候一定要**格外小心**。

### 异常匹配

try-catch句块，的catch处理代码，可以捕获不同的异常，可以针对不同的异常做处理，抛出的异常如果匹配到哪一个catch句块的异常，就分给那个异常处理。



