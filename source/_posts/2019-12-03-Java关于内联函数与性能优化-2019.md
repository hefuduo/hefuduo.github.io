---
layout:     post
title:      "内联函数与性能优化"
subtitle:   "函数内联"
date:       2019-11-25 19:00:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---



# 什么是函数内联

调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到
转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保
存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体
代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。

  那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。内联函数就是在程序编译时，编译器将程序中出现
的内联函数的调用表达式用内联函数的函数体来直接进行替换。显然，这样就不会产生转去转回的问题，但是由于在编译
时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时
那么大，可见它是以目标代码的增加为代价来换取时间的节省。

  在大学里学习写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用
到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的
处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等）

  写过C++代码的应该都知道，在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被
编译器视为内联函数。

那么，在java中的内联函数长什么模样呢？在java中使用final关键字来指示一个函数为内联函数，例如：Java代码 

```java
public final methodName(){
  //TODO 
}
```



  这个指示并不是必需的。final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。
但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。



# 性能测试

```java
 public static int[] convertByteToColor(byte[] data) {
        long l1 = System.currentTimeMillis();
        int size = data.length;
        if (size == 0) {
            return null;
        }

        int arg = 0;
        if (size % 3 != 0) {
            arg = 1;
        }

        // 一般RGB字节数组的长度应该是3的倍数，
        // 不排除有特殊情况，多余的RGB数据用黑色0XFF000000填充
        // ((data >> 4) & 0x0F) * 16 + (0x0F & data);
        int[] color = new int[size / 3 + arg];
        int red, green, blue;
        int colorLen = color.length;
        if (arg == 0) {
            for (int i = 0; i < colorLen; ++i) { //如果图像很大,需要很多for循环,内联convertByteToInt将会提升很大效率.
                //inline the function to improve performance.
                red =  ((data[i * 3] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3]);
                green = ((data[i * 3 + 1] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3 + 1]);
                blue = ((data[i * 3 + 2] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3 + 2]);

                // 获取RGB分量值通过按位或生成int的像素值
                color[i] = (red << 16) | (green << 8) | blue | 0xFF000000;
            }
        } else {
            for (int i = 0; i < colorLen - 1; ++i) {
                red =  ((data[i * 3] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3]);
                green = ((data[i * 3 + 1] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3 + 1]);
                blue = ((data[i * 3 + 2] >> 4) & 0x0F) * 16 + (0x0F & data[i * 3 + 2]);
                color[i] = (red << 16) | (green << 8) | blue | 0xFF000000;
            }
            color[colorLen - 1] = 0xFF000000;
        }
        
        long l2 = System.currentTimeMillis();
        Log.d("hefuduo_yoda", "the cost of convertbyteToColors = " + (l2 -l1));

        return color;
    }

    /**
     * @param data
     * @return
     */ //将这个函数内联将会显著提升代码的执行效率.
    public static int convertByteToInt(byte data) {
        return  ((data >> 4) & 0x0F) * 16 + (0x0F & data);
    }
```

