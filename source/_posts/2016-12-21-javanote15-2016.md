---
layout:     post
title:      "Java学习笔记15"
subtitle:   "泛型"
date:       2016-12-21 19:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---

[TOC]

# 第15章 泛型

> 一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义类型的类。如果要编写可以用于多种类型的代码，这种方式对于代码的束缚就会很大。

写在开头：

泛型的出现一个是可以在编译时就进行类型检查，避免了运行时的错误的类型转换抛出异常，此外，Java支持泛型也同时提高了编程效率，可以使用类似C++ 模板类的机制编写代码。



Java SE5的新特性就是泛型的概念。泛型实现了**参数化类型**的概念，使得代码可以用于多种类型。



### 15.1 与C++的比较

Java的泛型能做到什么，不能做到什么（Java泛型的边界是什么）？与C++ 的模板类相比较，Java的泛型优缺点是什么？什么是纯粹的泛型？



### 15.2 简单泛型

泛型的出现->创造**容器类（Collections）**



```java
//不使用泛型
public class Holer{
  private Object[] element;
  private int size;
  
  Holder(){
    
  }
  
  Holder(int size){
    this.size = size;
  }
  public void add(Object obj){
  	//add
  }
  
  public Object get(int position){
    //get;
  }
} 

public class Main{
  public static void main(String[] args){
    Holer h = new Holder();
    h.add(new Something1());
    //need to cast;
    Somthing1 some = (Something1)h.get(0);
  }
}


//使用泛型

public class Holder<T>{
  private T element;
  //something
}

//也许上面的例子没有足够的说服力，后面的例子也许会更清晰些
```





#### 元组

> 仅一次方法调用就能返回多个对象，但是return语句只允许返回单个对象，因此，解决办法就是创建一个对象，用它来持有想要返回的多个对象。当然，可以再每次需要的时候专门创建一个类来完成这个工作。但是有了泛型没我们就能够一次性的解决该问题。同时在编译时保证类型安全



定义：

**将一组对象直接打包存储于其中一个对象中，这个容器对象允许读取其中的元素，但是不允许向其中放入新的对象（这个概念也称为数据传送对象或信使），这个概念就是元组（tuple）**

示例：二维元组

```java
public class TwoDimenTuple<T,K>{
  public final T t;
  public final K k;
  
  TwoDimenTuple(T t, K k){
    this.t = t;
    this.k = k;
  }
}
```

安全性分析：客户端可以随意的使用t和k，但是已经初始化就无法改变t和k的值。因为final声明使得t和k是安全的，而且格式更加简单，因此不必要使用getter和setter，也不用讲域声明为private的。

当然你还可以声明三维元组或者更多维的元组。



> 为了使用元组，可以定义一个长度何时的元组，将其作为方法的返回值，然后在return语句中创建元组返回即可。



```java
public class Traffic<Vehicle,String,Integer>{
  //,,,,,
  
  public Traffic<Vehicle,String,Integer>)(Parameters...){
    return new Traffic<Vehicle,String,Integer>(.....);
  }
}
```





### 15.3 泛型接口

泛型也可以用于接口。例如生成器，这是一种专门负责创建对象的类，实际上这是一种工厂方法设计模式的一种应用。



```java
package net.mindview.util;

public interface Generator<T>{
  T next();
}
```



### 15.4 泛型方法

> 泛型方法使得该方法能够独立于类而产生变化。
>
> 指导原则：
>
> 无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说吗如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。
>
> 此外，对于一个static的方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力，就必须使其称为泛型方法。



```java
public class GenericMethods{
  public <T> void f(T t){
  	System.out.println(t.getClass().getName());  
  }
  
  public static void main(String[] args){
    GenericMethods gm = new GenericMethods();
    gm.f("");
    gm.f(1);
    gm.f(1.0);
    gm.f(1.0f);
    gm.f(gm);
  }
  
}
```



GenericMethods 并不是参数化的，尽管这个类和其内部的方法可以被同时参数化，但是在这个例子中，只有方法f是参数化的。



==当使用泛型类时，必须在创建对象的时候就指定类型参数的值，而使用泛型方法时，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这个被称为**类型推断**。==

如果调用方法f()传入的是基本类型，自动装箱就会介入其中，将基本类型装箱为对应的对象。



#### 杠杆利用参数类型推断

类型推断只是对赋值操作有效，其他时候并不一定生效。如果你是将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断。在这种情况下，编译器认为：调用泛型方法后，其返回值被赋给一个Object类型的变量，如下。



```java
public class LimitsOfInference{
  static void f(Map<SPerson, List <? extends Pet>> petPeople){
    
  }
  public static void main(String[] args){
    //f(New.map()); 这个无法被编译器编译通过
  }
}

//注：New.map()
public class New{
  public static <K,V> map<K,V> map(){
  return new HashMap<K,V>();
}
}
```



#### 显示的类型说明

在泛型方法中，可以显示的指明类型，不过这种语法很少使用。

```java
/要显示的指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static方法，必须在点的操作符之前加上类名。
/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        LimitsOfInterface.f(New.<Person, List<Pet>>map());
    }
}


class Person{
    
}

class Pet{
    
}

class LimitsOfInterface{
    static void f(Map<Person, List<Pet>> map){
        
    }
}

class New{
    public static <K,V> Map<K,V> map(){
        return new HashMap<K, V>();
    }
}
```

### 15.5 匿名内部类

泛型还可以应用于内部类和匿名内部类。示例展示使用匿名内部类实现Generator接口



```java
public interface Generator<T>{
  T next();
}


class Customer{
  private static long counter = 1;
  private final long id = counter++;
  private Customer(){}
  
  public String toString(){
    return "Customer " + id;
  }
  
  public static Generator<Customer> generator(){
    return new Generoator<Customer>(){
      public Customer next(){
        return new Customer();
      }
    }
  }
}
```



### 15.6 构建复杂的模型

泛型的一个重要好处就是能够简单而安全的构建复杂的模型。



```java
public class TupleList<A,B,C> extends ArrayList<FourTuple<A,B,C,D>> {
  public static void main(String[] args){
    TupleList<Vehicle,Amphibian,String,Integer> t1 = new TupleList<>();
    
    t1.add(TupleTest.h());
    t2.add(TupleTest.h());
    for(FourTuple<Vehicle,Amphibian,String,Integer>() i : t1){
     System.out.println(i); 
    }
  }
}
```





### 15.7 类型擦除

> 当你开始更深入地钻研泛型时，会发现大量的东西初看起来是没有意义的。例如，尽管可以生命ArrayList.class，但是不能生命ArrayList<Integer>.class



```java
public class EraseTypeEquivalence{
  public static void main(String[] args){
    Class c1 = new ArryaList<Integer>.getClass();
    Class c2 = new ArrayList<String>.getClass();
    System.out.println(c1==c2);
  }
}
//output ： true

ArrayList<Integer> 和 ArrayList<String>很容易被认为是两种不同的类型。
```



下面一个例子

```java
import java.io.ByteArrayOutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {

        List<Frob> list = new ArrayList<Frob>();
        Map<Frob,Fnorkle> map = new HashMap<Frob, Fnorkle>();
        Quark<Fnorkle> quark = new Quark<Fnorkle>();
        Particle<Long,Double> p = new Particle<Long, Double>();

        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
    }
}


class Frob{
    
}

class Fnorkle{
    
}

class Quark<Q>{
}

class Particle<POSITION,MOMENTUM>{}



//output 
[E]
[K, V]
[Q]
[POSITION, MOMENTUM]

Process finished with exit code 0

```



Class.getTypeParameters将返回一个TypeVariable的对象数组，表示有反省生命所生命的参数类型。这像是在暗示你可能发现参数类型的信息。

然而，正如从输出中你所看到的，你能够发现的只是用作参数占位符的标识符，这并非有用的信息。

因此得出的残酷结论是：

==在泛型代码内部，无法获得任何有关泛型参数类型的信息==

因此，你可以知道注入类型参数标识符和泛型参数边界这类的的信息-但是你却无法知道用来创建某讴歌特定实例的实际的参数类型。



Java的泛型是使用擦除来实现的，**这意味着当你使用泛型的时候，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象**。因此，`List<Integer>`和`List<String>`*在运行时*事实上是相同的类型，这两种形式都会被擦除成他们的原生类型，即List。



#### 与C++的对比

```c++
#include <iostream>
using namespace std;


template <class T> class Manipulator{
    T Obj;
public:
    Manipulator(T x){
        this->Obj = x;
    }

    void manipulate(){
        Obj.f();
    }

};

class Hasf{
public:
    void f(){
        cout<<"Hasf::f()"<<endl;
    }
};

int main() {
    Hasf hasf;
    Manipulator<Hasf> manipulator(hasf);
    manipulator.manipulate();

}

//output
Hasf::f()
```



Manipulator类存储了一个类型T的对象，有意思的地方时manipulate()方法，它在obj上调用方法f()。但是它怎么能知道f()方法是为类型参数T而存在的呢？

当你实例化这个模板时，C++编译器将进行检查，因此在`Manipulator<HasF>`被实例化的这一刻，它看到HasF拥有一个方法f(),如果情况并非如此，就会得到一个编译期错误，这样类型安全就可以保证了。

用C++编写这种类型的代码非常简单，因为当模板被实例化时，模板代码知道其模板*参数的类型*，Java泛型就不可以了。

如果将上面这个实例，换成Java代码，那么这些代码将无法通过编译。

```java
class Manipulator<T>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
       //Error: can't resolve method 'f()'
        obj.f();
    }
}
```





由于有了类型擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF拥有f()这一事实上，为了调用f()，我们就必须协助泛型类，给定泛型类的==边界==，以此告诉编译器只能接受遵循这个边界的类型。这里重用了extends关键字。由于有了边界，下面的代码就可以编译了。



```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        Manipulator<HasF> manipulator = new Manipulator<HasF>(new HasF());
        manipulator.manipulate();
    }
}


class Manipulator<T extends HasF>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}
```



==边界`<T extends HasF>`声明了T必须具有类型HasF或者从HasF导出的类型。如果情况确实如此，那么就可以安全的在obj上调用f()了==。

我们说泛型类型参数将*擦除到它的第一个边界（可能会有多个边界）*，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例一样，T擦除到了HasF，就好像在累的生命中用HasF替换了T一样。



上面的代码中，泛型实际上没有贡献任何好处，只需很容易地自己去执行擦除，就可以创建出没有泛型的类。

```java
class Manipulator{
  private HasF obj;
  public Manipulator(HasF x){
    obj = x;
  }
  public void manipulate(){
    obj.f();
  }
}
```



这提出了很重要的一点：

只有当你希望使用的类型参数比某个具体类型（以及所有它的子类型）更加“泛化”时，也就是希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，类型参数和他们在有用的泛型代码中的应用，通常比简单的类替换要更复杂。但是，不能因此而认为`<T extends HasF>`形式的任何东西都是有缺陷的。

例如，如果某个类有一个返回T的方法，那么泛型就有所帮助，因为他们之后将返回确切的类型。

```java
public class Main {
    public static void main(String[] args) {
        Manipulator<HasF> manipulator = new Manipulator<HasF>(new HasF());
        manipulator.manipulate();
        HasF hasF = manipulator.get();
    }
}


class Manipulator<T extends HasF>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}
```



#### 迁移兼容性

为了减少潜在的关于擦除的混淆，你必须清楚的认识到这不是一个语言特性，它是Java泛型实现的一种折中，因为泛型不是Java语言出现时就有的组成部分，所以这种折中是必须的。折中折中会让你痛苦，因此你需要习惯它并了解为什么它会是这样。

如果泛型在Java1.0的版本上 就实现了，那么这个特性就不会使用擦除来实现，它将使用*具体化*（就像C++ 示例中那样），是类型参数保持为第一类试题，因此能够在类型参数上执行基于类型的语言操作和反射操作。

类型擦除减少了泛型的泛化性，泛型在Java中仍旧是有用的，只是不如本来设想的那么好，而原因就是擦除。（C++中的模板类是一种更好的实现。）



在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文环境细中使用的类型，泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界，例如`List<T>`这样的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下江北擦除为Object。



擦除的核心动机是，它是的繁华的客户端可以使用非泛化的库来使用，反之亦然。这经常被称为*“迁移兼容性”*。



```java
class Manipulator<T extends HasF>{
    private T obj;
    
    Manipulator(){
        
    }
    
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}

class Manipulator2 extends Manipulator{
    Manipulator2(){
        
    }

  	//继承后的类型擦除，到HasF
    @Override
    public HasF get() {
        return super.get();
    }
} 
```

```java
class Manipulator<T>{
    private T obj;
    
    Manipulator(){
        
    }
    
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}

class Manipulator2 extends Manipulator{
    Manipulator2(){
        
    }

  //类型擦除为Object
    @Override
    public Object get() {
        return super.get();
    }
} 
```





#### 类型擦除问题

因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会突然间破坏所有的代码。

擦除的代价也是显著的，泛型不能用于显示的引用运行时类型的操作中，例如转型，instanceof和new表达式。因为所有关于参数的类型信息都在运行时丢失了，无论何时，当你编写泛型代码的时候。==注意，你只是*看起来好像拥有有关参数的类型信息*而已==。

如果你写了下面的代码：

```java
class Foo<T>{
  T var;
}

//那么，看起来当你在创建Foo的实例时：
Foo<Cat> f = new Foo<Cat>();
```



class Foo的代码应该知道现在工作于Cat之上，而泛型语法也在强烈暗示：整个类的各个地方，类型T都在被替换。但是事实并非如此，无论何时，当你在编写这个类的代码时，必须提箱自己：==“不，它只是一个Object！”==

```java
class GenericBase<T>{
    private T element;
    private void set(T arg){
        element = arg;
    }
    public T get(){
        return element;
    }
}

class Derived1<T> extends GenericBase<T>{
    
}

class Derived2 extends GenericBase{
//no warnings    
}

class Derived3 extends GenericBase<?>{
    //no wild card expected
    //required class or interface without bounds
}



public class Main {
    public static void main(String[] args) {
        Derived2 derived2 = new Derived2();
        Object object = derived2.get(); //继承擦除了类型
        derived2.set(object);//warning: unchecked call to set(T) as a member of raw type GenericBase
    }
}
```



当你希望将类型参数不要仅仅的当做Object处理时，你需要付出额外的努力来管理边界，并且与在C++等这样的语言中获得的参数化类型相比，你需要付出多得多的努力来获取少的少的汇报。



#### 边界处的动作

正是因为有了擦除，泛型最令人困惑的方面源自这样一个事实，即可以表示没有任何意义的事物。

```java
public class ArrayMaker<T>{
	private Class<T> kind;
  
  public ArrayMaker(Class<T> kind){
    this.kind = kind;
  }
  
  T[] create(int size){
    //warning unchecked cast. 
    reutnr (T[])Array.newInstance(kind,size);
  }
  
  public static void main(String[] args){
    ArrayMaker<String> stringMaker = new ArrayMaker<String>();
    String[] stringArray = stringMaker.create(9);
    System.out.println(Arrays.toString(stringArray));
  }
}

//output 

//[null,null,...,null]
```

即使，kind被存储为`Class<T>`，擦除也意味着它实际将被存储为Class，没有任何参数。因此每当你在使用它时，例如在创建数组的时候，`Array.newInstance()`实际上并未拥有kind所蕴含的类型信息，因此这不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告。

如果要创造一个容器而不是数组，情况就有所不同。

```java
public class ListMaker<T>{

  List<T> create(){
    return new ArrayList<T>();
  }
  
  public static void main(String[] args){
    ListMaker<String> stringMaker = new ListMaker<String>();
    List<String> stringList = stringMaker.create();
  }
}
```

 

编译器不会给出任何的警告，尽管我们（从擦除中）可以知道create()内部的`new ArrayList<T>()`中的`<T>`会被擦除，在运行时，这个类的内部会有任何`<T>`，因此这看起来毫无意义。但是，如果遵循这种思路与，将这个表达式改为`new ArrayList()`，编译器就会给出警告。

在本例子中是否有意义呢？返回List之前将某些对象放入其中。



```java
public class Main {
    public static void main(String[] args) {
       FilledListMaker<String> listMaker = new FilledListMaker<String>();
       List<String> strings = listMaker.create("hellow",4);
        System.out.println(strings);
    }
}
 
class FilledListMaker<T>{
    List<T> create(T t,int n){
        List<T> result = new ArrayList<T>();
        for (int i = 0; i < n; i++){
            result.add(t);
        }
        return result;
    }
}
```

即使编译器无法知道有关create()中的T的任何信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其适合`ArrayList<T>`。因此，即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。



因为擦除在==方法体中移除了类型信息==，所以在运行时的问题就是*边界*：

即对象进入和离开方法的地点。这些正是编译器在编译期间执行类型检查并插入转型代码的地点。

```java
public class Main {
    public static void main(String[] args) {
        SimpleHolder holder = new SimpleHolder();
        holder.set("Item");
      //class字节码，将在这里进行强制类型转化与检查
        String s = (String)holder.get();
    }
}

class SimpleHolder{
    private Object obj;
    public void set(Object obj){
        this.obj = obj;
    }
    public Object get(){
        return this.obj;
    }
}
```



如果反编译`SimpleHolder`这个类，得到内容解释：

```
class SimpleHolder {
  SimpleHolder();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void set(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return

  public java.lang.Object get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
}

 Fri 19 May - 01:55  ~/IdeaProjects/GradleJava 
 @hefuduo  javap -c build.cjavap -c build.classes.main.Main 
警告: 二进制文件build.classes.main.Main包含Main
Compiled from "Main.java"
public class Main {
  public Main();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class SimpleHolder
       3: dup
       4: invokespecial #3                  // Method SimpleHolder."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String Item
      11: invokevirtual #5                  // Method SimpleHolder.set:(Ljava/lang/Object;)V
      14: aload_1
      15: invokevirtual #6                  // Method SimpleHolder.get:()Ljava/lang/Object;
      18: checkcast     #7                  // class java/lang/String
      21: astore_2
      22: return
}

```



set()和get()方法将直接存储和生产值，而转型是在调用`get()`方法时接受检查的。

```java
class GenericHolder<T>{
  private T obj;
  public void set(T obj){
    this.obj = obj;
  }
  
  public T get(){
    return obj;
  }
}
public class Main {
    public static void main(String[] args) {
		GenericHolder<String> holder = new GenericHolder<String>();
      holder.set("Item");
      String s = holder.get();
    }
}

```

```
警告: 二进制文件build.classes.main.GenericHolder包含GenericHolder
Compiled from "Main.java"
class GenericHolder<T> {
  GenericHolder();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void set(T);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return

  public T get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
}

 Fri 19 May - 01:57  ~/IdeaProjects/GradleJava 
// @hefuduo  javap -c build.cjavap -c build.classes.main.Main 
警告: 二进制文件build.classes.main.Main包含Main
Compiled from "Main.java"
public class Main {
  public Main();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class GenericHolder
       3: dup
       4: invokespecial #3                  // Method GenericHolder."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String Item
      11: invokevirtual #5                  // Method GenericHolder.set:(Ljava/lang/Object;)V
      14: aload_1
      15: invokevirtual #6                  // Method GenericHolder.get:()Ljava/lang/Object;
      18: checkcast     #7                  // class java/lang/String
      21: astore_2
      22: return
}

```



对于进入set操作进行的检查是不需要的，因为这将由编译器执行。而对从get返回的值进行转型仍旧是需要的，但是这与你自己必须执行的操作是一样的，此处是由编译器自动插入的，因此写入和读取的代噪声（所谓噪声就是指你要写一些冗余的代码）将更小。

由于所产生的get和set的字节码相同，所以在泛型中的所有动作都发生在边界出----

对于传递进来的值进行额外的编译器检查，并插入对传递出去的值得转型。



### 15.8 擦除的补偿

> 正如我们所看到的，擦除丢失了在泛型代码中执行某些操作的能力，任何在运行时需要知道确切类型信息的操作都将无法工作。

```java
public class Erased<T>{
  private final int SIZE = 100;
  public static vodi f(Object arg){
    if(arg instance of T){   //Error
      T var = new T();   //Error;
      T[] array = new T[SIZE]; //Error
      T[] array = (T) new Object[size]; // unchecked warning
    }
  }
}
```



偶尔可以绕过这些问题来编程，==但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显示的传递你的Class对象，以便你可以在类型表达式中使用它==

例如，前面中的例子使用instanceof的尝试失败了，因为类型信息被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();

注意了，注意了，干货到了。

```java
import java.util.List;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        ClassTypeCapture<Building> cct1 = new ClassTypeCapture<Building>(Building.class);
        System.out.println(cct1.f(new Building()));
        System.out.println(cct1.f(new Mouse()));
        
        ClassTypeCapture<Mouse> cct2  = new ClassTypeCapture<Mouse>(Mouse.class);
        System.out.println(cct2.f(new Building()));
        System.out.println(cct2.f(new Mouse()));
    }
}

class Building{}
class Mouse extends Building{}

class ClassTypeCapture<T>{
    Class<T> kind;
    public ClassTypeCapture(Class<T> t){
        kind = t;
    }
    public boolean f(Object arg){
        return kind.isInstance(arg);
    }
}

//out put 
//true
//true
//false
//true
```





#### 创建类型实例

Erase.java创建一个new T()无法实现，原因一部分是因为擦除，另一部分是因为编译器不能验证T具有默认的(无参)构造函数。

但是这在C++中,这种操作是很自然的,很直观,也很安全(它是在编译期受到检查的)

```c++
template<class T> class Foo{
  T x;
  T *y;
  public:
  	Foo(){
      y = new T();
  	}
};

class Bar{};

int main(){
  Foo<Bar> fb;
  Foo<int> fi; // 
  return 0;
}
```

Java中解决这种问题的方案是传递一个工厂对象，并使用它来创建新的实例，最便利的工厂对象就是Class，因此如果使用类型标签，那么就可以使用`newInstance()`来创建这个类型的新对象。



```java


/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        ClassAsFactory<Employee> cf = new ClassAsFactory<Employee>(Employee.class);
        System.out.println("success");
        System.out.println(cf.x);
        
        ClassAsFactory<Integer> cf1 = new ClassAsFactory<Integer>(Integer.class);
    }
}

class ClassAsFactory<T>{
    T x;
    public ClassAsFactory(Class<T> kind){
        try {
            x = kind.newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Employee{
    
}
```

   然后该段代码的输出是

```
java.lang.InstantiationException: java.lang.Integer
	at java.lang.Class.newInstance(Class.java:427)
	at ClassAsFactory.<init>(Main.java:20)
	at Main.main(Main.java:12)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.lang.NoSuchMethodException: java.lang.Integer.<init>()
	at java.lang.Class.getConstructor0(Class.java:3082)
	at java.lang.Class.newInstance(Class.java:412)
	... 7 more
success
Employee@511d50c0

Process finished with exit code 0
```

创建`ClassAsFactory<Integer>`而失败，是因为Integer没有任何默认的构造器。因为这个错误不是在编译器被捕获的。

Sun建议使用显式的工厂，并将限制其类型，只能接受实现了这个工厂的类。



                                                                                                                                                                                                                                                            ```java

/**
*  Created by hefuduo on 2017/5/4.
   */
   public class Main {
    public static void main(String[] args) {
        new Foo2<Integer>(new IntegerFactory());
        new Foo2<Widget>(new Widget.Factory());
    }
   }

interface FactoryI<T>{
    T create();
}

class Foo2<T>{
    private T x;
  //<F extends FactoryI<T>>把这个放在构造函数的签名是为了什么？
    public <F extends FactoryI<T>> Foo2(F factory){
        x = factory.create();
    }
}


class IntegerFactory implements FactoryI<Integer>{

    public Integer create() {
        return new Integer(0);
    }
}

class Widget{
    public static class Factory implements FactoryI<Widget>{

        public Widget create() {
            return new Widget();
        }
    }
}
                                                                                                                                                                                                                                                            ```



1. ==为什么这么做？好处是什么？为什么通过这种方式就补偿了类型擦除的问题？==
2. ==`Class<T>`这是用来干嘛的呢？==



注意，这确实只是船体`Class<T>`的一种变体。两种方式都传递了工厂对象，`Class<T>`碰巧是内建的工厂对象，而上面的方式创建了一个显示的工厂对象，但是你却获得了编译期间的检查。

另一种方式是*模板方法*设计模式。

如下示例：`get()`是模板方法，而`create()`是在子类中，定义的、用来产生子类类型的对象。



```java
/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        Creator creator = new Creator();
        creator.f();
    }
}

abstract class GenericWithCreate<T>{
    final T element;
    GenericWithCreate(){
        element = create();
    }
    abstract T create();
}

class X {}

class Creator extends GenericWithCreate<X>{

    X create() {
        return new X();
    }
    void f(){
        System.out.println(element.getClass().getSimpleName());
    }
}
```

#### 泛型数组

> 泛型数组的知识是非常重要的！非常重要的。

==正如你在Erase.java中所见，不能创建泛型数组。一般的解决方案是在任何想要创建泛型数组的地方使用ArrayList.==

但是有时你需要创建泛型类型的数组，例如ArrayList内部就是使用的数组。又去的是你可以按照编译器喜欢的方式来定义一个引用



```java
class Generic<T>{}

public cass ArrayOfGenericReference{
  static Generic<Integer>[] gia;
}
```

编译器会接受这个程序，也不会产生任何警告。但是，永远都不能创阿金这个确切类型的数组，包括类型参数，因此这有一点令人困惑。既然所有数组无论他们持有的类型如何，都具有相同的结构，那么看起来你应该可以创爱你一个Object数组，并将其转型为希望的数组类型，事实上这个是可以编译通过的，但是不能运行，他将产生ClassCastException

```java
public class ArrayOfGeneric{
  static final int SIZE = 100;
  static Generic<Integer>[] gia;
  public static void main(String[] args){
    //compile ClassCastException
    gia = (Generic<Integer>[])new Object[SIZE];
    
    //runtime is the raw type (erased)
	gia = (Generic<Integer>[])new Generic[size];
    
    System.out.println(gia,.getClass().getSimpleName());
  
    gia[0] = new Generic<Integer>();
    //! gia[1] = new Object(); //compile error
    
    //! gia[2] = new Generic<Double>();
  }
} 
```



问题在数组将跟踪他们的实际类型，而这个类型是在数组被创建时确定的， 因此，即使gi已经被转型为`Generic<Integer>[]`，但是这个信息只存在于编译期。在运行时，它仍旧是Object数组。

```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArray<Integer> gi = new GenericArray<Integer>(10);
        Integer[] ia = gi.rep();
        Object[] ia1 = gi.rep();
    }
}

class GenericArray<T>{
    private T[] array;
    public GenericArray(int size){
        array = (T[])new Object[size];
    }
    public void put(int index,T t){
        array[index] = t;
    }
    public T get(int index){
        return array[index];
    }
    public T[] rep(){
        return array;
    }
}

//out put 
Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
	at Main.main(Main.java:8)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```



`rep()`方法将会返回T[]，它在main()中将用于gi，因此应该是Integer[],但是如果调用它，并尝试着将结果作为Integer[]引用来捕获，就是得到`ClassCastException`，这还是因为实际的运行时类型是Object数组。



因为有了擦除，数组的运行时类型只能是Object[],如果我们立即将其转型为T[],那么就会在编译期该数组的实际类型就将丢失，而编译器可能会错过某些潜在的错误检查，正是因为这样，最好在集合的内部使用Object[]，然后当你使用该数组元素的时，添加一个对T的转型。

```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArray<Integer> gi = new GenericArray<Integer>(10);
        for (int i = 0; i < 10; i++) {
            gi.put(i,i);
        }

        for (int i = 0; i < 10; i++) {
            System.out.print(gi.get(i)+ "   ");
        }
        
        Integer[] ia = gi.rep();
    }
}

class GenericArray<T>{
    private Object[] array;
    public GenericArray(int size){
        array = new Object[size];
    }
    public void put(int index,T t){
        array[index] = t;
    }
    public T get(int index){
        return (T)array[index];
    }
    public T[] rep(){
        return (T[])array;
    }
}
```

控制台如下：

```
Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
0   1   2   3   4   5   6   7   8   9   	at Main.main(Main.java:16)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)

Process finished with exit code 1
```



初看起来，这好像没多大变化，只是转型换了地方。以上的代码内部标识是Object[]而不是T[]。当get被调用是，它将独享转型为T，这实际上发是正确的类型，因此这是安全的。然而，如果你想用rep，它还是尝试着将Object[]转型为T[]，这仍旧不是正确的，将在编译期产生警告，但在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[]，在内部将array当做Object数组而不是T[]数组处理的优势是，我们不太可能忘记这个数组的运行时类型，而意外地引入缺陷。

对于新代码，应该传递一个标记类型，在这种情况下，GenericArray看起来会像下面这样。

```java
import java.lang.reflect.Array;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArrayWithTypeToken<Integer> gai = new GenericArrayWithTypeToken<Integer>(Integer.class,10);
        Integer[] ia = gai.rep();
    }
}

class GenericArrayWithTypeToken<T>{
    private T[] array;
    public GenericArrayWithTypeToken(Class<T> type,int size){
        array  = (T[]) Array.newInstance(type,size);
    }
    
    public void put(int index, T item){
        array[index] = item;
    }
    
    public T get(int index){
        return array[index];
    }
    
    public T[] rep(){
        return array;
    }
}
```

类型标记`Class<T>`被传递到构造器中，以便从擦除中恢复，使得我们可以创建需要的实际类型的数组，尽管从转型中产生的警告必须用`@Suppress Warnings`压制，一旦我们获得了实际类型，就可以返回它，并获得想要的结果，就像在main中看到的那样，该数组运行时类型是确切类型T[];



Java类库中（SE5）的标准类库源代码。你可以看到Object数组到参数化数组的类型的转换导出都是。

```java
//例如
public ArrayList(Collection c){
  size = c.size;
  elementData = (E[])new Object[size];
  c.toArray(elementData);
}
```



### 15.9   边界

> 边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这使得你可以强制规定泛型可以应用的类型。
>
> 因为擦除移除了类型信息，所以，可以使用误解反省参数调用的方法只是哪些可以用Objetct调用的方法。但是没如果能够将这个参数限制为某个类型的自己，那么就可以用这些类型自己来调用方法，为了执行这种限制，Java泛型重用了extends关键字。extends关键字在泛型边界的上下文环境中和在普通情况下所具有的意义是完全不同的。



【关于边界的概念，可以参考Java基础教程的泛型相关章节】



### 15.10  通配符

> 一些通配符的使用，例如在泛型参数表达式中的问号。



展示数组的一种特殊行为的例子：



```java
class Fruit{}
class Apple extends Fruit{}
class Jonathan extends Apple{}
class Orange extends Fruit{}
```

```java
pubic class CovariantArrays{
  public static void main(String args[]){
    Fruit[] fruit = new Apple[10];
    fruit[0] = new Apple();
    fruit[1] = new Jnoathan();
    //the Runtime type of fruit array is Apple[].
    
    try{
      fruit[0] = new Fruit(); // ArrayStoreException
    }catch(Exception){}
    try{
      fruit[0] = new Orange(); // ArrayStoreException
    }catch(Exception){}
}
  
  /*
  the Exception info is blew  
  java.lang.ArrayStoreException: Fruit
	at Main.main(Main.java:14)
java.lang.ArrayStoreException: Orange
	at Main.main(Main.java:19)

  */
```

fruit运行时类型是Apple数组，只能在Apple中防止Apple或者Apple 的子类型 ，如果放置Orange即Fruit的子类型是可以的，但是在运行期间会报错，编译期间是不会有问题的。如果向上转型放置Fruit也是同样的道理。

那么，想到用一个泛型来防止这类错误的发生呢？

```java
public class NonCovariantGenerics{
  //compile Error:incompatible types.
  List<Fruit> fruits = new ArrayList<Apple>(); //ERROR
}
```

上面这种写法是错误的：

==Apple的List不是Fruit的List。Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit。但是它不是一个Apple的List，它仍旧是Fruit的ListApple 的List在类型上不等价与Fruit的List，即使Apple是一种Fruit类型==

与数组不同，泛型没有内建的协变类型，编译器在在编译期间和运行时系统都不知道你想用类型做什么，以及采用什么样的规则。

但是，有时你想要在两个类型之间建立某种类型的向上转型的关系，这就是通配符所允许的。

```java
public class GenericsAndCovariance{
  public static void main(String args[]){
    //wildcards allow covariance
    List<? extends Fruit> flist = new ArrayList<Apple>();
    //compile Error can't add any type of object.
    //flist.add(new Fruit());
    //flist.add(new Apple());
    //flist.add(new Object());
    flist.add(null); //legal but uninteresting
    //we know that it returns at least fruit.
    
    //不能add ==
    //List<? extends Fruit> flist可能是任何Fruit子类型的一个List。
    Fruit f = flist.get(0);
  }
}
```



flist类型现在是`List<? extends Fruit>`，读作：==具有任何从Fruit继承的类型的列表==。

但是，这实际上并不意味着这个List将持有任何类型的Fruit。通配符引用的是明确的类型，因此它意味着“**某种flist引用没有指定的具体类型**”。因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了**向上转型为flist，这类型是什么并没有人关心**。

如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是实际上并不关心它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？就像在CovariantArray.java中向上转型数组一样，你不能，除非编译器而不是运行时系统可以组织这种操作的发生，你很快就会发现这一个问题。

你可能会认为，事情变得有点走极端了，因为现在你甚至不能像刚刚声明过将持有Apple对象的List中放置一个Apple对象了。是的但是编译器并不知道这一点。`List<? extends Fruit>`可以合法地指向一个`List<Orange>`，一旦执行这种类型的向上转型，你就将会丢失向其中传递任何对象的能力，甚至是传递Object也不行。

另一个方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象至少具有Fuirt类型的，因此编译器将允许这么做。

#### 15.10.1 编译器有多聪明

现在，你可能会猜想自己被阻止去滴啊用任何接受参数的方法，但是请考虑这样的程序：

```java
public class CompilerInteligence{
  List<? extends Fruit> flist = Arrays.asList(new Apple());
  Apple a = (Apple)list.get(0); //No warning
  flist.contains(new Apple()); // argument is 'Object'
  flist.indexOf(new Apple()); // argument is 'Object'
}
```

里那个方法都接受Apple对象作为参数，而且这些调用都可以正常执行。这是否意味着编译器实际上将检查代码，以查看的是否有某个特定的方法修改了他的对象。

通过查看ArrayList的实现，尽管`add()`将接受一个具有泛型参数类型的参数，但是`contains()`和`indexOf()`将接受Object类型的参数。因此当你指定一个`ArrayList<? extends Fruti>`时，`add()`参数就变成了 `? extends Frut`。从这个描述中，编译器并不能了解这里需要Fruit的那个具体子类型，因此它不会接受任何类型的Fruit。如果现将Apple向上转型为Fruit，也无关紧要———编译器将直接拒绝对参数列表中设计通配符的方法的调用。

在使用`contains()`和`indexOf()`时，参数类型是Object，因此不涉及任何通配符，编译器也将允许这个调用。这意味着酱油泛型累的设计者来决定哪些调用是*安全的*，并使用Object类型作为其参数类型。为了在类型中使用了通配符的情况下禁止这类的调用，我们需要在参数列表中使用类型参数。

```java
public class Holder<T>{
  private T value;
  public Holder(){}
  public void set(T val){
    value = val;
  }
  public T get(){
    return value;
  }
  
  public boolean equals(Object obj){
    return value.equals(obj);
  }
  
  public static void main(String[] args){
    Holder<Apple> apple = new Holder<Apple>(new Apple());
    Apple d = apple.get();
    apple.set(d);
    //Hollder<Fruit> fruit = apple; //cannot upcast;
    Holder<? extends Fruit> fruit = apple; //ok;
    Fruit p = fruit.get();
    d = (Apple)fruit.get();
    try{
      Orange c = (Orange)fruit.get(); //No warning
    }catch(Exception e){
      System.out.println(e);
    }
    
    System.out.println(fruit.equals(d)); //OK
    
  }
}


/*output info
java.lang.ClassCastException: APple cannot be cast to Orange.

true

*/
```

Holdr有一个接受T类型对象的`set()`方法，一个`get()`方法，以及一个接受Object对象的`equals()`方法.若果创建了一个`Holder<Apple>`，就不能将其向上转型为`Holder<Fruit>`，但是可以将其向上转型为`Holder<? extends Fruit>`。如果	调用`get()`，他只会返回一个Fruit——这就是在给定“任何扩展自Fruit的对象”这一边界之后，它所能你知道的一切了。如果能够了解更多的信息，那么你可以转型到某种具体的Fruit类型，二者不会导致任何的警告，但是你存在着得到ClassCastException的风险。`set()`方法不能工作与Apple或Fruit，因为`set()`的参数也是"`? extends Fruit`"，这个意味着它可以使任何事物，而编译器无法验证任何事物的类型安全性。

但是，`equals()`方法工作良好，因为它将接受Object类型而并非T类型的参数。因此，编译器只关注传递进来和要返回的对象类型，它并不会分析代码，以查看是否执行了任何实际的写入和读取操作。



#### 15.10.2 逆变

还可以走另外一条路，即使用超**类型通配符**。这里，可以生命通配符是有某个特定的类的任何基类来界定的，`<? super MyClass>`,设置或者使用参数类型`<? super T>`(尽管你不能对泛型参数给出一个超类型边界；即不能声明`<T super MyClass>`)。这使得你可以安全第传递一个类型对象到泛型类型中。因此，有了草类型通配符，就可以像Collection中写入了


```java
public class SuperTypeWildCard{
  static void writeTo(List<? super Apple> apples){
    apples.add(new Apple);
    apples.add(new Jonathan);
  }
}
```

参数Apple是Apple的某种基类型的List，这样你就知道像其中添加Apple或者是Apple的子类型是按全额。但是，既然Apple是**下界**，那么你可以知道像这样的List中添加Fruit是不安全的，因为这将是这个List敞开口子，从而可以向期货中添加非Apple类型的对象，这是违反静态类型安全的。

因此你可能会根据如何能够想一个泛型类型“写入”（传递给一个方法），以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来着手思考子类型和草类型边界。



#### 15.10.3 无界通配符

> 误解通配符`<?>`看起来意味着任何事物，因此使用误解共佩服好像等价于使用原生类型，事实上，编译器咋看起来是支持这种判断的。

```java
public class UnboundedWildcard {
    static List sList1;
    static List<?> sList2;
    static List<? extends Object> sList3;
    static void assign1(List list){
        sList1 = list;
        sList2 = list;
        sList3 = list;
    }
    
    static void assign2(List <?> list){
        sList1 = list;
        sList2 = list;
        sList3 = list;
    }
    static void assign3(List<? extends Object> list){
        sList1 = list;
        sList2 = list;
        sList3 = list;
    }
  
  public static void main(String[] args){
    UnboundedWildcard.assign1(new ArrayList());
        UnboundedWildcard.assign2(new ArrayList());
        UnboundedWildcard.assign3(new ArrayList());
        //warning: unchecked conversion,Found List ,required List<? exteds Object>
        UnboundedWildcard.assign1(new ArrayList<String>());
        UnboundedWildcard.assign2(new ArrayList<String>());
        UnboundedWildcard.assign3(new ArrayList<String>());
        
        List<?> wildList = new ArrayList();
        wildList = new ArrayList<String>();
        UnboundedWildcard.assign1(wildList);
        UnboundedWildcard.assign2(wildList);
        UnboundedWildcard.assign3(wildList);
  }
}
```

编译器很少关心使用的是原生类型还是`<?>`。在这些情况当中，`<?>`可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上，他是在声明：我是想用泛型来编写这段代码，我在这里并不是想要用原生类型，但是在当前这种情况下吗，泛型参数可以持有任何类型。（参见JDK，Class泛型(反射forname)）

此外，无界通配符的另一个重要作用。当你处理多个泛型参数时，有时允许一个参数可以是任何类型，同事为其他参数确定某种特定类型的这种能力会显得很重要。

```java
import java.util.HashMap;
import java.util.Map;

/**
 * Created by hefuduo on 2017/6/27.
 */
public class UnboundedWildcard2{
    static Map map1;
    static Map<?,?> map2;
    static Map<String,?> map3;
    static void assign1(Map map){
        map1 = map;
    }
    static void assign2(Map<?,?> map){
        map2 = map;
    }
    static void assign3(Map<String,?> map){
        map3 = map;
    }
    
    public static void main(String[] args){
        assign1(new HashMap());
        assign2(new HashMap());
        assign3(new HashMap());
        //warning unchecked assignment;
        assign1(new HashMap<String,Integer>());
        assign2(new HashMap<String,Integer>());
        assign3(new HashMap<String,Integer>());
    }
}

```

当你拥有的全都是无界通配符时，就像是`Map<?,?>`中看到的那样，编译器看起来就无法将其与原生Map区分开来了，其实编译器看来，`List<?>`和`List<? extends Object>`是不同的。

编译器并非总是关注像`List`和`List<?>`之间的这种差异，因此它们看起来就像是相同的事情。因为，事实上，由于泛型参数将擦除到它的第一个边界，因此`List<?>`看起来就是等价于`List<Object>`的。而`List`实际上就是`List<Object>`。

翻译一下就是`List`实际上表示“持有任何Object类型的原生List”，而`List<?>`则表示“具有某种特定类型的非原生List”，只是我们不知道那种类型是什么。


#### 15.10.4 捕获转换

虽然`<?>`看起来和原生类型差不多，但是，有一种情况特别需要使用`<?>`而不是原生类型。
如果想一个使用`<?>`的方法传递原生类型，那么对于编译器，可能会推断出时机的类型参数没事的这个方法可以**回转并调用另一个使用这个确切类型的方法。**
这种被称为*捕获转换*，因为未指定的通配符被捕获，并且转换为确切类型。

```java
/**
 * Created by hefuduo on 2017/6/27.
 */
public class CaptureConversion {
    static <T> void f1(Holder<T> holder){
        T t = holder.get();
        System.out.println(t.getClass().getSimpleName());
    }
    static void f2(Holder<?> holder){
        f1(holder);  //call with caputered type
    }
    public static void main(String[] args){
        Holder raw = new Holder<Integer>(1);
        f1(raw);//书中有提到warning，但是实际编译时并没有
        f2(raw);
        Holder rawBasic = new Holder(null);
        rawBasic.set(new Object()); //warning unchecked set()
        f2(rawBasic); 
        Holder<?> wildcarded = new Holder<Double>(1.0);
        f2(wildcarded);
        f2(new Holder<String>("ssss"));
        f1(new Holder<Object>(0.1d));
    }
}

class Holder<T>{
    private T obj;

    public Holder(T obj){
        this.obj = obj;
    }
    
    public void set(T obj){
        this.obj = obj;
    }

    public T get(){
        return obj;
    }
}
//注意：这里JDK新的编译器可能经过了优化，没有书中所说的一些warning。
//output 
/**
Integer
Integer
Object
Double
String
Double
*/
```

`f1()`中的类型参数都是确切的，没有通配符或者是边界。在`f2()`中，Holder的类型参数是一个误解通配符，因此看起来是未知的，但是在`f2()`中，`f1()`被调用，而`f1()`需要一个**已知的参数**，这里所发生的是：参数类型在调用`f2()`的过程中被捕获。因此，它可以在对`f1()`的调用中使用。

那么问题来了：这项技术是否可以用于写入，但是这要求要再传递`Holder<?>`的同时传递一个**具体类型**，捕获转换只有在这种情况下才可以工作；即在方法内部，你还是需要使用确切的类型的。
注意不能从`f2()`中返回`T`,因为`T`对于`f2()`是未知的。捕获转换很有趣，但是也是有限制的。（PECS一直是不变的）。


#### 15.11.2 实现参数化接口

一个类不实现同一个泛型接口的两种变体，由于擦除的原因，这两个接口会变成相同的接口

```java
interface Payable<T>{}

class Employee implements Payable<Employee>{}

class Hourly extends Employee implements Payable<Hourly>{}

```
Holy不能编译，因为擦除会将`Payable<Employee>`和`Payable<Hourly>`简化为相同的类`Payable`。

#### 15.11.3 转型和警告

使用带有泛型类型参数的转型或`instanceof`不会有任何效果，下面的容器在内部将各个值存储为Object,并在获取这些值时，强制转换为T;
> JDK 中 Stack的实现也是Object数组存储，然后pop时强制转换为T类型

```java
/**
 * Created by hefuduo on 2017/6/28.
 */
public class FixedSizeStack<T> {
    private int index = 0;
    private int length = 0;
    private Object[] elements;
    public FixedSizeStack(){
        
    }
    public FixedSizeStack(int size){
        elements = new Object[size];
    }
    public void push(T item){
        elements[index++] = item;
        length++;
    }
    
    public T pop(){
        length--;
        return (T)elements[index--];
    }

    public int getLength() {
        return length;
    }

    public static void main(String[] args){
        FixedSizeStack<String> strings = new FixedSizeStack<String>(15);
        for (String s: "A B C D E F G H I J K".split(" ")){
            strings.push(s);
        }
        for (int i = 0; i < strings.getLength(); i++){
            String s = strings.pop();
            System.out.println(s);
        }
    }
}

```

可能会产生警告，因为编译器将对`pop()`发出"unchecked cast"警告，由于擦除的原因，编译器无法知道这个类型转化是否是安全的。并且`pop()`方法实际上并没有执行任何类型转换。这是因为T被擦除到他的第一个边界，Object。因此出站方法实际上只是将Object转为Object。

#### 15.11.4 重载
由于类型擦除的原因，类型参数是不包含在重载函数的函数签名中的。

#### 15.11.5 基类劫持了接口

加入你有一个Pet类，它可以与其他的Pet对象进行比较(实现了`Comparable Interface`)

```java
public class ComparablePet implements Comparable<ComparablePet>{

}
```
对可以与`ComparablePet` 的子类比较的类型进行窄化是有意义的。例如，一个`Cat`对象就只能与其他Cat对象比较。
这个时候，比较遗憾的事情发生了。
```java
//compile error.
//ERROR: cannot be inherited with different type arguments"ComparablePet" and "Cat"
class Cat extends  ComparablePet implements Comparable<Cat>{
    
}
```
```java
class Hamster extends ComparablePet implements Comparable<ComparablePet>{
    
    @Override
    public int compareTo(ComparablePet o) {
        return super.compareTo(o);
    }
}

//or just
class Hamster extends ComparablePet implements Comparable<ComparablePet>{

}

```
Hamster说明了再次实现`ComparablePet`中的相同的接口是可能的，只要他们能够精确的相同，包括类型参数也要相同。但是这只是腹泻基类中的方法是相同的。

### 15.12 自限定类型

在Java泛型中，有一个好像是经常出现的惯用法，相当令人费解。

```java
class SelfBounded<T extends SelfBounded<T>>{

}
```
这就像两面彼此对照的镜子一样，是一种无限反射。`SelfBounded`类接受泛型参数T，而T有一个边界类限定，这个边界类就是拥有`T`作为其参数的`SelfBounded`类。

#### 15.12.1 古怪的循环泛型

为理解自限定类型的含义，我们从简单的入手。

```java
class GenericType<T>{}
public class CuriouslyRecurringGeneric extends GenericType<CuriouslyRecurringGeneric>(){}
```
>古怪的循环：类相当奇怪的出现在它自己的基类中。

含义：我们创建了一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其类型参数。
下面一种情况能够很好的说明问题：

```java
public class BasicHolder<T>{
  T element;
  void set(T arg){
    element = arg;
  }
  T get(){
    return element;
  }
  void f(){
    System.out.println(element.getClass.getSimpleName());
  }
}
```

这是一个普通的泛型类型，他的方法将接受和生产具有其阐述类型的对象，还有一个方法将在其存储的域上执行操作，我们可以在一个股改的循环泛型中使用BasicHolder.
```java
class Subtype extends BasicHolder<Subtype>{
  public static void main(String[] args){
  Subtype st1 = new Subtype();
  Subtype st2 = new Subtype();
  st1.set(st2);
  Subtype st3 = st1.get();
  st1.f();
  }
}
//output Subtype
```
新类接受Subtype接受的参数和返回的值具有Subtype类型而不仅仅是基类BasicHolder类型。即：**基类用导出类代替其参数**这个意味着泛型基类编程了一种其所有导出了类的公共功能的模板。


#### 15.12.2 自限定

自限定将采取额外的步骤，强制泛型当其自己的边界参数来使用。

BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样。

```java
class Other{}
class BasicOther extends BasicHolder<Other>{}
public class Unconstrained {
  public static void main(String[] args){
    BasicOther b = new BasicOther().b2 = new BasicOther();
    b.set(new Other());
    Other other = b.get();
    b.f();
  }
 }

}

//out put :
//Other
```
自限定将采取而外的步骤，*强制泛型*当作其自己的边界参数来使用，观察所产生的类可以如何使用以及不可以如何使用。

```java
class SelfBounded<T extends SelfBounded<T>>{
  T elemnt;
  SelfBounded<T> set(T arg){
    element = arg;
    return this;
  }
  T get(){
    return element;
  }
}

class A extends SelfBounded<A>{}
class B extends SelfBounded<A>{}

class C extends SelfBounded<C>{
  C setAndGet(C arg){
    set(arg);
    return get();
  }
}

class D{}

class E extends SelfBounded<D>{} //ERROR,param D is not within it's bound.

class F extends SelfBounded{}

public class SelfBounding{
  public static void main(String[] args){
    A a = new A();
    a.set(new A());
    a = a.set(new A()).get();
    a = a.get();
    c = c.setAndGet(new C());
  }
}
```

自限定所做的，就是要在继承关系中，像下面这样使用这个类：
```java
class A extends SelfBounded<A>{}
```
这会强制要求将正在定义的类当做参数传递给基类。

此外，还可以将自限定用于泛型方法。


#### 15.12.3 参数协变
自限定类型的价值在于他们可以产生协变参数类型-方法参数类型会随着子类变化而变化，尽管自限性类型还可以产生于子类类型相同的返回类型。

```java
class Base{}
class Derived extends Base{}

interface OrdinaryGettter{
  Base get();
}

interface DerivedGetter extends OrdinaryGetter{
  //Return type of overridden method is allowed to vary;
  Derived get();
}

public class CovariantReturnTypes{
  void test(DerivedGetter d){
    Derived d2 = d.get();
  }
}
```

`DerivedGetter`中的`get()`方法覆盖了`OrdinaryGetter`中的`get()`，并返回了一个从`OrdinaryGetter.get()`的返回类型中导出的类型。尽管这是完全合乎逻辑的事情，但是这在早期的Java版本中是不合法的。

自限定泛型事实上将产生确切的导出类型作为其返回值，就像是在get()中所看到的一样。

### 15.13 动态类型安全

因为可以向Java SE5之前的代码传递*泛型容器*，所以旧式代码仍旧有可能会破坏你的容器。

### 15.14 异常
由于擦除的原因，将泛型应用于异常是非常受限制的，catch语句**不能捕获泛型类型的异常**，因为在编译器和运行时都必须要知道异常的确切类型，泛型类也不能直接或间接继承自Throwable。

但是类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而繁盛变化的泛型代码。

```java
interface Processor<T,E extend Exception>{
  void process(List<T> resultCollector) throws E;
}

//嗯，这个看起来真的好吗？
```

`Processor`执行`process()`，并且可能会抛出具有类型E的异常，如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。

### 15.15 混型

术语：
>混型随时间的推移就好像拥有了无数的含义，但是最基本的概念是混合多个类的能力。

#### 15.15.1 C++中的混型
在C++中，使用*多重继承*最大的理由，就是为了使用混型。但是对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是集成字其类型参数的类，在C++中可以很容易的创建混型，因为C++nenggou记住其模板参数的类型。

#### 15.15.2 与接口混合

一种更常见的推荐解决方案是使用接口来产生混型效果：

```java

interface TimeStamped{
  long getStamp();
}

class TimeStampedImp implements TimeStamped{
  private final long timeStamp;
  public TimeStampedImp(){
    timeStamp = new Date().getTime();
  }
  
   public long getStamp(){
     return timeStamp;
   }
}

interface SerialNumbered{
  long getSerialNumber();
}

class SerialNumbered implemenets SerialNumbered{
}

interface Basic{
  public void set(String val);
  public void get();
}

class BasicImp implements Basic{
  private String value;
  public void set(String val){
    value = val;
  }
  public String get(){
    return value;
  }
}


class Mixin extends BasicImp 
 implements TimeStamped, SerialNumbered{
   //Override the functions
 }
```
#### 15.15.3 使用装饰器模式

使用装饰器模式组合




