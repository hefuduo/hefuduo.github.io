---
layout:     post
title:      "深入理解Java虚拟机系列"
subtitle:   "内存区域与内存溢出"
date:       2018-01-29 11:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
    - JVM
---



[TOC]

# Java内存区域与内存溢出

Java虚拟机所管理的内存分为以下几个运行时数据区域



[JVM规范](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5)

![内存区域图示](http://7xkjk9.com1.z0.glb.clouddn.com/jvm-1.jpg)

## 程序计数器

当前线程所执行的字节码的行号指示器,每条线程都拥有一个独立的程序计数器,各个线程之间不共享,这种内存区域为*"线程私有"*的内存.

如果线程正在执行的是Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果是native方法,那么这个计数器的值为空(Undefined),这个区域是唯一一个在Java虚拟机规范中没有规定OOM情况的区域.

## Java虚拟机栈

与程序计数器一样,Java虚拟机栈也是线程私有的.它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:

​	每个方法在执行的同时,都会创建一个栈帧,用于存储**局部变量表,操作数栈,动态链接,方法出口等信息**.每个方法从调用开始一直到执行完成的过程,就对应着一个栈帧在虚拟机栈中从出站到入栈的过程.

概念模型: 局部变量表,操作数栈,动态链接,返回地址

### 局部变量表

是一组变量值的存储空间,用于存放方法参数和局部变量在Class 文件的方法表的 Code 属性的 max_locals 指定了该方法所需局部变量表的最大容量.变量槽(variable slot)是局部变量表的最下单位,一个slot可以存放boolean byte cahr short int float reference 和return address 八种类型.对于64位long和double变量,虚拟机会为其分配两个连续的slot空间.当调用方法是非静态方法时,局部变量表中第0位索引的Slot默认是用于传递方法所述对象实例的引用,即this关键字指向的对象.slot是可重用的(节省栈帧空间)

《Practical Java》一书中把”不使用的对象应手动赋值为 null “作为一条推荐的**编码规则**，这并不是一个完全没有意义的操作。但是不应该对 赋 null 值有过多的依赖，主要有两点原因：

- 从编码的角度来讲，用恰当的变量作用域来控制变量的回收才是最优雅的解决方法。
- 从执行角度将，使用赋值 null 的操作优化内存回收是建立在对字节码执行引擎概念模型基础上的，但是概念模型与实际执行模型可能完全不同。在使用解释器执行时，通常离概念模型还比较接近，但是一旦经过JIT 编译为本地代码才是虚拟机执行代码的主要方式，赋 null 值在JIT编译优化之后会被完全消除，这时候赋 null 值是完全没有意义的。

### 操作数栈

操作数栈（Operand Stack）也常称为操作栈，是一个后入先出栈。在Class 文件的Code 属性的 max_stacks 指定了执行过程中最大的栈深度。Java 虚拟机的解释执行引擎称为”**基于栈的执行引擎**“，这里的栈就是指操作数栈。

方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。

在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一**部分重叠**。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递。

### 动态链接

每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的**动态连接**（Dynamic Linking）。

Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为**静态解析**。另一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接**。

### 方法返回地址

当一个方法开始执行以后，只有两种方法可以退出当前方法：

- 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。
- 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。

当方法返回时，可能进行3个操作：

- 恢复上层方法的局部变量表和操作数栈
- 把返回值压入调用者调用者栈帧的操作数栈
- 调整 PC 计数器的值以指向方法调用指令后面的一条指令

### 附加信息

虚拟机规范并没有规定具体虚拟机实现包含什么附加信息，这部分的内容完全取决于具体实现。在实际开发中，一般会把动态连接，方法返回地址和附加信息全部归为一类，称为**栈帧信息**。



在Java虚拟机规范中,对这个区域规定了两种异常情况:

 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展,如果扩展是无法申请到足够的内存,就会抛出OOM异常.

## 本地方法栈

与虚拟机栈作用相似,只不过前者是执行Java方法,而本地方法栈执行的是Native方法.异常类型同上



## Java 堆

Java堆是Java虚拟机所管理的内存中最大的一块.Java堆是被**所有线程共享的一块内存区域.**在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例.JVM虚拟机规范描述: 所有的对象实例以及数组都要在对上分配内存.

Java堆是垃圾回收管理的主要区域,因此很多时候也被称之为"GC"堆. 如果堆内存无法扩展,将会抛出OOM异常

## 方法区

方法区与堆一样,是各个线程共享的内存区域,它用于存储一杯虚拟机加载的类信息,常量,静态变量,及时编译器编译后的代码等数据.

## 运行时常量池

运行时常量池是方法区的一个部分.Class文件中除了有类的版本,字段,方法,接口的描述信息外,还有一项信息就是常量池,用于存放编译期生成的各种字面常量和符号的引用,这部分内容将在类加载后进入方法去的运行时常量池中存放.

### 直接内存

...





