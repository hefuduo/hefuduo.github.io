---
layout:     post
title:      "Android View系列"
subtitle:   "View事件体系"
date:       2017-12-04 16:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Android	
---



# View的事件体系

​	

## 1. 基础知识

### 1.1 View简介

View是所有Android显示控件的基类,View可以嵌套显示,形成一个类似于DOM的树形结构,可以以下面的一张图很明显的说明.

![图片渲染失败](/img/androidview/view_tree.png)

### 1.2 View的位置参数

View是一块矩形的显示区域,由View的四个顶点指定位置.分别由四个边到父布局的距离指定的.

TOP:上边到父布局的距离

LEFT:下边到父布局的距离

BOTTOM:左边到父布局的距离

RIGHT:右边到父布局的距离

![图片加载出错](/img/androidview/screen.png)



```
width = right - left;
height = bottom - top;

left = view#getLeft();
right = view#getRight();
bottom = view#getBottom();
top = view#getTop();

width = view#getMeasuredWidth();  //在view被测量之后
height = view#getMeasuredHeight(); //在view被测量之后
```

此外, 还有几个参数可以表示view的位置

x,y表示view的左上角的坐标,translateX和translateY表示view的左上角相对父view的偏移量.并且translateX和translateY默认值是0;

> 获取View在全局坐标系中的x,y值.

```

view#getLocationOnScreen(int[] location)  //计算全局坐标系中的xy的值,包括了状态栏.
view#getLocationInWindow(int[] location)  //获取视图所在window 的绝对坐标.

//以上获取在onCreate中获取的时候都是0,需要等待UI控件加载完毕才能获取.
```

### 1.3 View 的touch事件

View的触摸事件由一个MotionEvent对象记录,该对象会记录touch类型,发生的位置.



```
void onTouchEvent(MotionEvent e){
  
}
```



```
view#getX()
view#getY() 获取的是相对当前view的点击事件发生的x和y坐标.

而view#getRawX()和view#getRawY()获取的是相对于屏幕左上角的坐标.
```

此外,当手指在屏幕上滑动时候,会有一个识别最小滑动的触发阈值.这个阈值可以通过`ViewConfiguration`这个类获取

```
float touchSlop = ViewConfiguration.get(Context context).getScaledTouchSlop();
```

### 1.4 手势识别

#### VelocityTacker

```java
VelocityTracker mVelocityTracker = VelocityTracker.obtain();

@Override
public boolean onTouch(View view,MotionEvent motionEvent){
        mVelocityTracker.addMovement(motionEvent);
        int action = motionEvent.getActionMasked();
        switch (action){
            case MotionEvent.ACTION_DOWN:
                break;
            case MotionEvent.ACTION_MOVE:
                mVelocityTracker.computeCurrentVelocity(1000); //获取速度之前都要先计算速度.
                break;
            case MotionEvent.ACTION_UP:
                float xV = mVelocityTracker.getXVelocity();
                float yV = mVelocityTracker.getYVelocity();
                Log.d(TAG, "onTouch: " + "x = " + xV + ",y = " + yV);
                break;
        }
        return true;
}

@Override
public void onDestroy(){
  //回收内存
    mVelocityTracker.clear();
  	mVelocityTracker.recycle();
}
```

### GestureDetector

```java
GestureureDetector mGestureDetecotr = null;

@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mView = findViewById(R.id.scroll_view);
        mView.setOnTouchListener(this);
        mView.setFocusable(true);
        mView.setClickable(true);
        mView.setLongClickable(true);
        mVelocityTracker = VelocityTracker.obtain();
        mGestureDetector = new GestureDetector(this,new GestureDetector.SimpleOnGestureListener(){
            @Override
            public boolean onSingleTapConfirmed(MotionEvent e) {
                Log.d(TAG, "onSingleTapConfirmed: ");
                return true;
            }

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                Log.d(TAG, "onDoubleTap: ");
                return true;
            }

            @Override
            public boolean onDoubleTapEvent(MotionEvent e) {
                Log.d(TAG, "onDoubleTapEvent: ");
                return true;
            }

            @Override
            public boolean onSingleTapUp(MotionEvent e) {
                Log.d(TAG, "onSingleTapUp: ");
                return true;
            }

            @Override
            public boolean onDown(MotionEvent e) {
                Log.d(TAG, "onDown: ");
                return false;
            }

            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                Log.d(TAG, "onFling: ");
                return true;
            }
        });
        mGestureDetector.setIsLongpressEnabled(false);
    }


	@Override
    public boolean onTouch(View view, MotionEvent motionEvent) {
        return mGestureDetector.onTouchEvent(motionEvent);
    }
```

日常开发中常用`GestureDetector`来监听`onDoubleTap `,`onFling`,`onScroll`等.



### Scroller

弹性滑动对象,用来实现`View`的弹性滑动.当使用View 的`ScrollTo`和`ScrollBy`方法来进行滑动的时候,都是瞬间完成的,没有过渡效果的滑动体验非常不好.这个时候就可以使用Scroller来实现滑动的效果.这个滑动过程不是瞬间完成的,而是在一定时间间隔内完成的.`Scroller`本身无法让`View`弹性滑动,它需要和`View`的`computerScroll`方法配合使用才能完成这个功能.

使用:

```java
Scroller mScroller = new Scroller(CmContext);

private void smoothScrollTo(int destX,int destY){
    /**
     * Return the scrolled left position of this view. This is the left edge of
     * the displayed part of your view. You do not need to draw any pixels
     * farther left, since those are outside of the frame of your view on
     * screen.
     *
     * @return The left edge of the displayed part of your view, in pixels.
     */  
  int scrollX = getScrollX();
  int delta = destX - scrollX;
  //1000ms 内滑向destX,缓慢滑动
  mScroller.startScroll(scrollX,0,delta,0,1000);
  invalidate();
}

    /**
     * Called by a parent to request that a child update its values for mScrollX
     * and mScrollY if necessary. This will typically be done if the child is
     * animating a scroll using a {@link android.widget.Scroller Scroller}
     * object.
     */
@Override
public void computeScroll(){
    if(mScroller.computeScrollOffset()){
       scrollTo(mScroller.getCurrentX(),mScroller.getCurrentY);
       postInvalidate();
    }
}
```





## 2. View的滑动

> 实现View的滑动可以有三种方式: 1. View本身提供的scrollTo和ScrollBy方法 2. 通过动画使View发生平移变化实现滑动.3. 通过改变View的LayoutParams实现View的滑动.

### 2.1 ScrollTo/ScrollBy

`scrollBy`是`scrollTo` 的相对滑动,二者都是view内容相对view边缘的滑动,view本身在布局中的位置是不会变化的.

滑动时候,左上偏移为正,右下偏移为负.

### 2.2 使用动画

注意使用view动画并不会改变View的原始位置,可以通过使用属性动画,来改变View的位置.

### 2.3 改变布局参数

通过改变View的margin即可.



## 3. 弹性滑动

通过动画和Scroller实现View的弹性滑动. 见代码:

```java
public class MyScrollView extends View {

    Scroller mScroller;

    public MyScrollView(Context context) {
        this(context, null);
    }

    public MyScrollView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public MyScrollView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public MyScrollView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    Paint mPaint;
    public void init() {
        mScroller = new Scroller(getContext());
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setColor(0xff00ddcc);
    }

    public void smoothScrollTo(int destX, int destY) {
        int scrollX = getScrollX();
        int deltaX = destX - scrollX;
        mScroller.startScroll(scrollX, 0, deltaX, 0,1000);
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawRect(getLeft(),getTop(),getRight(),getBottom(),mPaint);
    }

    @Override
    public void computeScroll() {
        if (mScroller.computeScrollOffset()){
            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
            postInvalidate();
        }
    }
}
```



在MainActivity中

```java
public class MainActivity extends AppCompatActivity {

    private static final String TAG = "MainActivity";

    MyScrollView mView;
    Button mButton;
    boolean isSwitched = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mView = findViewById(R.id.scroll_view);
        mButton = findViewById(R.id.button);
        mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (isSwitched){
                    mView.smoothScrollTo(-1000,0);
                    isSwitched = false;
                }else{
                    mView.smoothScrollTo(1000,0);
                    isSwitched = true;
                }
            }
        });
    }
}
```



**效果图:**
其中蓝色的是`View`的内容,红色的是背景

![scoller](/img/androidview/scroller.gif)





**`Scroller`原理:**

Scoller本身不能使View完成滑动,要配合View的computeScroll方法才能完成弹性滑动效果,其根本原理,是不断的重绘制View,直到到达指定位置.



## 4. View的事件分发机制

> 点击事件的分发过程主要由三个很重要的方法完成.
>
> `dispatchTouchEvent, onInterceptTouchEvent, onTouchEvent`

```java
/**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */
public boolean dispatchTouchEvent(MotionEvent event);  //这是view的方法
 //受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响,标识是否消耗当前的事件.


 /**
     * Implement this method to intercept all touch screen motion events.  This
     * allows you to watch events as they are dispatched to your children, and
     * take ownership of the current gesture at any point.
     *
     * <p>Using this function takes some care, as it has a fairly complicated
     * interaction with {@link View#onTouchEvent(MotionEvent)
     * View.onTouchEvent(MotionEvent)}, and using it requires implementing
     * that method as well as this one in the correct way.  Events will be
     * received in the following order:
     *
     * <ol>
     * <li> You will receive the down event here.
     * <li> The down event will be handled either by a child of this view
     * group, or given to your own onTouchEvent() method to handle; this means
     * you should implement onTouchEvent() to return true, so you will
     * continue to see the rest of the gesture (instead of looking for
     * a parent view to handle it).  Also, by returning true from
     * onTouchEvent(), you will not receive any following
     * events in onInterceptTouchEvent() and all touch processing must
     * happen in onTouchEvent() like normal.
     * <li> For as long as you return false from this function, each following
     * event (up to and including the final up) will be delivered first here
     * and then to the target's onTouchEvent().
     * <li> If you return true from here, you will not receive any
     * following events: the target view will receive the same event but
     * with the action {@link MotionEvent#ACTION_CANCEL}, and all further
     * events will be delivered to your onTouchEvent() method and no longer
     * appear here.
     * </ol>
     *
     * @param ev The motion event being dispatched down the hierarchy.
     * @return Return true to steal motion events from the children and have
     * them dispatched to this ViewGroup through onTouchEvent().
     * The current target will receive an ACTION_CANCEL event, and no further
     * messages will be delivered here.
     */
    public boolean onInterceptTouchEvent(MotionEvent ev) //viewGroup的方法
      
      
      
    //判断是否拦截某个事件,如果当前View拦截了事件,那么在一个事件序列中,此方法不会被调用,返回结果表示是否拦截当前事件.
    
   /**
     * Implement this method to handle touch screen motion events.
     * <p>
     * If this method is used to detect click actions, it is recommended that
     * the actions be performed by implementing and calling
     * {@link #performClick()}. This will ensure consistent system behavior,
     * including:
     * <ul>
     * <li>obeying click sound preferences
     * <li>dispatching OnClickListener calls
     * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
     * accessibility features are enabled
     * </ul>
     *
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    public boolean onTouchEvent(MotionEvent event)
    //在dispatchTouchEvent方法中调用,用来处理点击事件,返回结果表示是否消耗了当前事件,如果不消耗,则在同一个事件中,当前View无法再次接受到事件.
```



上面三个方法的关系可以使用下面的伪代码来表示:

```java
//this = current view witch has received the event.

public boolean dispatchTouchEvent(MotionEvent ev){
  boolean consume = false;
  if(onInterceptTouchEvent(ev)){
      consume = onTouchEvent(ev)
  }else{
      consume = child.dispatchTouchEvent(ev);
  }
  return consume;
}
```

此外,当一个View被设置了`onTouchListener`那么`onTouchListener`中的`ouTouch`方法就会被调用.如果返回`false`,那么继续调用`onTouchEvent`,否则不在调用`onTouchEvent`.如果设置了`onClickListener`,它的优先级比`onTouchEvent`的优先级低.



## 5. 解决滑动冲突

> 当内外两层嵌套的View都可以滑动的时候,就产生了滑动冲突.

### 1. 滑动冲突的场景

常见的滑动冲突主要由三种场景:

1. 两层嵌套内外滑动方向不一致
2. 两层嵌套内外滑动方向一致
3. 多层嵌套,内外滑动有一致的也有不一致的方向

对于场景1,ViewPager和Fragment(内不是一个ListView的时候).就会产生滑动冲突,但是ViewPager内部对滑动冲突做了处理.但是每当使用SrollView等控件的时候,就需要手动处理滑动冲突了.否则造成的后果就是内外两层只有一层能够滑动.

对于场景2,内外两层在一个方向上滑动,存在逻辑上的问题.

对于场景3,是场景1和2的综合体,因此只要分别处理了以上两种情况就可以了.



### 2. 滑动冲突的处理规则

1. 外部拦截方法

点击事件都先经过父容器,如果父容器需要相应这个事件,那么就拦截掉,如果不需要,那么就传递给子视图.

伪代码;

```java
public void onInterceptTouchEvent(MotionEvent event){
  boolean intercepted = false;
  int x = event.getX();
  int y = event.getY();
  swtich(event.getAction()){
    case MotionEvent.ACTION_DOWN:
    intercepted = false; //如果拦截了down事件,那么后续的move和up事件,子视图就无法接收了.
    break;
    case MotionEvent.ACTION_MOVE:
    if(parentNeed){
        intercepted = true;
    }else{
        intercepted = false;
    }
    break;
    case MotionEvent.ACTION_UP:
    intercepted = false;  //一旦拦截了,子视图就无法响应click事件了
    break;
    case default:
    intercepted = false;
    break
  }
  mLastXIntercepted = x;
  mLastYIntercepted = y;
  return intercepted;
}
```

*注意啊,划重点了*

**考虑一种情况,假设事件交由子元素处理,如果父容器在 ACTION_UP时返回了true,就会导致子元素无法接收到ACTION_UP事件,这个时候子元素中的onClick事件就无法触发,但是父容器比较特殊,一旦他开始拦截任何一个事件,那么后续的事件都会交给它来处理,而ACTION_UP作为最后一个事件也必定传给父容器,即使父容器的onInterceptOnTouchEvent方法在ACTION_DOWN的时候返回了false**

2. 内部拦截法

内部拦截法是指父容器不拦截任何事件,所有事件都传递给子元素,如果子元素需要此事件就消耗掉,否则交给父容器来处理.

这种方式不做推荐.

伪代码:

```java
//重写子View的dispatchTouchEvent(MotionEvent event)

public boolean dispatchTouchEvent(MotionEvent event){
  int x = event.getX();
  int y = event.getY();
  switch(event.getMaskedAction()){
    case MotionEvent.ACTION_DOWN:
      parent.requestDisallowInterceptTouchEvent(true);   
      break;
    case MotionEvent.ACTION_MOVE:
      int deltaX = x - mLastX;
      int deltaY = y - mLastY;
      if(parentNeed){
          parent.requestDisallowInterceptTouchEvent(false);//当调用此方法时候,父视图开始拦截事件
      }
      break;
    case MotionEvent.ACTION_UP:
      break;
      default :
      break;
  }
  mLastX = x;
  mLastY = y;
  return super.dispatchTouchEvent(event);
}

//此外,父元素也需要拦截除了ACTION_DOWN意外的其他事件
//父视图
public boolean onInterceptTouchEvent(MotionEvent event){
    if(event.getMaskedAciton == MotionEvent.ACTION_DOWN){
        return false;  //父视图不能拦截ACTION_DOWN事件,否则接下来的事件无法传递到子视图.`
    }else{
        return true;
    }
}
```

