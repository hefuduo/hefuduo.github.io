---
layout:     post
title:      "Kotlin从入门到放弃"
subtitle:   "Other"
date:       2019-09-04 19:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Koltin
---



[TOC]

# 解构声明

把一个对象*解构*成很多变量会很方便

```kotlin
val (name, age) = person
println(name)
println(age)
```

这种语法称为*解构声明*, 一个解构声明同时创建了很多的变量, 你可以单独使用这些变量

一个解构声明被编译成以下的代码:

```kotlin
val name = person.component1()
val age = person.componen2()
```

其中`component1` 和`component2`是Koltin广泛使用的约定原则的一个例子(操作符重载).

任何表达式都可以出现在解构声明的右侧, 只要可以对它调用所需数量的component函数即可.

请注意:

`componentN`函数需要用`operator`关键字标记, 以允许在解构声明中使用它们.解构声明也可以用再`for-`循环中.

```for((a,b) in collection){}```

变量`a`和`b`的值取自对集合中的元素上调用`component1`和`component2`的返回值

例子: 从函数中返回两个变量

```kotlin
//使用数据类
data class Result(val result: Int, val status: Status)
fun function(...): Result{ 
	//,,,,
  return Result(result, status)
}
//使用该函数
val (result, status) = function(...)
```

因为数据类自动声明了`componentN`函数, 因此可以使用解构声明

我们也可以使用标准类`Pair`并且让函数返回`Pair<Int, Status>`但是让数据合理命名通常更好.

例子: 解构声明和映射

可能遍历一个映射最好的方式是这样的:

```kotlin
for((key, value) in map) {
  //使用该key, value
}
```

为了使其能用我们应该:

1. 提供一个`iterator`函数将映射标识为一个值的序列
2. 提供函数`component1`和`component2`来将每个元素呈现为一对.

标准库的实现:

```kotlin
operator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()
operator fun <K, V> Map.Entry<K, V>.component1() = getKey()
operator fun <K, V> Map.Entry<K, V>.component2() = getValue()
```

可以使用`_`下划线站位不使用的解构变量



## 在Lambda表达式中使用解构

如果lambda表达式具有`Pair`类型的参数那么可以使用解构声明语法

```kotlin
map.mapValues {entry -> "${entry.value}"}
map.mapValues {(key, value) -> "$value!"}
```

可以指定整个解构的参数的类型或者分别指定特定组件的类型

```kotlin
map.mapValues { (_, value): Map.Entry<Int, String> -> "$value!" }

map.mapValues { (_, value: String) -> "$value!" }
```





# 类型检查和转换: `is` and `as`





# This 表达式

To denote the current *receiver*, we use *this* expressions:

- In a member of a [class](https://kotlinlang.org/docs/reference/classes.html#inheritance), *this* refers to the current object of that class.
- In an [extension function](https://kotlinlang.org/docs/reference/extensions.html) or a [function literal with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) *this* denotes the *receiver* parameter that is passed on the left-hand side of a dot.

If *this* has no qualifiers, it refers to the *innermost enclosing scope*. To refer to *this* in other scopes, *label qualifiers* are used:

```kotlin
class A { // implicit label @A
    inner class B { // implicit label @B
        fun Int.foo() { // implicit label @foo
            val a = this@A // A's this
            val b = this@B // B's this

            val c = this // foo()'s receiver, an Int
            val c1 = this@foo // foo()'s receiver, an Int

            val funLit = lambda@ fun String.() {
                val d = this // funLit's receiver
            }


            val funLit2 = { s: String ->
                // foo()'s receiver, since enclosing lambda expression
                // doesn't have any receiver
                val d1 = this
            }
        }
    }
}
```



# 相等性

