---
layout:     post
title:      "Java学习笔记14"
subtitle:   "类型信息"
date:       2016-12-21 17:40:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---

# 第14章 类型信息

### 14.1 RTTI

RTTI（Run-Time Type Information)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类

RTTI提供了以下两个非常有用的操作符：

（1）typeid操作符，返回指针和引用所指的实际类型。

（2）dynamic_cast操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。

面向对象的编程语言，像C++，Java，delphi都提供了对RTTI的支持。



### 14.2 Class对象

类是程序的一部分，每个类都有一个Class对象。每当编写并且编译了一个新类，就会产生一个Class对象（准确说是被保存在一个同名的.class文件中）。为了生成这个累的对象，运行这个程序的JVM将使用“类加载器”的子系统。



所有的类都是在对其第一次使用时，动态的加载到JVM中的。当程序创建第一个对象的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字，因此使用new操作符创建类的新对象也会别当做类的静态成员的引用。



因此，Java程序在它开始运行之前并非被完全加载，各个部分都是在必需时才加载的，这些与许多传统语言不同。动态加载使能的行为，在类似C++这样的静态加载语言中很那或者是根本不能复制的，

类加载器首先检查这个Class对象是否已经加载，如果尚未加载，默认的累加扎起就会根据类名查找Class文件（例如某个附加类加载器可能会在数据库中查找字节码）。在这个累的字节码被加载时，它们会接受验证（verify）以确保其没有被破坏，并且不包含不良的Java代码（这是Java中用于安全防范目的的措施之一）。



一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。

```java
class Candy{
  static{
    print("Loading Candy");
  }
}
class Gum{
  static{
    print("Loading Gum");
  }
}

class Cookie{
  static{
    print("Loading Cookie");
  }
}

public class SweetShop{

  public static void main(String[] args){
    print("inside main");
    new Candy();
    print("After creating Candy");
    try{
      Class.forName("Gum");
    }catch(ClassNotFoundException e){
      print("Couldn't find class Gum");
    }
    print("After class.forName(\"Gum\")" );
    
    new Cookie();
    print("After creating Cookie");
  }
}


/*
The output 

inside main

Loading Candy
After creating Candy

Loading Gum
After class.forName("Gum")

Loading Cookie
After creating Cookie
*/
```



由此可知，类对象尽在需要的时候被加载，static初始化是在类加载时进行的。

`Class.forName(String arg)`

注意这个方法，这个方法是Class类的一个Static成员。Class度意向就和其他对象一样。

forName方法是取得Class对象的引用的一种方法，他使用一个包含目标类的文本名的String作为输入参数，返回一个Class对象的引用（经常能在反射中看到这个）。上面的代码忽略的返回值，而利用的是该方法的一个“副作用”：如果累Gum还没有被加载我就加它，在它加载的过程中，Gum的static自己被执行。



如果该方法找不到arg所指的类，则会抛出一个ClassNotFoundException异常类型。



无论何时，只要你想在运行时使用类型信息，就必须首先获得恰当的Class对象的引用，Class.forName就是实现此功能的便捷途径，因为你不需要为了获得Class引用而持有该类型的对象。但是，如果你已经有有一个感兴趣的类型的对象，可以直接调用该对象的getClass()方法直接获取该类型的对象。



### 14.3类型转换前先做检查

如果执行了一次错误的类型转换，程序会抛出一个ClassCastException



`instanceof `关键字



此外，还有动态的instanceof

`Class.isInstance`

```
public boolean isInstance(Object obj)
```

Determines if the specified `Object` is assignment-compatible with the object represented by this `Class`. This method is the dynamic equivalent of the Java language `instanceof` operator. The method returns `true` if the specified `Object` argument is non-null and can be cast to the reference type represented by this `Class` object without raising a `ClassCastException.` It returns `false` otherwise.Specifically, if this `Class` object represents a declared class, this method returns `true` if the specified `Object` argument is an instance of the represented class (or of any of its subclasses); it returns `false` otherwise. If this `Class` object represents an array class, this method returns `true` if the specified `Object` argument can be converted to an object of the array class by an identity conversion or by a widening reference conversion; it returns `false` otherwise. If this `Class` object represents an interface, this method returns `true` if the class or any superclass of the specified `Object` argument implements this interface; it returns `false`otherwise. If this `Class` object represents a primitive type, this method returns `false`.



### 14.4 动态代理

> 代理是基本的设计模式之一，他是你为了提供而外的或不同的操作，而插入的用来代替实际对象的对象。
>
> 这些操作通常涉及与实际对象的通信，因此代理通常充当着中间人的角色。

