---
layout:     post
title:      "Kotlin学习笔记2"
subtitle:   "Class and Inheriances"
date:       2019-08-21 16:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin	
---



# Kotlin 学习笔记2

## Classes and Inheritance 类与继承

###  Classes

```kotlin
//keyword class
class Invoice{}
```



#### Constructors

A class in Kotlin can have a **primary constructor** and one or more **secondary constructors**. The primary constructor is part of the class header: it goes after the class name (and optional type parameters)

主构造函数,跟随类名

```kotlin
class Person constructor(firName: String) {
  
}
```

If the primary constructor does not have any annotations or visibility modifiers, the *constructor* keyword can be omitted:

主构造函数不带任何注解和可见性修饰符,  `constructor` 关键字可以被省略

```kotlin
class Person(firstname: String) {}
```

The primary constructor cannot contain any code. Initialization code can be placed in **initializer blocks**, which are prefixed with the *init* keyword.

主构造函数不能包含任何代码, 所有的初始化操作都放在`init block`代码块中

During an instance initialization, the initializer blocks are executed in the same order as they appear in the class body, interleaved with the property initializers:

在实例初始化期间, 初始化块在body中按照顺序执行,插入在属性初始化器中

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}

fun main(args: Array<String>) {
    val p = InitOrderDemo("li")
    println(p.firstProperty)
    println(p.secondProperty)
}

First property: li
First initializer block that prints li
Second property: 2
Second initializer block that prints 2
First property: li
Second property: 2
```

Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:

主构造函数中的参数能在初始化块中使用, 也能够在类体重的属性初始化中使用

```kotlin
class Customer(name: String) {
  val customerKey = name.toUpperCase()
}
```

In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:

参数构造器与属性声明与初始化一同进行

```kotlin
class Person(val fristName: String, val lastName: String, var age: int)
```

Much the same way as regular properties, the properties declared in the primary constructor can be mutable (*var*) or read-only (*val*).

f the constructor has annotations or visibility modifiers, the *constructor* keyword is required, and the modifiers go before it:

```kotlin
class Customer public @Inject constructor(name: String){
  
}
```



#### Sencondary constructors

声明次构造函数 使用`constructors`

```kotlin
class Person (){
    private var children: MutableList<Person> = mutableListOf()
    constructor(parent: Person) : this() {
        parent.children.add(this)
    }
}
```

Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:

`init`代码块一定会在次构造函数之前执行



```kotlin
class Test {
    init {
        println("init block")
    }

    constructor() {
        println("secondary constructor")
    }
}

//output
/*
init block
secondary constructor
*/
```



> **NOTE**: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.

> ```kotlin
> class Customer(val customerName: String = "")
> ```
>
> 

#### Creating instancees of classes

类似C++ 的创建方式



### 继承

If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor.

```kotlin
open class Base(p: Int)		
class Derived(p: Int) : Base(p)
```



使用`super`关键字调用父类构造函数

```kotlin
class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```



#### Overriding Methods

As we mentioned before, we stick to making things explicit in Kotlin. So, Kotlin requires explicit modifiers for overridable members (we call them *open*) and for overrides:

必须显式的指定open 和 override

```kotlin
//use open modifier to make the class can be inheriate
open class Shape {  
  open fun draw() {} //use open to make the method  can be overrided
  fun fill()
}

class Circle() : Shape() {
  override fun draw() {}
}
```

The *override* modifier is required for `Circle.draw()`. If it were missing, the compiler would complain. If there is no *open* modifier on a function, like `Shape.fill()`, declaring a method with the same signature in a subclass is illegal, either with *override* or without it. The *open*modifier has no effect when added on members of a final class (i.e.. a class with no *open*modifier).

如果没有使用`open`修饰函数,那么子类使用相同的签名将是不合法的.

A member marked *override* is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use *final*:

使用override修饰的自带open属性, 如果不想方法被覆盖,使用`final`直接修饰方法.



#### Overriding Properties

覆盖属性与覆盖方法类似

Overriding properties works in a similar way to overriding methods; properties declared on a superclass that are then redeclared on a derived class must be prefaced with *override*, and they must have a compatible type. Each declared property can be overridden by a property with an initializer or by a property with a `get` method.

```kotlin
open class Shape {
  open val vertexCount: Int = 0
}

class Rectangle: Shape() {
  override val vertexCount = 4
}
```

You can also override a `val` property with a `var` property, but not (vice versa)(反之亦然). This is allowed because a `val` property essentially declares a `get` method, and overriding it as a `var` additionally declares a `set` method in the derived class.

Note that you can use the *override* keyword as part of the property declaration in a primary constructor.

`var` 可以覆盖`val`反之则不行

在主构造函数中直接指定可覆写的属性

```kotlin
interface Shape {
    val vertexCount: Int
}

class Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices

class Polygon : Shape {
    override var vertexCount: Int = 0  // Can be set to any number later
}
```

#### Derived class initialization order

During construction of a new instance of a derived class, the base class initialization is done as the first step (preceded only by evaluation of the arguments for the base class constructor) and thus happens before the initialization logic of the derived class is run.

```kotlin
open class Base(val name: String) {

    init {
        println("Initializing Base")
    }

    open val size: Int =
            name.length.also { println("Initializing size in Base: $it") }
}

class Derived(
        name: String,
        val lastName: String
) : Base(name.capitalize().also { println("Argument for Base: $it") }) {

    init {
      //从输出来看, 如果此时在这个init块中使用size属性, 在运行时按照初始化顺序这个值为3, 而不是预想的5, 这个一定要注意, 尽量避免在 constructor init 属性初始化这三个地方使用open的properties
        println("Initializing Derived")
    }

    override val size: Int =
            (super.size + lastName.length).also { println("Initializing size in Derived: $it") }
}
```

输出

```text
//output
Argument for Base: Leo
Initializing Base
Initializing size in Base: 3
Initializing Derived
Initializing size in Derived: 5
```

It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden *open* member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using *open* members in the constructors, property initializers, and *init* blocks.

当父类构造函数执行时. 在子类声明或覆盖的属性并没有执行初始化操作, 如果任何这些属性在父类初始化逻辑中使用到了, 可能会出现运行时异常, 当设计一个父类的时候, 因此需要避免在构造函数中, 属性初始化中, 初始化块中使用`open member`

#### Calling the superclass implementation

Code in a derived class can call its superclass functions and property accessors implementations using the *super* keyword:

```kotlin
open class Rectangle {
        open fun draw() { println("Drawing a rectangle") }
        val borderColor: String get() = "black"
    }

    class FilledRectangle : Rectangle() {
        override fun draw() {
            super.draw // calling the super method
            println("Filling the rectangle")
        }

        val fillColor: String get() = super.borderColor
    }
```



Inside an inner class, accessing the superclass of the outer class is done with the *super*keyword qualified with the outer class name: `super@Outer`:

use `this@Outer` 引用当期那类属性.

```Kotlin
//nested class
open class Rectangle {
    open fun draw() { println("Drawing a rectangle") }
    open val borderColor: String get() = "black"
}


class FilledRectangle : Rectangle() {
    override fun draw(){}
    override val borderColor : String get() = "red"
    inner class Filler {
        fun fill() {}
        fun drawAndFill() {
            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()
            fill()
            println("Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}") // Uses Rectangle's implementation of borderColor's get()
            println("this ${this@FilledRectangle.borderColor}")
        }
    }
}
```



#### Overriding Rules

In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use *super* qualified by the supertype name in angle brackets, e.g. `super<Base>`:

```kotlin
open class Rectangle {
    open fun draw() { /* ... */ }
}

interface Polygon {
    fun draw() { /* ... */ } // interface members are 'open' by default
}

class Square() : Rectangle(), Polygon {
    // The compiler requires draw() to be overridden:
    override fun draw() {
        super<Rectangle>.draw() // call to Rectangle.draw()
        super<Polygon>.draw() // call to Polygon.draw()
    }
}
```

It's fine to inherit from both `Rectangle` and `Polygon`, but both of them have their implementations of `draw()`, so we have to override `draw()` in `Square` and provide its own implementation that eliminates the ambiguity.

#### Abstract Classes

A class and some of its members may be declared *abstract*. An abstract member does not have an implementation in its class. Note that we do not need to annotate an abstract class or function with open – it goes without saying.

We can override a non-abstract open member with an abstract one



```kotlin
open class Polygon {
  open fun draw() {}
}

abstract class Rectangle : Polygon() {
  override abstract fun draw()
}
```

or e.g.

```kotlin
abstract class A {
    abstract fun test()
}

class B : A() {
    override fun test() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

```



#### Companion objects

伴生对象

If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an [object declaration](https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.

Even more specifically, if you declare a [companion object](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) inside your class, you'll be able to call its members using only the class name as a qualifier.



## 属性和字段 Properties and Fields

### Declaring Properties

`var` mutable `val` immutable

```kotlin
class Address {
    var name: String = "Holmes, Sherlock"
    var street: String = "Baker"
    var city: String = "London"
    var state: String? = null
    var zip: String = "123456"
}
```

To use a property, simply refer to it by name:

```kotlin
fun copyAddress(address: Address) : Address {
  val result = Address() // there's no 'new' keyword in Kotlin
    result.name = address.name // accessors are called
    result.street = address.street
    // ...
    return result
}
```

### Getters and Setters

Declaring a property use this syntax

```shell
var|val <propertyName> [: <PropertyType>] [=PropertyValue] [<getter>] [<setter>]
```



e.g.

```kotlin
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied 必须被初始化
var initialized = 1 // has type Int, default getter and setter
```

The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with `val` instead of `var` and does not allow a setter:

只读属性只有`getter` 没有`setter`

```kotlin
val simple: Int? // has type Int, default getter, must be initialized in constructor
val inferredType = 1 // has type Int and a default getter
```

We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:

自定义属性访问器

```kotlin
val isEmpty: Boolean
    get() = this.size == 0
```

If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:

使用自定义属性`setter`

```kotlin
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }

//访问与设置
stringRepresentation = "?" (setter)
val a = stringRepresenation (getter)
```

By convention, the name of the setter parameter is `value`, but you can choose a different name if you prefer.

Since Kotlin 1.1, you can omit the property type if it can be inferred from the getter:

`value`是默认的`set`参数名, 从koltin`1.1`开始, 属性类型可以被省略,因为类型可以被类型推断系统确定类型

```kotlin
val isEmpty get() = this.size == 0  // has type Boolean
```



设置属性访问器的可见性

```kotlin
var setterVisibility: String = "abc"
	private set//the setter is private and has the default implementation
var setterWithAnnotation: Any? = null
@Inject set//annotate the setter with Inject
```



### Backing Fields

Fields cannot be declared directly in Kotlin classes. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the `field` identifier:

使用`field`关键字引用幕后字段

```kotlin
var counter = 0
	set(value) {
    if(value >= 0) field = value //field is the backing field
	}
```



<font color="red">The `field` identifier can only be used in the accessors of the property.</font>

A backing field will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the `field` identifier.

For example, in the following case there will be no backing field:

```kotlin
val isEmpty: Boolean 
	get() = this.size ==0 
//这中情况没有backing field
```

### Backing Properties

If you want to do something that does not fit into this "implicit backing field" scheme, you can always fall back to having a *backing property*:

如果不想使用`implicit backing field`可以直接使用退化的*backing property*

```kotlin
class C {
    private var _table: HashMap<String, String>? = null
    val table: Map<String, String>
        get() {
            if (_table == null) {
                _table = HashMap()
            }
            return _table ?: throw IllegalArgumentException("error argument")
        }
}

```

> **On the JVM**: The access to private properties with default getters and setters is optimized so no function call overhead is introduced in this case.





### Compile-Time Constants 编译时常量

Properties the value of which is known at compile time can be marked as *compile time constants*using the *const* modifier. Such properties need to fulfil the following requirements:

- Top-level, or member of an [*object* declaration](https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations) or [a *companion object*](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects).
- Initialized with a value of type `String` or a primitive type
- No custom getter

### Late-Initialized Properties and Variables

Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.

To handle this case, you can mark the property with the `lateinit` modifier:

使用`lateinit`来标记延迟初始化的属性,避免属性被编译器空检查

```kotlin
public class MyTest {
    lateinit var subject: TestSubject 

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // dereference directly
    }
}
```



The modifier can be used on `var` properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.

Accessing a `lateinit` property before it has been initialized throws a special exception that clearly identifies the property being accessed and the fact that it hasn't been initialized.

能够在class的body内修饰var属性(不能在主构造函数中使用,并且属性不能够有自定义属性访问器) 从kotlin 1.2, 顶级属性和本地变量. 

属性的类型必须是非空的, 并且不能是基础类型(Int Double Byte ...)



### Override Properties

See @ override Properties Chapter

### Delegate Properties

See @ delegate Properties 



## Interfaces

Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.

An interface is defined using the keyword *interface*

```kotlin
interface MyInterface {
  fun bar()
  fun foo() {
    //optional body default
  }
}
```



### Implementing Interfaces

A class or object can implement one or more interfaces

```kotlin
class Child : MyInterface {
    override fun bar() {
        // body
    }
}
```

You can declare properties in interfaces. A property declared in an interface can either be abstract, or it can provide implementations for accessors. Properties declared in interfaces can't have backing fields, and therefore accessors declared in interfaces can't reference them.

### Perperties in Interfaces 

在kotlin的接口中可以声明属性, 属性是可以被覆写的, 或者能够有一个默认的访问器, 在接口中定义的属性不能有幕后字段, 因此不能够在interfaces中定义访问器索引他们

```kotlin
interface MyInterface {
  val prop: Int // abstract
  val propertyWithImplementation: String
  	get() = "foo"
  fun foo() {
    print(prop)
  }
}

class Child : MyInterface {
  override val prop: Int = 29
}
```



### Interfaces Inheritance

接口的继承

一个接口能够继承自另一个接口,并且提供新的属性和方法,又提供了父类的实现. 类实现属性可以只定义剩下的未实现的方法或属性

```kotlin
interface Named {
  val name: String
}

interface Person : Named {
  val firstName : String
  val lastName: String
  
 override val name : String get() = "$firstName $lastName"
}

data class Employee(
  override val firstName: String,
  override val lastName: String,
  val position: Position
) : Person
```

### Resolving Override confilicts

解决覆盖冲突
当我们在父类中声明了很多类型, 可能出现在继承时, 可能出现多个实现对应一个方法, 举例:

```kotlin
interface A {
  fun foo() {
    print("A")
  }
  fun bar()
}

interface B {
  fun foo() {
    print("B")
  }
  fun bar() {
    print("bar")
  }
}

class C : A {
  override fun bar() {print("bar")}
}

class D : A, B {
  override fun foo() {
    super<A>.foo()
    super<B>.foo()
  }
  
  override fun bar() {
    super<B>.bar()
  }
}
```

Interfaces *A* and *B* both declare functions *foo()* and *bar()*. Both of them implement *foo()*, but only *B*implements *bar()* (*bar()* is not marked abstract in *A*, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class *C* from *A*, we, obviously, have to override *bar()*and provide an implementation.

However, if we derive *D* from *A* and *B*, we need to implement all the methods which we have inherited from multiple interfaces, and to specify how exactly *D* should implement them. This rule applies both to methods for which we've inherited a single implementation (*bar()*) and multiple implementations (*foo()*).



`class D `中从A和B中都继承了相同的方法, 那么调用A中的还是B中的呢, 需要明确指定父类的方法.



## Visibility Modifiers 可见性修饰

四个可见性修饰符

1. `private` 仅当前类的实例
2. `public`都可见
3. `protected`当前类和类的子类实例
4. `internal`当前模块

### Packages

`public` 是默认的, `protected`不能作为顶级声明使用



### Classes and Interfaces

Example

```kotlin
open class Outer {
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4  // public by default
    
    protected class Nested {
        public val e: Int = 5
    }
}

class Subclass : Outer() {
    // a is not visible
    // b, c and d are visible
    // Nested and e are visible

    override val b = 5   // 'b' is protected
}

class Unrelated(o: Outer) {
    // o.a, o.b are not visible
    // o.c and o.d are visible (same module)
    // Outer.Nested is not visible, and Nested::e is not visible either 
}
```

### Constructor

To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit *constructor* keyword):

```kotlin
class C private constructor(a: Int) { ... }
```

### 什么是模块

-  IntelliJ IDEA module;
- a Maven project;
- a Gradle source set (with the exception that the `test` source set can access the internal declarations of `main`);
- a set of files compiled with one invocation of the `<kotlinc>` Ant task.





## Extensions 扩展

Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called *extensions*. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called *extension functions*. There are also *extension properties* that let you define new properties for existing classes.

### Extension functions 扩展函数

To declare an extension function, we need to prefix its name with a *receiver type*, i.e. the type being extended. The following adds a `swap` function to `MutableList<Int>`:

扩展函数需要前置一个接受类型, 指定对哪个类型的扩展

```kotlin
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
```

扩展函数的形式

```
fun <genericType> [receiveType][<genericType>].[function name]([parameters]): [returnType] {
	[body]
}
```

其中,`this`指向`receive object` 本身.

```kotlin
val list = mutableListOf(1, 2, 3)
list.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'
```

进一步修改让它支持泛型

```kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
```



### Extensions are resolved Statically

扩展是类似Java的静态方法





### Nullable Receiver

可空接收者

Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even if its value is null, and can check for `this == null` inside the body. This is what allows you to call toString() in Kotlin without checking for null: the check happens inside the extension function.

```kotlin
fun Any?.toString(): String{
  if(this == null) return "null"
  return toString();
}
```

### Extension Properties 扩展属性

与扩展方法类似

```kotlin
val <T> List<T>.lastIndex: Int 
	get() == size - 1
```

Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a [backing field](https://kotlinlang.org/docs/reference/properties.html#backing-fields). This is why **initializers are not allowed for extension properties**. Their behavior can only be defined by explicitly providing getters/setters

```kotlin
val House.number = 1 //error: initializers are not allowed for extension properties
```



### Companion object extensions  伴生对象扩展

If a class has a [companion object](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) defined, you can also define extension functions and properties for the companion object. Just like regular members of the companion object, they can be called using only the class name as the qualifier:

```kotlin
class MyClass {
  companion object {} //will be called "Companion"
}

fun MyClass.Companion.printCompanion() {
  println("compation")
}

fun main() {
  MyClass.printCompanion();
}
```



### Scope of extensions 扩展的作用域

Most of the time we define extensions on the top level - directly under packages:

在包名下定义顶级扩展

```kotlin
package org.example.declarations
 
fun List<String>.getLongestString() { /*...*/}
```

使用时, import 进来

```kotlin
package org.example.usage

import org.example.declarations.getLongestString

fun main() {
    val list = listOf("red", "green", "blue")
    list.getLongestString()
}
```

### Declaring extensions as members

Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple *implicit receivers* - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called *dispatch receiver*, and the instance of the receiver type of the extension method is called *extension receiver*.

```kotlin
class Host(val hostname: String) {
  fun printHostname() {print(hostname)}
}

class Connection(val host: Host, val port: Int){
  fun printPort() {
    print(port)
  }
  
  fun Host.printConnectionString(p: Int) {
    printHostname()    //call Host.printHostname
    print(":")
    printPort()     call Connection.printPort
  }
  
  fun connect() {
    host.printConnectionString(port) //calls the extension function
  }
}


fun main() {
  Connection(Host("kotl.in"), 443).connect();
  //Host("Kotl.in").printConnectionString(443) //ERROR, the extension function is unavailable outside Connection
}

```



In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the [qualified `this` syntax](https://kotlinlang.org/docs/reference/this-expressions.html#qualified).

```kotlin
class Connection {
    fun Host.getConnectionString() {
        toString()         // calls Host.toString()
        this@Connection.toString()  // calls Connection.toString()
    }
}
```

Extensions declared as members can be declared as `open` and overridden in subclasses. This means that the dispatch of such functions is virtual with regard to the dispatch receiver type, but static with regard to the extension receiver type.

**在class内部的扩展成员也能够声明成可被覆写的**

```kotlin
open class Base { }

class Derived : Base() { }

open class BaseCaller {
    open fun Base.printFunctionInfo() {
        println("Base extension function in BaseCaller")
    }

    open fun Derived.printFunctionInfo() {
        println("Derived extension function in BaseCaller")
    }

    fun call(b: Base) {
        b.printFunctionInfo()   // call the extension function
    }
}

class DerivedCaller: BaseCaller() {
    override fun Base.printFunctionInfo() {
        println("Base extension function in DerivedCaller")
    }

    override fun Derived.printFunctionInfo() {
        println("Derived extension function in DerivedCaller")
    }
}

fun main() {
    BaseCaller().call(Base())   // "Base extension function in BaseCaller"
    DerivedCaller().call(Base())  // "Base extension function in DerivedCaller" - dispatch receiver is resolved virtually
    DerivedCaller().call(Derived())  // "Base extension function in DerivedCaller" - extension receiver is resolved statically

```



### NOTE On visibility

Extensions utilize the same [visibility of other entities](https://kotlinlang.org/docs/reference/visibility-modifiers.html) as regular functions declared in the same scope would. For example:

- An extension declared on top level of a file has access to the other `private` top-level declarations in the same file;
- If an extension is declared outside its receiver type, such an extension cannot access the receiver's `private` members.





## Data Classes  数据类

We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a *data class* and is marked as `data`:



```kotlin
data class User(val name: String, val age: Int)
```

The compiler automatically derives the following members from all properties declared in the primary constructor:

- `equals()`/`hashCode()` pair;
- `toString()` of the form `"User(name=John, age=42)"`;
- [`componentN()` functions](https://kotlinlang.org/docs/reference/multi-declarations.html) corresponding to the properties in their order of declaration;
- `copy()` function (see below).

To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:

为了确保一致性和有意义的自动代码, 数据了类必须满足一下要求

- The primary constructor needs to have at least one parameter; 主构造函数至少要有一个参数
- All primary constructor parameters need to be marked as `val` or `var`; 所有主构造函数的参数都必须被标记为`val`或者是`var`
- Data classes cannot be abstract, open, sealed or inner; 数据类不能是抽象的 , 可扩展, 密封的或是内部的
- (before 1.1) Data classes may only implement interfaces. 数据类型只能实现接口

Additionally, the members generation follows these rules with regard to the members inheritance:

此外,成员遵循以下继承的规则

- If there are explicit implementations of `equals()`, `hashCode()` or `toString()` in the data class body or *final* implementations in a superclass, then these functions are not generated, and the existing implementations are used;
- If a supertype has the `componentN()` functions that are *open* and return compatible types, the corresponding functions are generated for the data class and override those of the supertype. If the functions of the supertype cannot be overridden due to incompatible signatures or being final, an error is reported;
- Deriving a data class from a type that already has a `copy(...)` function with a matching signature is deprecated in Kotlin 1.2 and is prohibited in Kotlin 1.3.
- Providing explicit implementations for the `componentN()` and `copy()` functions is not allowed.

Since 1.1, data classes may extend other classes (see [Sealed classes](https://kotlinlang.org/docs/reference/sealed-classes.html) for examples).

On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see [Constructors](https://kotlinlang.org/docs/reference/classes.html#constructors)).

```kotlin
data class User(val name: String = "", val age: Int = 0)
```

Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:

将一个属性从自动产生的实现中移除, 则在类体中声明它

```kotlin
data class person(val name: String) {
  var age: Int = 0
}
```

Only the property `name` will be used inside the `toString()`, `equals()`, `hashCode()`, and `copy()`implementations, and there will only be one component function `component1()`. While two `Person`objects can have different ages, they will be treated as equal.

```kotlin
val person1 = Person("John")
val person2 = Person("John")
person1.age = 10
person2.age = 20
```



### Copying 复制

It's often the case that we need to copy an object altering *some* of its properties, but keeping the rest unchanged. This is what `copy()` function is generated for. For the `User` class above, its implementation would be as follows:

```kotlin
fun copy(name: String = this.name, age: Int = this.age) = User(name, age)
```

This allows us to write:

```kotlin
val jack = User(name = "jack", age = 1)
val olderJack = jack.copy(age = 2)
```



### Data  Class and Descrucuring Declarations 数据类型和解构声明

```kotlin
val jane = User("Jane", 35)
val (name, age) = jane
println("$name, $age years of age")
```



### Standard Data Classes 标准数据类

标注函数库提提供了`Pair`和`Triple`. 在大多数情况下, 尽管, 命名数据类是一个更好的设计选择, 因为这使得代码更加可读, 并且为属性提供了有意义的名称.



## Sealed Classes 密封类

Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.

To declare a sealed class, you put the `sealed` modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).

```kotlin
sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()
```

(The example above uses one additional new feature of Kotlin 1.1: the possibility for data classes to extend other classes, including sealed classes.)

A sealed class is [abstract](https://kotlinlang.org/docs/reference/classes.html#abstract-classes) by itself, it cannot be instantiated directly and can have *abstract* members.

Sealed classes are not allowed to have non-*private* constructors (their constructors are *private* by default).

Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in the same file.

The key benefit of using sealed classes comes into play when you use them in a [`when` expression](https://kotlinlang.org/docs/reference/control-flow.html#when-expression). If it's possible to verify that the statement covers all cases, you don't need to add an `else` clause to the statement. However, this works only if you use `when` as an expression (using the result) and not as a statement.

```kotlin
fun eval(expr: Expr): Double = when(expr) {
    is Const -> expr.number
    is Sum -> eval(expr.e1) + eval(expr.e2)
    NotANumber -> Double.NaN
    // the `else` clause is not required because we've covered all the cases
}
```

## 泛型

类似Java, Koltin也有类型参数

```kotlin
class Box<T>(t: T) {
  var value = t
}
//大体上我们需要在创建实例时,提供参数的具体类型
val box: Box<Int> = Box<Int>(1)
```

如果参数类型能够被推断, 则可以省略

```kotlin
val box = Box(1) // 类型参数可以被省略
```



### Variance 变量

One of the most tricky parts of Java's type system is wildcard types (see [Java Generics FAQ](http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)). And Kotlin doesn't have any. Instead, it has two other things: declaration-site variance and type projections.

Kotlin没有类型通配符

irst, let's think about why Java needs those mysterious wildcards. The problem is explained in [Effective Java, 3rd Edition](http://www.oracle.com/technetwork/java/effectivejava-136174.html), Item 31: *Use bounded wildcards to increase API flexibility*. First, generic types in Java are **invariant**, meaning that `List<String>` is **not** a subtype of `List<Object>`. Why so? If List was not **invariant**, it would have been no better than Java's arrays, since the following code would have compiled and caused an exception at runtime:

```java
// Java
List<String> strs = new ArrayList<String>();
List<Object> objs = strs; // !!! The cause of the upcoming problem sits here. Java prohibits this!
objs.add(1); // Here we put an Integer into a list of Strings
String s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String
```

避免产生歧义

So, Java prohibits such things in order to guarantee run-time safety. But this has some implications. For example, consider the `addAll()` method from `Collection` interface. What's the signature of this method? Intuitively, we'd put it this way:

```java
//java
interface Collection<E> {
  void addAll(Collection<E> items)
}
```

But then, we would not be able to do the following simple thing (which is perfectly safe):

```java
//Java
void copyAll(Collection<Object> to, Collection<String> from) {
  to.addAll(from);
  //Error.
}
```

(In Java, we learned this lesson the hard way, see [Effective Java, 3rd Edition](http://www.oracle.com/technetwork/java/effectivejava-136174.html), Item 28: *Prefer lists to arrays*)

That's why the actual signature of `addAll()` is the following:

```java
//Java
interface Collection<E> {
  void addAll(Collection<? extends E> items);
}
```

The **wildcard type argument** `? extends E` indicates that this method accepts a collection of objects of `E` *or some subtype of* `E`, not just `E` itself. This means that we can safely **read** `E`'s from items (elements of this collection are instances of a subclass of E), but **cannot write** to it since we do not know what objects comply to that unknown subtype of `E`. In return for this limitation, we have the desired behaviour: `Collection<String>` *is* a subtype of `Collection<? extends Object>`. In "clever words", the wildcard with an **extends**-bound (**upper** bound) makes the type **covariant**.

The key to understanding why this trick works is rather simple: if you can only **take** items from a collection, then using a collection of `String`s and reading `Object`s from it is fine. Conversely, if you can only *put* items into the collection, it's OK to take a collection of `Object`s and put `String`s into it: in Java we have `List<? super String>` a **supertype** of `List<Object>`.

The latter is called **contravariance**, and you can only call methods that take String as an argument on `List<? super String>` (e.g., you can call `add(String)` or `set(int, String)`), while if you call something that returns `T` in `List<T>`, you don't get a `String`, but an `Object`.

Joshua Bloch calls those objects you only **read** from **Producers**, and those you only **write** to **Consumers**. He recommends: "*For maximum flexibility, use wildcard types on input parameters that represent producers or consumers*", and proposes the following mnemonic:

*PECS stands for Producer-Extends, Consumer-Super.*

*NOTE*: if you use a producer-object, say, `List<? extends Foo>`, you are not allowed to call `add()` or `set()` on this object, but this does not mean that this object is **immutable**: for example, nothing prevents you from calling `clear()` to remove all items from the list, since `clear()` does not take any parameters at all. The only thing guaranteed by wildcards (or other types of variance) is **type safety**. Immutability is a completely different story.



### Declaration-site variance

Suppose we have a generic interface `Source<T>` that does not have any methods that take `T` as a parameter, only methods that return `T`:

```java
interface Source<T> {
  T nextT();
}
```

Then, it would be perfectly safe to store a reference to an instance of `Source<String>` in a variable of type `Source<Object>` – there are no consumer-methods to call. But Java does not know this, and still prohibits it:

```java
void demo(Source<String> strs) {
  Source<Object> objects = strs; //ERROR Not allowed in Java
}
```

To fix this, we have to declare objects of type `Source<? extends Object>`, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.

n Kotlin, there is a way to explain this sort of thing to the compiler. This is called **declaration-site variance**: we can annotate the **type parameter** `T` of Source to make sure that it is only **returned**(produced) from members of `Source<T>`, and never consumed. To do this we provide the **out** modifier:

```kotlin
interface Source<out T> {
  fun nextT(): T
}

fun demo(strs: Source<String>) {
  val objects: Source<Any> = str // this is ok, since T is an out-parameter
}
```

The general rule is: when a type parameter `T` of a class `C` is declared **out**, it may occur only in **out**-position in the members of `C`, but in return `C<Base>` can safely be a supertype of `C<Derived>`.

通用规则: 当一个class `C`的类型参数`T`被声明为`out`, 他只能出现在`C`的`out-position`, `C<Base>`能够安全的成为`C<Derive>`的父类型

In "clever words" they say that the class `C` is **covariant** in the parameter `T`, or that `T` is a **covariant**type parameter. You can think of `C` as being a **producer** of `T`'s, and NOT a **consumer** of `T`'s.

`T`称为协变参数.

The **out** modifier is called a **variance annotation**, and since it is provided at the type parameter declaration site, we talk about **declaration-site variance**. This is in contrast with Java's **use-site variance** where wildcards in the type usages make the types covariant.

In addition to **out**, Kotlin provides a complementary variance annotation: **in**. It makes a type parameter **contravariant**: it can only be consumed and never produced. A good example of a contravariant type is `Comparable`:



```kotlin
interface Comparable<in T> {
  operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
  x.compareTo(1.0) //1.0 has type double , which is subtype of Number
  val y: Comparable<Double> = x //OK!
}
```

We believe that the words **in** and **out** are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:

准则: Consumer  in, Producer  Out!  = POCI

out => extends , in => super

### Type Projections

t is very convenient to declare a type parameter T as *out* and avoid trouble with subtyping on the use site, but some classes **can't** actually be restricted to only return `T`'s! A good example of this is Array:

```kotlin
class Array<T>(val size: Int) {
    fun get(index: Int): T { ... }
    fun set(index: Int, value: T) { ... }
}
```

This class cannot be either co- or contravariant in `T`. And this imposes certain inflexibilities. Consider the following function:

```kotlin
fun copy(from: Array<Any>, to: Array<Any>) {
    assert(from.size == to.size)
    for (i in from.indices)
        to[i] = from[i]
}
```

This function is supposed to copy items from one array to another. Let's try to apply it in practice:

```kotlin
val ints: Array<Int> = arrayOf(1, 2, 3)
val any = Array<Any>(3) { "" } 
copy(ints, any)
//   ^ type is Array<Int> but Array<Any> was expected
```

Here we run into the same familiar problem: `Array<T>` is **invariant** in `T`, thus neither of `Array<Int>`and `Array<Any>` is a subtype of the other. Why? Again, because copy **might** be doing bad things, i.e. it might attempt to **write**, say, a String to `from`, and if we actually passed an array of `Int` there, a `ClassCastException` would have been thrown sometime later.

Then, the only thing we want to ensure is that `copy()` does not do any bad things. We want to prohibit it from **writing** to `from`, and we can:

```kotlin
fun copy(from: Array<out Any>, to: Array<Any>) { ... }
```

What has happened here is called **type projection**: we said that `from` is not simply an array, but a restricted (**projected**) one: we can only call those methods that return the type parameter `T`, in this case it means that we can only call `get()`. This is our approach to **use-site variance**, and corresponds to Java's `Array<? extends Object>`, but in a slightly simpler way.

You can project a type with **in** as well:

```kotlin
fun fill(dest: Array<in String>, value: String) { ... }
```

`Array<in String>` corresponds to Java's `Array<? super String>`, i.e. you can pass an array of `CharSequence` or an array of `Object` to the `fill()` function.



### Star-projections

Sometimes you want to say that you know nothing about the type argument, but still want to use it in a safe way. The safe way here is to define such a projection of the generic type, that every concrete instantiation of that generic type would be a subtype of that projection.

Kotlin provides so called **star-projection** syntax for this:

- For `Foo<out T : TUpper>`, where `T` is a covariant type parameter with the upper bound `TUpper`, `Foo<*>` is equivalent to `Foo<out TUpper>`. It means that when the `T` is unknown you can safely *read* values of `TUpper` from `Foo<*>`.
- For `Foo<in T>`, where `T` is a contravariant type parameter, `Foo<*>` is equivalent to `Foo<in Nothing>`. It means there is nothing you can *write* to `Foo<*>` in a safe way when `T` is unknown.
- For `Foo<T : TUpper>`, where `T` is an invariant type parameter with the upper bound `TUpper`, `Foo<*>` is equivalent to `Foo<out TUpper>` for reading values and to `Foo<in Nothing>` for writing values.

If a generic type has several type parameters each of them can be projected independently. For example, if the type is declared as `interface Function<in T, out U>` we can imagine the following star-projections:

- `Function<*, String>` means `Function<in Nothing, String>`;
- `Function<Int, *>` means `Function<Int, out Any?>`;
- `Function<*, *>` means `Function<in Nothing, out Any?>`.

*Note*: star-projections are very much like Java's raw types, but safe.







### Generic Functions

```kotlin
fun <T> singleTonList<item: T> : List<T> {} //normal

fun <T> T.basicToString(): String{}   // extension function
```





### Generic Constraints

The set of all possible types that can be substituted for a given type parameter may be restricted by **generic constraints**.

#### Upper Bounds

The most common type of constraint is an **upper bound** that corresponds to Java's *extends* keyword:

上界, 类似Java的`extends`关键字

```kotlin
fun <T : Comparable<T>> sort(List: List<T>){}
```

The type specified after a colon is the **upper bound**: only a subtype of `Comparable<T>` may be substituted for `T`. For example:

```kotlin
sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable<Int>
sort(listOf(HashMap<Int, String>())) // Error: HashMap<Int, String> is not a subtype of Comparable<HashMap<Int, String>>
```

The default upper bound (if none specified) is `Any?`. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate **where**-clause:

```kotlin
fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>
    where T : CharSequence,
          T : Comparable<T> {
    return list.filter { it > threshold }.map { it.toString() }
}
```

The passed type must satisfy all conditions of the `where` clause simultaneously. In the above example, the `T` type must implement *both* `CharSequence` and `Comparable`.



### Type Erasure (类型擦除)

The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be *erased*. For example, the instances of `Foo<Bar>` and `Foo<Baz?>` are erased to just `Foo<*>`.

Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler [prohibits such *is*-checks](https://kotlinlang.org/docs/reference/typecasts.html#type-erasure-and-generic-type-checks).

Type casts to generic types with concrete type arguments, e.g. `foo as List<String>`, cannot be checked at runtime.
These [unchecked casts](https://kotlinlang.org/docs/reference/typecasts.html#unchecked-casts) can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to `foo as List<*>`).

The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (`foo as T`) are unchecked. However, [reified type parameters](https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters) of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.