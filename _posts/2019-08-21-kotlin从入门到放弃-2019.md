---
layout:     post
title:      "Kotlin学习笔记2"
subtitle:   "Class and Inheriances"
date:       2019-08-21 16:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin	
---



# Kotlin 学习笔记2

## Classes and Inheritance 类与继承

###  Classes

```kotlin
//keyword class
class Invoice{}
```



#### Constructors

A class in Kotlin can have a **primary constructor** and one or more **secondary constructors**. The primary constructor is part of the class header: it goes after the class name (and optional type parameters)

主构造函数,跟随类名

```kotlin
class Person constructor(firName: String) {
  
}
```

If the primary constructor does not have any annotations or visibility modifiers, the *constructor* keyword can be omitted:

主构造函数不带任何注解和可见性修饰符,  `constructor` 关键字可以被省略

```kotlin
class Person(firstname: String) {}
```

The primary constructor cannot contain any code. Initialization code can be placed in **initializer blocks**, which are prefixed with the *init* keyword.

主构造函数不能包含任何代码, 所有的初始化操作都放在`init block`代码块中

During an instance initialization, the initializer blocks are executed in the same order as they appear in the class body, interleaved with the property initializers:

在实例初始化期间, 初始化块在body中按照顺序执行,插入在属性初始化器中

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}

fun main(args: Array<String>) {
    val p = InitOrderDemo("li")
    println(p.firstProperty)
    println(p.secondProperty)
}

First property: li
First initializer block that prints li
Second property: 2
Second initializer block that prints 2
First property: li
Second property: 2
```

Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:

主构造函数中的参数能在初始化块中使用, 也能够在类体重的属性初始化中使用

```kotlin
class Customer(name: String) {
  val customerKey = name.toUpperCase()
}
```

In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:

参数构造器与属性声明与初始化一同进行

```kotlin
class Person(val fristName: String, val lastName: String, var age: int)
```

Much the same way as regular properties, the properties declared in the primary constructor can be mutable (*var*) or read-only (*val*).

f the constructor has annotations or visibility modifiers, the *constructor* keyword is required, and the modifiers go before it:

```kotlin
class Customer public @Inject constructor(name: String){
  
}
```



#### Sencondary constructors

声明次构造函数 使用`constructors`

```kotlin
class Person (){
    private var children: MutableList<Person> = mutableListOf()
    constructor(parent: Person) : this() {
        parent.children.add(this)
    }
}
```

Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:

`init`代码块一定会在次构造函数之前执行



```kotlin
class Test {
    init {
        println("init block")
    }

    constructor() {
        println("secondary constructor")
    }
}

//output
/*
init block
secondary constructor
*/
```



> **NOTE**: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.

> ```kotlin
> class Customer(val customerName: String = "")
> ```
>
> 

#### Creating instancees of classes

类似C++ 的创建方式



### 继承

If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor.

```kotlin
open class Base(p: Int)		
class Derived(p: Int) : Base(p)
```



使用`super`关键字调用父类构造函数

```kotlin
class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```



#### Overriding Methods

As we mentioned before, we stick to making things explicit in Kotlin. So, Kotlin requires explicit modifiers for overridable members (we call them *open*) and for overrides:

必须显式的指定open 和 override

```kotlin
//use open modifier to make the class can be inheriate
open class Shape {  
  open fun draw() {} //use open to make the method  can be overrided
  fun fill()
}

class Circle() : Shape() {
  override fun draw() {}
}
```

The *override* modifier is required for `Circle.draw()`. If it were missing, the compiler would complain. If there is no *open* modifier on a function, like `Shape.fill()`, declaring a method with the same signature in a subclass is illegal, either with *override* or without it. The *open*modifier has no effect when added on members of a final class (i.e.. a class with no *open*modifier).

如果没有使用`open`修饰函数,那么子类使用相同的签名将是不合法的.

A member marked *override* is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use *final*:

使用override修饰的自带open属性, 如果不想方法被覆盖,使用`final`直接修饰方法.



#### Overriding Properties

覆盖属性与覆盖方法类似

Overriding properties works in a similar way to overriding methods; properties declared on a superclass that are then redeclared on a derived class must be prefaced with *override*, and they must have a compatible type. Each declared property can be overridden by a property with an initializer or by a property with a `get` method.

```kotlin
open class Shape {
  open val vertexCount: Int = 0
}

class Rectangle: Shape() {
  override val vertexCount = 4
}
```

You can also override a `val` property with a `var` property, but not (vice versa)(反之亦然). This is allowed because a `val` property essentially declares a `get` method, and overriding it as a `var` additionally declares a `set` method in the derived class.

Note that you can use the *override* keyword as part of the property declaration in a primary constructor.

`var` 可以覆盖`val`反之则不行

在主构造函数中直接指定可覆写的属性

```kotlin
interface Shape {
    val vertexCount: Int
}

class Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices

class Polygon : Shape {
    override var vertexCount: Int = 0  // Can be set to any number later
}
```

#### Derived class initialization order

During construction of a new instance of a derived class, the base class initialization is done as the first step (preceded only by evaluation of the arguments for the base class constructor) and thus happens before the initialization logic of the derived class is run.

```kotlin
open class Base(val name: String) {

    init {
        println("Initializing Base")
    }

    open val size: Int =
            name.length.also { println("Initializing size in Base: $it") }
}

class Derived(
        name: String,
        val lastName: String
) : Base(name.capitalize().also { println("Argument for Base: $it") }) {

    init {
      //从输出来看, 如果此时在这个init块中使用size属性, 在运行时按照初始化顺序这个值为3, 而不是预想的5, 这个一定要注意, 尽量避免在 constructor init 属性初始化这三个地方使用open的properties
        println("Initializing Derived")
    }

    override val size: Int =
            (super.size + lastName.length).also { println("Initializing size in Derived: $it") }
}
```

输出

```text
//output
Argument for Base: Leo
Initializing Base
Initializing size in Base: 3
Initializing Derived
Initializing size in Derived: 5
```

It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden *open* member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using *open* members in the constructors, property initializers, and *init* blocks.

当父类构造函数执行时. 在子类声明或覆盖的属性并没有执行初始化操作, 如果任何这些属性在父类初始化逻辑中使用到了, 可能会出现运行时异常, 当设计一个父类的时候, 因此需要避免在构造函数中, 属性初始化中, 初始化块中使用`open member`

#### Calling the superclass implementation

Code in a derived class can call its superclass functions and property accessors implementations using the *super* keyword:

```kotlin
open class Rectangle {
        open fun draw() { println("Drawing a rectangle") }
        val borderColor: String get() = "black"
    }

    class FilledRectangle : Rectangle() {
        override fun draw() {
            super.draw // calling the super method
            println("Filling the rectangle")
        }

        val fillColor: String get() = super.borderColor
    }
```



Inside an inner class, accessing the superclass of the outer class is done with the *super*keyword qualified with the outer class name: `super@Outer`:

use `this@Outer` 引用当期那类属性.

```Kotlin
//nested class
open class Rectangle {
    open fun draw() { println("Drawing a rectangle") }
    open val borderColor: String get() = "black"
}


class FilledRectangle : Rectangle() {
    override fun draw(){}
    override val borderColor : String get() = "red"
    inner class Filler {
        fun fill() {}
        fun drawAndFill() {
            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()
            fill()
            println("Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}") // Uses Rectangle's implementation of borderColor's get()
            println("this ${this@FilledRectangle.borderColor}")
        }
    }
}
```



#### Overriding Rules

In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use *super* qualified by the supertype name in angle brackets, e.g. `super<Base>`:

```kotlin
open class Rectangle {
    open fun draw() { /* ... */ }
}

interface Polygon {
    fun draw() { /* ... */ } // interface members are 'open' by default
}

class Square() : Rectangle(), Polygon {
    // The compiler requires draw() to be overridden:
    override fun draw() {
        super<Rectangle>.draw() // call to Rectangle.draw()
        super<Polygon>.draw() // call to Polygon.draw()
    }
}
```

It's fine to inherit from both `Rectangle` and `Polygon`, but both of them have their implementations of `draw()`, so we have to override `draw()` in `Square` and provide its own implementation that eliminates the ambiguity.

#### Abstract Classes

A class and some of its members may be declared *abstract*. An abstract member does not have an implementation in its class. Note that we do not need to annotate an abstract class or function with open – it goes without saying.

We can override a non-abstract open member with an abstract one



```kotlin
open class Polygon {
  open fun draw() {}
}

abstract class Rectangle : Polygon() {
  override abstract fun draw()
}
```

or e.g.

```kotlin
abstract class A {
    abstract fun test()
}

class B : A() {
    override fun test() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

```



#### Companion objects

伴生对象

If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an [object declaration](https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.

Even more specifically, if you declare a [companion object](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) inside your class, you'll be able to call its members using only the class name as a qualifier.



## 属性和字段 Properties and Fields

### Declaring Properties

`var` mutable `val` immutable

```kotlin
class Address {
    var name: String = "Holmes, Sherlock"
    var street: String = "Baker"
    var city: String = "London"
    var state: String? = null
    var zip: String = "123456"
}
```

To use a property, simply refer to it by name:

```kotlin
fun copyAddress(address: Address) : Address {
  val result = Address() // there's no 'new' keyword in Kotlin
    result.name = address.name // accessors are called
    result.street = address.street
    // ...
    return result
}
```

### Getters and Setters

Declaring a property use this syntax

```shell
var|val <propertyName> [: <PropertyType>] [=PropertyValue] [<getter>] [<setter>]
```



e.g.

```kotlin
var allByDefault: Int? // error: explicit initializer required, default getter and setter implied 必须被初始化
var initialized = 1 // has type Int, default getter and setter
```

The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with `val` instead of `var` and does not allow a setter:

只读属性只有`getter` 没有`setter`

```kotlin
val simple: Int? // has type Int, default getter, must be initialized in constructor
val inferredType = 1 // has type Int and a default getter
```

We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:

自定义属性访问器

```kotlin
val isEmpty: Boolean
    get() = this.size == 0
```

If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:

使用自定义属性`setter`

```kotlin
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }

//访问与设置
stringRepresentation = "?" (setter)
val a = stringRepresenation (getter)
```

By convention, the name of the setter parameter is `value`, but you can choose a different name if you prefer.

Since Kotlin 1.1, you can omit the property type if it can be inferred from the getter:

`value`是默认的`set`参数名, 从koltin`1.1`开始, 属性类型可以被省略,因为类型可以被类型推断系统确定类型

```kotlin
val isEmpty get() = this.size == 0  // has type Boolean
```



设置属性访问器的可见性

```kotlin
var setterVisibility: String = "abc"
	private set//the setter is private and has the default implementation
var setterWithAnnotation: Any? = null
@Inject set//annotate the setter with Inject
```



### Backing Fields

Fields cannot be declared directly in Kotlin classes. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the `field` identifier:

使用`field`关键字引用幕后字段

```kotlin
var counter = 0
	set(value) {
    if(value >= 0) field = value //field is the backing field
	}
```



<font color="red">The `field` identifier can only be used in the accessors of the property.</font>

A backing field will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the `field` identifier.

For example, in the following case there will be no backing field:

```kotlin
val isEmpty: Boolean 
	get() = this.size ==0 
//这中情况没有backing field
```

### Backing Properties

If you want to do something that does not fit into this "implicit backing field" scheme, you can always fall back to having a *backing property*:

如果不想使用`implicit backing field`可以直接使用退化的*backing property*

```kotlin
class C {
    private var _table: HashMap<String, String>? = null
    val table: Map<String, String>
        get() {
            if (_table == null) {
                _table = HashMap()
            }
            return _table ?: throw IllegalArgumentException("error argument")
        }
}

```

> **On the JVM**: The access to private properties with default getters and setters is optimized so no function call overhead is introduced in this case.





### Compile-Time Constants 编译时常量

Properties the value of which is known at compile time can be marked as *compile time constants*using the *const* modifier. Such properties need to fulfil the following requirements:

- Top-level, or member of an [*object* declaration](https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations) or [a *companion object*](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects).
- Initialized with a value of type `String` or a primitive type
- No custom getter

### Late-Initialized Properties and Variables

Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.

To handle this case, you can mark the property with the `lateinit` modifier:

使用`lateinit`来标记延迟初始化的属性,避免属性被编译器空检查

```kotlin
public class MyTest {
    lateinit var subject: TestSubject 

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // dereference directly
    }
}
```



The modifier can be used on `var` properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.

Accessing a `lateinit` property before it has been initialized throws a special exception that clearly identifies the property being accessed and the fact that it hasn't been initialized.

能够在class的body内修饰var属性(不能在主构造函数中使用,并且属性不能够有自定义属性访问器) 从kotlin 1.2, 顶级属性和本地变量. 

属性的类型必须是非空的, 并且不能是基础类型(Int Double Byte ...)



### Override Properties

See @ override Properties Chapter

### Delegate Properties

See @ delegate Properties 



## Interfaces

Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.

An interface is defined using the keyword *interface*

```kotlin
interface MyInterface {
  fun bar()
  fun foo() {
    //optional body default
  }
}
```



### Implementing Interfaces

A class or object can implement one or more interfaces

```kotlin
class Child : MyInterface {
    override fun bar() {
        // body
    }
}
```

You can declare properties in interfaces. A property declared in an interface can either be abstract, or it can provide implementations for accessors. Properties declared in interfaces can't have backing fields, and therefore accessors declared in interfaces can't reference them.

