---
layout:     post
title:      "面向切面编程"
subtitle:   "AOP（Aspect Orient Program）"
date:       2017-02-27 11:09:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
    - 编程思想
    - 软件工程
---

[TOC]

# 深入理解面向切面编程

> 面向切面编程：在运行时，动态地将代码切入到类的制定方法、  指定位置上的编程思想就是面向切面编程。一般而言：切入到制定类制定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了这种思想，我们可以吧几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。

## 面向切面编程所要解决的问题以及在Spring中的具体应用

> 面向切面编程（AOP）是对面向对象编程（OOP）的一种补充与完善，而这种技术或者是思想在Spring IoC（我也不懂是什么👻）中非常重要，Spring的一个关键的组件就是AOP框架。下面一个就是Spring中使用AOP技术的所解决问题的实例。



​        在传统的编写业务逻辑处理代码时，我们通常会习惯性地做几件事情：日志记录、事务控制及权限控制等，然后才是编写核心的业务逻辑处理代码。当代码编写完成回头再看时，不禁发现，扬扬洒洒上百行代码中，真正用于核心业务逻辑处理才那么几行，如下图所示。方法复方法，类复类，就这样子带着无可奈何遗憾地度过了多少个春秋。这倒也罢，倘若到了项目的尾声，突然决定在权限控制上需要进行大的变动时，成千上万个方法又得一一"登门拜访"，痛苦"雪上加霜"。

![aspectJ1](/img/aspectJ/aspectJ1.jpg)

​       如果能把上图所示中众多方法中的所有共有代码全部抽取出来，放置到某个地方集中管理，然后在具体运行时，再由容器动态织入这些共有代码的话，最起码可以解决两个问题：

[**Java EE**](http://lib.csdn.net/base/javaee)程序员在编写具体的业务逻辑处理方法时，只需关心核心的业务逻辑处理，既提高了工作效率，又使代码变更简洁优雅。

在日后的维护中由于业务逻辑代码与共有代码分开存放，而且共有代码是集中存放的，因此使维护工作变得简单轻松。

面向切面编程AOP技术就是为解决这个问题而诞生的，切面就是横切面，如图6-5所示，代表的是一个普遍存在的共有功能，例如，日志切面、权限切面及事务切面等。

![140615289](/img/aspectJ/140615289.jpg)



​       下面我们以用户管理业务逻辑组件UserService的AOP实现过程（见图6-6）为例，深度剖析一下AOP技术的实现原理。AOP技术是建立在Java语言的[反射机制](http://www.cnblogs.com/lzq198754/p/5780331.html)与[动态代理](http://www.2cto.com/kf/201609/546253.html)机制之上的。业务逻辑组件在运行过程中，AOP容器会动态创建一个代理对象供使用者调用，该代理对象已经按Java EE程序员的意图将切面成功切入到目标方法的连接点上，从而使切面的功能与业务逻辑的功能同时得以执行。从原理上讲，调用者直接调用的其实是AOP容器动态生成的代理对象，再由代理对象调用目标对象完成原始的业务逻辑处理，而代理对象则已经将切面与业务逻辑方法进行了合成。

![140642106](/img/aspectJ/140642106.jpg)

切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。

通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。

连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但[**spring**](http://lib.csdn.net/base/javaee)只支持方法级的连接点。

切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。

目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。

代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。

织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。

## 面向切面编程在Android中的应用

### 专业术语

Terminology：

Before we get started, let's have a look at some vocabulary that we should keep in mind:

- **Cross-cutting concerns:** Even though most classes in an OO model will perform a single, specific function, they often share common, secondary requirements with other classes. For example, we may want to add logging to classes within the data-access layer and also to classes in the UI layer whenever a thread enters or exits a method. Even though each class has a very different primary functionality, the code needed to perform the secondary functionality is often identical.
- **Advice:** The code that is injected to a class file. Typically we talk about before, after, and around advices, which are executed before, after, or instead of a target method. It’s possible to make also other changes than injecting code into methods, e.g. adding fields or interfaces to a class. 
- **Join point:** A particular point in a program that might be the target of code injection, e.g. a method call or method entry.
- **Pointcut:** An expression which tells a code injection tool where to inject a particular piece of code, i.e. to which joint points to apply a particular advice. It could select only a single such point – e.g. execution of a single method – or many similar points – e.g. executions of all methods marked with a custom annotation such as @DebugTrace.
- **Aspect:** The combination of the pointcut and the advice is termed an aspect. For instance, we add a logging aspect to our application by defining a pointcut and giving the correct advice.
- **Weaving: **The process of injecting code – advices – into the target places – joint points.

This picture summarizes a bit a few of these concepts:

![AspectOrientedProgramming](/img/aspectJ/AspectOrientedProgramming.png)



翻译：

- **Cross-cutting concerns（横切关注点）:** 尽管面向对象模型中大多数类会实现单一特定的功能，但通常也会开放一些通用的附属功能给其他类。例如，我们希望在数据访问层中的类中添加日志，同时也希望当UI层中一个线程进入或者退出调用一个方法时添加日志。尽管每个类都有一个区别于其他类的主要功能，但在代码里，仍然经常需要添加一些相同的附属功能。
- **Advice（通知）:** 注入到class文件中的代码。典型的 Advice 类型有 before、after 和 around，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码。 除了在方法中注入代码，也可能会对代码做其他修改，比如在一个class中增加字段或者接口。
- **Joint point（连接点）:** 程序中可能作为代码注入目标的特定的点，例如一个方法调用或者方法入口。
- **Pointcut（切入点）:** 告诉代码注入工具，在何处注入一段特定代码的表达式。例如，在哪些 joint points 应用一个特定的 Advice。切入点可以选择唯一一个，比如执行某一个方法，也可以有多个选择，比如，标记了一个定义成@DebguTrace 的自定义注解的所有方法。
- **Aspect（切面）:** Pointcut 和 Advice 的组合看做切面。例如，我们在应用中通过定义一个 pointcut 和给定恰当的advice，添加一个日志切面。
- **Weaving（织入）:** 注入代码（advices）到目标位置（joint points）的过程。

### 在Android中，在哪些场景下可以使用AOP？

1. 日志
2. 持久化
3. 性能监控
4. 数据认证
5. 缓存
6. 比方说埋点

那么，这些代码可以在不同的时期注入：

1. runtime：运行时注入。例如动态代理。
2. load-time：类装载时注入。这些修改可以在目标classes正在被Dalvik或者ART载入时，修改。ByteCode或DexCode weaving。
3. build-time：编译时注入。在编译过程中加入其它步骤，在打包或者发布应用前，来修改最终编译出的结果。SourceCode weaving。



### 工具和库

1. **AspectJ** ：一个可以和Java平台无缝连接的AOP扩展库，兼容Android，AspectJ有着自己的语法。（运行在JVM上的兼容Java的语言）。
2. **Javassit for Android**：二进制代码操作库。
3. **DexMaker**：一个Java运行时或编译时产生Dalvik虚拟机目标代码的工具。
4. **ASMDEX**：二进制代码操作库。


### 为什么使用AspectJ

* 非常强大
* 支持编译时和类加载时代码注入
* 使用简单



### 实例

假如我们想测量一个方法的性能（执行时间）。为了实现这个，我们标记函数使用**@DebugTrace**这个注解，并且希望使用logcat获得结果，并且不用在每个注解的方法中写代码。**使用AspectJ来实现这个目标**

![AspectWeaving](/img/aspectJ/AspectWeaving.png)

<p color="green">Project Structure</p>



**创建注解**

```java
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
public @interface DebugTrace{
  
}
```

**创建StopWatch类来监控性能**

```java
//StopWatch.class
public class StopWatch {
  private long startTime;
  private long endTime;
  private long elapsedTime;

  public StopWatch() {
    //empty
  }

  private void reset() {
    startTime = 0;
    endTime = 0;
    elapsedTime = 0;
  }

  public void start() {
    reset();
    startTime = System.nanoTime();
  }

  public void stop() {
    if (startTime != 0) {
      endTime = System.nanoTime();
      elapsedTime = endTime - startTime;
    } else {
      reset();
    }
  }

  public long getTotalTimeMillis() {
    return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;
  }
}
```

**DebugLog Class**

```java
/**
 * Wrapper around {@link android.util.Log}
 */
public class DebugLog {

  private DebugLog() {}

  /**
   * Send a debug log message
   *
   * @param tag Source of a log message.
   * @param message The message you would like logged.
   */
  public static void log(String tag, String message) {
    Log.d(tag, message);
  }
}
```

**Our Aspect**

> managing the annotation processing and source-code weaving.

**TraceAspect.java**

```java
/**
 * Aspect representing the cross cutting-concern: Method and Constructor Tracing.
 */
@Aspect
public class TraceAspect {

  private static final String POINTCUT_METHOD =
      "execution(@org.android10.gintonic.annotation.DebugTrace * *(..))";

  private static final String POINTCUT_CONSTRUCTOR =
      "execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))";

  @Pointcut(POINTCUT_METHOD)
  public void methodAnnotatedWithDebugTrace() {}

  @Pointcut(POINTCUT_CONSTRUCTOR)
  public void constructorAnnotatedDebugTrace() {}

  @Around("methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()")
  public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {
    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
    String className = methodSignature.getDeclaringType().getSimpleName();
    String methodName = methodSignature.getName();

    final StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    Object result = joinPoint.proceed();
    stopWatch.stop();

    DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));

    return result;
  }

  /**
   * Create a log message.
   *
   * @param methodName A string with the method name.
   * @param methodDuration Duration of the method in milliseconds.
   * @return A string representing message.
   */
  private static String buildLogMessage(String methodName, long methodDuration) {
    StringBuilder message = new StringBuilder();
    message.append("Gintonic --> ");
    message.append(methodName);
    message.append(" --> ");
    message.append("[");
    message.append(methodDuration);
    message.append("ms");
    message.append("]");

    return message.toString();
  }
}
```

 **在Android项目中使用AspectJ**

需要配置一下Gradle，使得使用AspectJ compiler来编译所有被AspectJ所影响的classes。

**build.gradle** 

```groovy
import com.android.build.gradle.LibraryPlugin
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:0.12.+'
    classpath 'org.aspectj:aspectjtools:1.8.1'
  }
}

apply plugin: 'android-library'

repositories {
  mavenCentral()
}

dependencies {
  compile 'org.aspectj:aspectjrt:1.8.1'
}

android {
  compileSdkVersion 19
  buildToolsVersion '19.1.0'

  lintOptions {
    abortOnError false
  }
}

android.libraryVariants.all { variant ->
  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)
  JavaCompile javaCompile = variant.javaCompile
  javaCompile.doLast {
    String[] args = ["-showWeaveInfo",
                     "-1.5",
                     "-inpath", javaCompile.destinationDir.toString(),
                     "-aspectpath", javaCompile.classpath.asPath,
                     "-d", javaCompile.destinationDir.toString(),
                     "-classpath", javaCompile.classpath.asPath,
                     "-bootclasspath", plugin.project.android.bootClasspath.join(
        File.pathSeparator)]

    MessageHandler handler = new MessageHandler(true);
    new Main().run(args, handler)

    def log = project.logger
    for (IMessage message : handler.getMessages(null, true)) {
      switch (message.getKind()) {
        case IMessage.ABORT:
        case IMessage.ERROR:
        case IMessage.FAIL:
          log.error message.message, message.thrown
          break;
        case IMessage.WARNING:
        case IMessage.INFO:
          log.info message.message, message.thrown
          break;
        case IMessage.DEBUG:
          log.debug message.message, message.thrown
          break;
      }
    }
  }
}
```

**测试方法**

```java
@DebugTrace
  private void testAnnotatedMethod() {
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }


//outputs:
//will like this:
//Gintonic --> testAnnotatedMethod --> [10ms]
```





#  AspectJ介绍

> AspectJ是一种语言，但是其也运行在JVM之上，简而言之就是JVM类语言的一种，类似Scala之类的。AspectJ也支持原生Java，只要是用AspectJ提供的注解就好了。
>
> 但是不管用什么方法，最终倒要用ajc来编译。

1.Joint Points

Joint Points（*JPoints* for short）是AspectJ中很重要的一个概念。就是程序运行时的一些执行点。（我的理解就是类似于调试时的断点。）

- 一个函数的调用可以是一个JPoint
- 设置或则读取一个变量也是一个JPoint
- for循环也可以看做是JPoint

理论上，一个程序中很多地方都可以被看做是一个JPoint，但是AspectJ中明确规定了只有下表中的这些执行点认为是JPoints

| Joint Points          | 说明               | 实例               |
| :-------------------- | :--------------- | :--------------- |
| method call           | 函数调用             | Log.e()          |
| method execution      | 函数执行             | 比如Log.e()执行内部    |
| constructor call      | 构造函数调用           | 函数调用类似           |
| constructor execution | 和函数执行类似          | 函数执行类似           |
| field get             | 获取某个变量           |                  |
| field set             | 设置某个变量           |                  |
| pre-initialization    | Object在构造函数中做的工作 |                  |
| static initializaiton | 类初始化             | 静态初始化代码块         |
| handler               | 异常处理             | trycatch中的catch块 |
| advice execution      | AspectJ内容        |                  |
|                       |                  |                  |

一个比较直观一点的例子：

利用Intelij IDEA创建一个简单的Java console Application，需要AspectJ的两个插件（具体可参考IDE的帮助手册），

新建Test.java，与JPTest.aj，如下所示。

```java
/**
 * Created by hefuduo on 2017/3/15.
 */

public class Test {
    static public class TestBase {
        static int x = 0;
        int base = 0;

        TestBase(int index) {
            base = index;
        }
    }

    static public class TestDerived extends TestBase {
        public int derived = 0;

        TestDerived() {
            super(0);
            this.derived = 1000;
        }

        public void testMethod() {
            try {
                byte[] test = null;
                test[1] = 0x33;
            } catch (Exception e) {

            }
        }

        static int getFixedIndex() {
            return 1000;
        }
    }

    public static void main(String args[]) {
        System.out.println("Test begin ...");
        TestDerived derived = new TestDerived();
        derived.testMethod();
        derived.base = 1;
        System.out.println("Test end...");
    }

}

```



```java
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.ConstructorSignature;

/**
 * Created by hefuduo on 2017/3/15.
 */
public aspect JPTest {
    pointcut testAll():within(Test);
    before():testAll(){
        System.out.println("before calling " + thisJoinPoint);
        System.out.println("     at:  " + thisJoinPoint.getSourceLocation());
    }

    after():testAll(){
        Signature sig = thisJoinPoint.getSignature();
        if(sig instanceof ConstructorSignature){
            System.out.println("after calling: " + thisJoinPoint);
            System.out.println("      at: " + thisJoinPoint.getSourceLocation());
        }
    }
}
```

然后配置Configuration（包括compiler 将项目的compiler设置为ajc）。

最后将编译好的程序运行，即可得到结果。可以尝试将Aspect类添加一个空的main方法！

2.Pointcuts

一个程序会有很多JPoints，即使是同一个函数也会分call类型和execution类型。显然，并不是所有的JPoint，也不是所有类型的JPoint是我们所关注的，举例Activity的几个生命周期函数中打印日志，只有这几个生命周期函数才是我们业务需要的JPoint，而其他的什么JPoint我不需要关注，怎么从一堆一堆的JPoints中选择自己想要的JPoints呢？Pointcuts就是用来过滤JPoints的。以下举例说明。

```tiddlywiki
//以上程序的输出结果如下所示：
before calling staticinitialization(Test.<clinit>)
     at:  Test.java:0
before calling execution(void Test.main(String[]))
     at:  Test.java:37
before calling get(PrintStream java.lang.System.out)
     at:  Test.java:38
before calling call(void java.io.PrintStream.println(String))
     at:  Test.java:38
Test begin ...
before calling call(Test.TestDerived())
     at:  Test.java:39
before calling staticinitialization(Test.TestBase.<clinit>)
     at:  Test.java:7
before calling set(int Test.TestBase.x)
     at:  Test.java:7
before calling staticinitialization(Test.TestDerived.<clinit>)
     at:  Test.java:0
before calling preinitialization(Test.TestDerived())
     at:  Test.java:18
after calling: preinitialization(Test.TestDerived())
      at: Test.java:18
before calling preinitialization(Test.TestBase(int))
     at:  Test.java:10
after calling: preinitialization(Test.TestBase(int))
      at: Test.java:10
before calling initialization(Test.TestBase(int))
     at:  Test.java:10
before calling execution(Test.TestBase(int))
     at:  Test.java:10
before calling set(int Test.TestBase.base)
     at:  Test.java:8
before calling set(int Test.TestBase.base)
     at:  Test.java:11
after calling: execution(Test.TestBase(int))
      at: Test.java:10
after calling: initialization(Test.TestBase(int))
      at: Test.java:10
before calling initialization(Test.TestDerived())
     at:  Test.java:18
before calling execution(Test.TestDerived())
     at:  Test.java:18
before calling set(int Test.TestDerived.derived)
     at:  Test.java:16
before calling set(int Test.TestDerived.derived)
     at:  Test.java:20
after calling: execution(Test.TestDerived())
      at: Test.java:18
after calling: initialization(Test.TestDerived())
      at: Test.java:18
after calling: call(Test.TestDerived())
      at: Test.java:39
before calling call(void Test.TestDerived.testMethod())
     at:  Test.java:40
before calling execution(void Test.TestDerived.testMethod())
     at:  Test.java:23
before calling handler(catch(Exception))
     at:  Test.java:27
before calling set(int Test.TestBase.base)
     at:  Test.java:41
before calling get(PrintStream java.lang.System.out)
     at:  Test.java:42
before calling call(void java.io.PrintStream.println(String))
     at:  Test.java:42
Test end...
```

引申为一句话就是，Pointcuts的目的是提供一种方法使得开发者能够选择自己感兴趣的JoinPoints。下面就从简入繁的理解Pointcuts。

经过修改后（我们换一种过滤的策略）的代码是酱婶的：

```java
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.ConstructorSignature;

/**
 * Created by hefuduo on 2017/3/15.
 */
public aspect JPTest {
  //pointcut：关键词，表示这里定义的是一个pointcut。
  //testAll()pointcut的名字，在AspectJ中，定义Pointcut可以分为有名和匿名两种办法。建议使用有名字的方法。
  //切点名称后的冒号，是必须加上的，冒号后面是这个pointcut怎么选择JoinPoint的条件。本例子中的条件翻译为：选择那些调用println(任意个参数)的Joinpoint，TestAspect中的除外。
  
 /**
 * call : 一种选择条件，为call函数调用类型
 * (public * *.println(..)) =  ([modifier] [return pattern] [function named println in package] ([param pattern])
 *call后面可以用与或非组合条件。
 *within是另外一种类型选择方法，特别注意的是，这种类型和前面讲到的joinpoint的哪几种类型不同。within的类型是数据类型，而joinpoint的类型更像是动态的，运行时的类型。？？？？
 */  
    pointcut testAll():call(public * *.println(..)) && !within(JPTest);
    before():testAll(){
        System.out.println("before calling " + thisJoinPoint);
        System.out.println("     at:  " + thisJoinPoint.getSourceLocation());
    }

    after():testAll(){
        Signature sig = thisJoinPoint.getSignature();
        if(sig instanceof ConstructorSignature){
            System.out.println("after calling: " + thisJoinPoint);
            System.out.println("      at: " + thisJoinPoint.getSourceLocation());
        }
    }
}

```

经过修改后的执行结果是酱婶的：

```java
before calling call(void java.io.PrintStream.println(String))
     at:  Test.java:38
Test begin ...
before calling call(void java.io.PrintStream.println(String))
     at:  Test.java:42
Test end...
```

那么经过上面的例子，总结一下，扩展一下哎，就有了下面的表：

~直接对JoinPoint的选择

| Join point category         | Pointcut syntax                         |
| --------------------------- | --------------------------------------- |
| method execution            | execution(MethodSignature)              |
| method call                 | call(MethodSignature)                   |
| constructor execution       | execution(ConstructorSignature)         |
| constructor call            | call(ConstructorSignature)              |
| class initialization        | staticinitialization(TypeSignature)     |
| Field read access           | get(FiledSignature)                     |
| Field write access          | set(FieldSignature)                     |
| Exception handler execution | handler(TypeSignature)                  |
| object initialization       | initializaiton(ConstructorSignature)    |
| object pre-initialization   | preinitialization(ConstructorSignature) |
| Advice execution            | adviceexcution()                        |

~间接针对JPoint的选择

除了使用Signature信息匹配JPoint外，AspectJ还提供其他一些选择方法来选择JPoint，比如某个类中的所有JPoint，每一个函数执行流程中所包含的JPoint

以下列举出了一些常用的非JPoint选择方法：

| 关键词                            | 说明                                       | 实例                                       |
| ------------------------------ | ---------------------------------------- | ---------------------------------------- |
| within(TypePattern)            | TypePattern表示package或者类，可使用通配符           | 表示某个package或者勒种的所有JPoint例如上面的例子          |
| withincode(fucntion Signature) | 表示某个构造函数或者函数执行过程中涉及的JPoint               | withinCode(* TestDerived.testMethod(...))表示testMethod涉及的JPoint，withincode(*.Test.new(..))表示Test构造函数涉及的JPoint |
| cflow                          | cflow是call flow的意思，cflow的条件是pointcut     | cflow(call TestDerived.testMethod)表示调用TestDerived.testMethod函数时所包含的JPoint，包括testMethodc的call这个JPoint本身。 |
| cfowbelow                      |                                          | cflowbelow(call TestDerived.testMethod)：表示调用TestDerived.testMethod函数时所包含的JPoint，*不*包括testMethodc的call这个JPoint本身。 |
| this(Type)                     | JPoint的this对象是Type类型。判断Type是不是某种类型，即是否满足instanceofType的条件 | JPoint是代码段（不论是函数，异常处理，static block），从语法上说，它都属于一个类。如果这个类的类型是Type标示的类型，则和它相关的JPoint将全部被选中。图2示例的testMethod是TestDerived类。所以this(TestDerived)将会选中这个testMethod JPoint |
| target(Type)                   | JPoint的target对象是Type类型                   | 和this相对的是target。不过target一般用在call的情况。call一个函数，这个函数可能定义在其他类。比如testMethod是TestDerived类定义的。那么 arget(TestDerived)就会搜索到调用testMethod的地方。但是不包括testMethod的execution JPoint |
| args(TypeSignature)            | 用来对JPoint的参数进行条件搜索的                      | 比如args(int,..)，表示第一个参数是int，后面参数个数和类型不限的JPoint |

**注意：this()和target()匹配的时候不能使用通配符。**

**注意，不是所有的AOP实现都支持本节所说的查询条件。比如Spring就不支持withincode查询条件**



Advice和AspectJ

> 在AspectJ中，在pointcuts前后执行的代码，这段代码就叫做advice。
>
> 简单来说，advice就是一种hook。
>
> 那什么是hook呢，hook这个来源于windows，win32程序都是基于消息循环机制的，窗口接收鼠标键盘事件，而hook就是在窗口之前拦截住这些事件，做一些处理，就像是个钩子一样。勾住事件，执行自己的代码。

AspectJ中有好几个Hook，主要是根据JPoint执行时机的不同而不同。

下表中列举出了AspectJ所支持的Advice的类型。

| 关键词                      | 说明                                       | 作用                                       |
| ------------------------ | ---------------------------------------- | ---------------------------------------- |
| before()                 | before advice                            | 表示在JPoint执行之前，做一些事情                      |
| after()                  | after advice                             | 表示在JPoint执行之后，做一些事情                      |
| after():returning(返回值类型) | returning和throwing后面都可以指定具体的类型，如果不指定的话则匹配时候不限定类型 | 如果JPoint是一个函数调用的话，那么函数调用执行完有两种方式退出，一个是正常的return，另一种是抛出异常。 |
| after():throwing(异常类型)   |                                          | after()默认包括returning和throwing两种情况        |
| 返回值类型around()            | before和around是指JPoint执行前或执行后被处罚，而around就替代了元JPoint | around是替代了原JPoint，如果要执行原JPoint的话，需要调用proceed |

**注意，after和bifore没有返回值，但是around的目标是替代原JPoint，所以他一般会有返回值，而且返回值的类型需要匹配被选中的JPoint，举个栗子**

```java
public void testMethod(){
  byte[] test = null;
  test[1] = 0x33;
  return;
}
```

```java
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.ConstructorSignature;

/**
 * Created by hefuduo on 2017/3/15.
 */
public aspect JPTest {
    public static void main(String args[]){
        
    }

    pointcut methodExecutionTest():execution(* *.TestDerived.testMethod());
    
    Object around():methodExecutionTest(){
        System.out.println("Around:" + thisJoinPoint);
        System.out.println("  at " + thisJoinPoint.getSourceLocation());
//        proceed();
        return null;
    }    
    
}

```



1. 将源代码函数中的try-catch句块去掉，那么函数就一定会抛出异常。
2. Aspect代码中是我们配置的advice，除了before外，还有一个around。它的返回值是Object。虽然匹配的JPoint是testMethod，其定义的返回值是void，但是AspectJ考虑的很周到。在around里，可以设置返回值类型为Object来表示返回任意类型的返回值。Aspect在真正返回参数的时候，会自动进行转换。比如，一个返回int类型的函数，在around里可以返回一个Integer，AspectJ会自动转换int作为返回值。
3. 再看around中的proceed（）这句话。这代表调用真正的JPoint函数，即testMethod。由于这里我们屏蔽了proceed，所以testMethod真正的内容并未执行，故运行的时候空指针异常就不会抛出来。也就是说，我们完全截获了testMethod的运行，甚至可以任意修改它，让它知行杯的函数都没有问题。

> around可以替代before after。around不能与after同时存在。





参数传递和JPoint信息

（1）参数传递（待完善）

向advice传递参数比较简单，就是利用前面提到的this(),target(),args()等方法。另外，整个pointcuts和advice编写的语法也有一些区别。

- l pointcuts修改：像定义函数一样定义pointcuts，然后在this,target或args中绑定参数名（注意，不再是参数类型，而是参数名）。
- l advice修改：也像定义函数一样定义advice，然后在冒号后面的pointcuts中绑定参数名（注意是参数名）
- l 在advice的代码中使用参数名



（2）JoinPoint信息收集

- l thisJoinpoint对象：在advice代码中可直接使用。代表JPoint每次被触发时的一些动态信息，比如参数啊之类的、
- l thisJoinpointStatic对象：在advice代码中可直接使用，代表JPoint中那些不变的东西。比如这个JPoint的类型，JPoint所处的代码位置等。
- l thisEnclosingJoinPointStaticPart对象：在advice代码中可直接使用。也代表JPoint中不可变的部分，但是它包含的东西和JPoint的类型有关，比如对一个call类型JPoint而言，thisEnclosingJoinPointStaticPart代表包含调用这个JPoint的函数的信息。对一个handler类型的JPoint而言，它代表包含这个try/catch的函数的信息。



### 5.1  AspectJ编译

- l AspectJ比较强大，除了支持对source文件（即aj文件、或@AspectJ注解的Java文件，或普通java文件）直接进行编译外，
- l 还能对Java字节码（即对class文件）进行处理。有感兴趣的同学可以对aspectj-test小例子的class文件进行反编译，你会发现AspectJ无非是在被选中的JPoint的地方加一些hook函数。当然Before就是在调用JPoint之前加，After就是在JPoint返回之前加。
- l 更高级的做法是当class文件被加载到虚拟机后，由虚拟机根据AOP的规则进行hook。



# AOP在Android中的应用





引用文章：

[面向切面编程（AOP）的理解](http://blog.csdn.net/Intlgj/article/details/5671248)

[Aspect Oriented Programming in Android -Fernando Cejas](https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/)

[深入理解Android之AOP](http://blog.csdn.net/innost/article/details/49387395)

[Android中的AOP编程](http://www.jianshu.com/p/0fa8073fd144)

参考文献

[1]  Manning.AspectJ.in.Action第二版

看书还是要挑简单易懂的，AOP概念并不复杂，而AspectJ也有很多书，但是真正写得通俗易懂的就是这本，虽然它本意是介绍Spring中的AOP，但对AspectJ的解释真得是非常到位，而且还有对@AspectJ注解的介绍。本文除第一个图外，其他参考用图全是来自于此书。

[2]  http://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/

Android中如何使用AspectJ，最重要的是它教会我们怎么使用aspectj编译工具API。