---
layout:     post
title:      "面向切面编程"
subtitle:   "AOP（Aspect Orient Program）"
date:       2017-02-27 11:09:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
    - 编程思想
    - 软件工程
---

[TOC]

# 深入理解面向切面编程

> 面向切面编程：在运行时，动态地将代码切入到类的制定方法、  指定位置上的编程思想就是面向切面编程。一般而言：切入到制定类制定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了这种思想，我们可以吧几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。

## 面向切面编程所要解决的问题以及在Spring中的具体应用

> 面向切面编程（AOP）是对面向对象编程（OOP）的一种补充与完善，而这种技术或者是思想在Spring IoC（我也不懂是什么👻）中非常重要，Spring的一个关键的组件就是AOP框架。下面一个就是Spring中使用AOP技术的所解决问题的实例。



​        在传统的编写业务逻辑处理代码时，我们通常会习惯性地做几件事情：日志记录、事务控制及权限控制等，然后才是编写核心的业务逻辑处理代码。当代码编写完成回头再看时，不禁发现，扬扬洒洒上百行代码中，真正用于核心业务逻辑处理才那么几行，如下图所示。方法复方法，类复类，就这样子带着无可奈何遗憾地度过了多少个春秋。这倒也罢，倘若到了项目的尾声，突然决定在权限控制上需要进行大的变动时，成千上万个方法又得一一"登门拜访"，痛苦"雪上加霜"。

![aspectJ1](/img/aspectJ/aspectJ1.jpg)

​       如果能把上图所示中众多方法中的所有共有代码全部抽取出来，放置到某个地方集中管理，然后在具体运行时，再由容器动态织入这些共有代码的话，最起码可以解决两个问题：

[**Java EE**](http://lib.csdn.net/base/javaee)程序员在编写具体的业务逻辑处理方法时，只需关心核心的业务逻辑处理，既提高了工作效率，又使代码变更简洁优雅。

在日后的维护中由于业务逻辑代码与共有代码分开存放，而且共有代码是集中存放的，因此使维护工作变得简单轻松。

面向切面编程AOP技术就是为解决这个问题而诞生的，切面就是横切面，如图6-5所示，代表的是一个普遍存在的共有功能，例如，日志切面、权限切面及事务切面等。

![140615289](/img/aspectJ/140615289.jpg)



​       下面我们以用户管理业务逻辑组件UserService的AOP实现过程（见图6-6）为例，深度剖析一下AOP技术的实现原理。AOP技术是建立在Java语言的[反射机制](http://www.cnblogs.com/lzq198754/p/5780331.html)与[动态代理](http://www.2cto.com/kf/201609/546253.html)机制之上的。业务逻辑组件在运行过程中，AOP容器会动态创建一个代理对象供使用者调用，该代理对象已经按Java EE程序员的意图将切面成功切入到目标方法的连接点上，从而使切面的功能与业务逻辑的功能同时得以执行。从原理上讲，调用者直接调用的其实是AOP容器动态生成的代理对象，再由代理对象调用目标对象完成原始的业务逻辑处理，而代理对象则已经将切面与业务逻辑方法进行了合成。

![140642106](/img/aspectJ/140642106.jpg)

切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。

通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。

连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但[**spring**](http://lib.csdn.net/base/javaee)只支持方法级的连接点。

切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。

目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。

代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。

织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。

## 面向切面编程在Android中的应用

### 专业术语

Terminology：

Before we get started, let's have a look at some vocabulary that we should keep in mind:

- **Cross-cutting concerns:** Even though most classes in an OO model will perform a single, specific function, they often share common, secondary requirements with other classes. For example, we may want to add logging to classes within the data-access layer and also to classes in the UI layer whenever a thread enters or exits a method. Even though each class has a very different primary functionality, the code needed to perform the secondary functionality is often identical.
- **Advice:** The code that is injected to a class file. Typically we talk about before, after, and around advices, which are executed before, after, or instead of a target method. It’s possible to make also other changes than injecting code into methods, e.g. adding fields or interfaces to a class. 
- **Joint point:** A particular point in a program that might be the target of code injection, e.g. a method call or method entry.
- **Pointcut:** An expression which tells a code injection tool where to inject a particular piece of code, i.e. to which joint points to apply a particular advice. It could select only a single such point – e.g. execution of a single method – or many similar points – e.g. executions of all methods marked with a custom annotation such as @DebugTrace.
- **Aspect:** The combination of the pointcut and the advice is termed an aspect. For instance, we add a logging aspect to our application by defining a pointcut and giving the correct advice.
- **Weaving: **The process of injecting code – advices – into the target places – joint points.

This picture summarizes a bit a few of these concepts:

![AspectOrientedProgramming](/img/aspectJ/AspectOrientedProgramming.png)

### 在Android中，在哪些场景下可以使用AOP？

1. 日志
2. 持久化
3. 性能监控
4. 数据认证
5. 缓存
6. 比方说埋点

那么，这些代码可以在不同的时期注入：

1. runtime：运行时注入。例如动态代理。
2. load-time：类装载时注入。这些修改可以在目标classes正在被Dalvik或者ART载入时，修改。ByteCode或DexCode weaving。
3. build-time：编译时注入。在编译过程中加入其它步骤，在打包或者发布应用前，来修改最终编译出的结果。SourceCode weaving。



### 工具和库

1. **AspectJ** ：一个可以和Java平台无缝连接的AOP扩展库，兼容Android，AspectJ有着自己的语法。（运行在JVM上的兼容Java的语言）。
2. **Javassit for Android**：二进制代码操作库。
3. **DexMaker**：一个Java运行时或编译时产生Dalvik虚拟机目标代码的工具。
4. **ASMDEX**：二进制代码操作库。



### 为什么使用AspectJ

* 非常强大
* 支持编译时和类加载时代码注入
* 使用简单



### 实例

假如我们想测量一个方法的性能（执行时间）。为了实现这个，我们标记函数使用**@DebugTrace**这个注解，并且希望使用logcat获得结果，并且不用在每个注解的方法中写代码。**使用AspectJ来实现这个目标**

![AspectWeaving](/img/aspectJ/AspectWeaving.png)

<p color="green">Project Structure</p>



**创建注解**

```java
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
public @interface DebugTrace{
  
}
```

**创建StopWatch类来监控性能**

```java
//StopWatch.class
public class StopWatch {
  private long startTime;
  private long endTime;
  private long elapsedTime;

  public StopWatch() {
    //empty
  }

  private void reset() {
    startTime = 0;
    endTime = 0;
    elapsedTime = 0;
  }

  public void start() {
    reset();
    startTime = System.nanoTime();
  }

  public void stop() {
    if (startTime != 0) {
      endTime = System.nanoTime();
      elapsedTime = endTime - startTime;
    } else {
      reset();
    }
  }

  public long getTotalTimeMillis() {
    return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;
  }
}
```

**DebugLog Class**

```java
/**
 * Wrapper around {@link android.util.Log}
 */
public class DebugLog {

  private DebugLog() {}

  /**
   * Send a debug log message
   *
   * @param tag Source of a log message.
   * @param message The message you would like logged.
   */
  public static void log(String tag, String message) {
    Log.d(tag, message);
  }
}
```

**Our Aspect**

> managing the annotation processing and source-code weaving.

**TraceAspect.java**

```java
/**
 * Aspect representing the cross cutting-concern: Method and Constructor Tracing.
 */
@Aspect
public class TraceAspect {

  private static final String POINTCUT_METHOD =
      "execution(@org.android10.gintonic.annotation.DebugTrace * *(..))";

  private static final String POINTCUT_CONSTRUCTOR =
      "execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))";

  @Pointcut(POINTCUT_METHOD)
  public void methodAnnotatedWithDebugTrace() {}

  @Pointcut(POINTCUT_CONSTRUCTOR)
  public void constructorAnnotatedDebugTrace() {}

  @Around("methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()")
  public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {
    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
    String className = methodSignature.getDeclaringType().getSimpleName();
    String methodName = methodSignature.getName();

    final StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    Object result = joinPoint.proceed();
    stopWatch.stop();

    DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));

    return result;
  }

  /**
   * Create a log message.
   *
   * @param methodName A string with the method name.
   * @param methodDuration Duration of the method in milliseconds.
   * @return A string representing message.
   */
  private static String buildLogMessage(String methodName, long methodDuration) {
    StringBuilder message = new StringBuilder();
    message.append("Gintonic --> ");
    message.append(methodName);
    message.append(" --> ");
    message.append("[");
    message.append(methodDuration);
    message.append("ms");
    message.append("]");

    return message.toString();
  }
}
```

 **在Android项目中使用AspectJ**

需要配置一下Gradle，使得使用AspectJ compiler来编译所有被AspectJ所影响的classes。

**build.gradle** 

```groovy
import com.android.build.gradle.LibraryPlugin
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:0.12.+'
    classpath 'org.aspectj:aspectjtools:1.8.1'
  }
}

apply plugin: 'android-library'

repositories {
  mavenCentral()
}

dependencies {
  compile 'org.aspectj:aspectjrt:1.8.1'
}

android {
  compileSdkVersion 19
  buildToolsVersion '19.1.0'

  lintOptions {
    abortOnError false
  }
}

android.libraryVariants.all { variant ->
  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)
  JavaCompile javaCompile = variant.javaCompile
  javaCompile.doLast {
    String[] args = ["-showWeaveInfo",
                     "-1.5",
                     "-inpath", javaCompile.destinationDir.toString(),
                     "-aspectpath", javaCompile.classpath.asPath,
                     "-d", javaCompile.destinationDir.toString(),
                     "-classpath", javaCompile.classpath.asPath,
                     "-bootclasspath", plugin.project.android.bootClasspath.join(
        File.pathSeparator)]

    MessageHandler handler = new MessageHandler(true);
    new Main().run(args, handler)

    def log = project.logger
    for (IMessage message : handler.getMessages(null, true)) {
      switch (message.getKind()) {
        case IMessage.ABORT:
        case IMessage.ERROR:
        case IMessage.FAIL:
          log.error message.message, message.thrown
          break;
        case IMessage.WARNING:
        case IMessage.INFO:
          log.info message.message, message.thrown
          break;
        case IMessage.DEBUG:
          log.debug message.message, message.thrown
          break;
      }
    }
  }
}
```

**测试方法**

```java
@DebugTrace
  private void testAnnotatedMethod() {
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }


//outputs:
//will like this:
//Gintonic --> testAnnotatedMethod --> [10ms]
```





#  AspectJ介绍

> AspectJ是一种语言，但是其也运行在JVM之上，简而言之就是JVM类语言的一种，类似Scala之类的。AspectJ也支持原生Java，只要是用AspectJ提供的注解就好了。
>
> 但是不管用什么方法，最终倒要用ajc来编译。

1.Joint Points

Joint Points（*JPoints* for short）是AspectJ中很重要的一个概念。就是程序运行时的一些执行点。（我的理解就是类似于调试时的断点。）

- 一个函数的调用可以是一个JPoint
- 设置或则读取一个变量也是一个JPoint
- for循环也可以看做是JPoint

理论上，一个程序中很多地方都可以被看做是一个JPoint，但是AspectJ中明确规定了只有下表中的这些执行点认为是JPoints

| Joint Points          | 说明               | 实例               |
| :-------------------- | :--------------- | :--------------- |
| method call           | 函数调用             | Log.e()          |
| method execution      | 函数执行             | 比如Log.e()执行内部    |
| constructor call      | 构造函数调用           | 函数调用类似           |
| constructor execution | 和函数执行类似          | 函数执行类似           |
| field get             | 获取某个变量           |                  |
| field set             | 设置某个变量           |                  |
| pre-initialization    | Object在构造函数中做的工作 |                  |
| static initializaiton | 类初始化             | 静态初始化代码块         |
| handler               | 异常处理             | trycatch中的catch块 |
| advice execution      | AspectJ内容        |                  |
|                       |                  |                  |

2.Pointcuts

一个程序会有很多JPoints，即使是同一个函数也会分call类型和execution类型。显然，并不是所有的JPoint，也不是所有类型的JPoint是我们所关注的，举例Activity的几个生命周期函数中打印日志，只有这几个生命周期函数才是我们业务需要的JPoint，而其他的什么JPoint我不需要关注，怎么从一堆一堆的JPoints中选择自己想要的JPoints呢？Pointcuts就是用来过滤JPoints的。以下举例说明。

```
	
```

未完待续...



引用文章：

[面向切面编程（AOP）的理解](http://blog.csdn.net/Intlgj/article/details/5671248)

[Aspect Oriented Programming in Android -Fernando Cejas](https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/)

[深入理解Android之AOP](http://blog.csdn.net/innost/article/details/49387395)

