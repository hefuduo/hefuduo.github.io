---
layout:     post
title:      "java学习笔记10"
subtitle:   "内部类"
date:       2016-12-21 10:21:20
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---

[TOC]

# 第十章 内部类

> 可以将一个类的定义放在另一个类的定义内部，这就是内部类
>
> ------Java编程思想

内部类是一种非常有用的特性，因为他允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。

## 创建内部类

创建内部类的方式：

```java
public class Parcell{
  class Contents{
    private int i = 11;
    public int value(){
      return i;
    }
  }
  class Destinattion{
    private String label;
    Destination(String whereTo){
      label = whereTo;
    }
    String readLabel(){
      return label;
    }
  }
  //using inner classes looks just like using any other class within parcell;
  
  public void ship(String dest){
    Contents c = new Contents();
    Destination d = new Destination(dest);
    System.out.println(d.readLabel());
  }
  public static void main(String args[]){
    Parcell p = new Parcell();
    p.ship("Tasmania");
  }
}

//output:
//Tasmania
```

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须制定对象的类型为：

OutterClass.InnerClass；

---

## 链接到外部类

> 内部类拥有其外部类的所有元素的访问权限

```java
//:innerClass access outterclass members.

interface Selector{
  boolean end();
  Object current();
  void next();
}

public class Sequence{
  private Object[] items;
  private int next = 0;
  public Sequence(int size){
    items = new Object[size];
  }
  public void add(Object x){
    if(next < items.length){
      items[next++] = x;
    }
  }
  
  private calss SequenceSelector implements Selector{
    private int i = 0;
    public boolean end(){
      return i == items.length;
    }
    public Object current(){
      return items[i];
    }
    public void next(){
      if(i < items.length){i++;}
    }
  }
 public Selector selector(){
   return new SequenceSelector();
 }
 public static void main(String[] args){
  Sequence s = new Sequence(10);
  for(int i = 0; i < 10; i++){
    s.add(Integer.toString(i));
  }   
  Selector sele = s.selector();
  while(!sele.end()){
    System.out.println(selector.current + "");
    selector.next();
  }
 }
}

//OutPut is print the elements of the sequence.
```

上述代码看着是不是很熟悉，是的。Java中的List的一些实现就是类似的。List和Iterator的组合，另外，C++种的STL容器的一些实现也是类似的。

---

## 使用.this 和.new 

如果需要生成对外部类对象的引用，可以使用外部类的名字+.this这种方式，这样产生的引用自动的具有正确的类型，这一点在编译器就被知晓并受到检查，因此没有任何运行时开销。

```java
public class DotThis{
  void f(){
    System.out.println("DotThis.f()");
  }
  public class Inner{
    return DotThis.this;
    //a plain "this" would be Inner's "this".
    //please pay an attention to this.
  }
  
  public Inner inner(){
    return new Inner();
  }
  
  public static void main(String[] args){
    DotThis dt = new DotThis();
    DotThis.Inner dti = dt.inner();
    dti.outer().f();
  }
}

//output DotThis.f();
```

​        有时候可能告知其某些其他对象，去创建某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，需要使用.new语法。Like this!

```java
public class DotNew{
  public class Inner{}
  public static void main(String[] args){
    DotNew dn = new DotNew();
    DotNew.Inner dni = dn.new Inner();
  }
}
```

在没有外部类对象之前，是无法创建内部类对象的，这是因为内部类对象会暗暗的连接到创建他的外部类对象上，但是，如果你创建的是 *嵌套类* （静态内部类），那么他就不需要对外部类对象的引用。

```java
public class Outter{
  public static class Inner{
    
  }
  
  public static void main(String[] args){
    //compare with the DotNew.Inner dni = dn.new Inner();
    Outter.Inner i = new Outter.Inner();
  }
}
```

1. 静态内部类是静态嵌套的，是隐藏在外部类的“外部类”。

2. 非静态内部类是外部类的成员，如果没有外部类的引用，无法加载。

---

## 内部类与向上转型

   > 当内部类向上转型为其基类型，尤其是转化一个接口的时候，内部类就有了用武之地。

​       这是因为次内部类------某个接口的实现------能够完全不可见，并且不可用。所得到的的知识之下只指向基类或接口的引用，所以能够很方便的隐藏实现的细节。

