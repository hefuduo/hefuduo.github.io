---
layout:     post
title:      "java学习笔记5"
subtitle:   "java学习笔记5"
date:       2016-12-7 10:20:20
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
--


[toc]

# 第五章 初始化与清理

## 用构造器确保初始化

** 构造器的名称必须与类名完全相同。**
** 不接受任何参数的构造器叫做默认构造器，或者称为无参构造器。如果没有声明无参数构造器，编译器会在编译阶段加入一个默认的构造器**


## 方法重载与重写
(overload / override)


*重载 : 函数名称相同，参数类型or参数数量不同，不包括返回值*

*重写 : 覆盖从父类型继承的方法，将方法的实现细节重新实现。*


## this关键字

this是对该类型实例的引用，例如可能为一个类谢了很多构造器，有事可能想在一个构造器调用另一个构造器，以避免重复代码，this关键字可以做到。


static的含义：
在了解this以后，就可一全面的了解static静态方法的含义。static 方法就是没有this的方法，再static方法内部不能调用非晶态方法，也不能使用非静态变量，反过来可以。Java中禁止使用全局方法，但是可以在类中置入static方法，可以访问static方法和static域。


## 清理:终结处理和垃圾回收

Java允许再类中定义一个名为finalize()的方法，它的工作原理“假定“是这样的：一单垃圾回收齐准备号是房对象占用的存储空间，将首先调用其finalize()方法，并且能在下一次垃圾回收动作发生时，才会真正回收对象占用的内存，所以如果大蒜用finallize()，就能再垃圾回收时刻做一些重要的清理工作。

>编程陷阱：
>finalize与c++中的西沟函数是不同的。C++中对象一定会被销毁；而Java里的对象却并非总是北垃圾回收。
>* 对象可能不被垃圾回收
>* 垃圾回收并不等于 ”析构“


<b>finalize()用途何在？</b>
这里引出问题的第三点
>* 垃圾回收只与内存有关。

看来之所以要有finalize()是由于在分配内存时，可能采取了类似C语言的做法，而非Java鱼眼的方式。例如本地方法。
在本地方法中，C/C\+\+会调用malloc函数系列来分配内存空间 or new，而且除非手动调用free函数，否则存储空间不会得到释放，从而造成内存泄露，free是c和c\+\+中的函数，因此需要再finalize中用本地方法调用他。

由此可见，finalize并不是进行普通清理工作的适合场所。

++ 记住，无论是 ”垃圾回收“还是 ”终结“，都不能保证一定会发生，如果JVM并没有面临内存耗尽的情况，是不会执行垃圾回收以释放内存的，因为频繁的垃圾回收也是会消耗资源降低性能的。 ++


*终结条件* :

### 垃圾回收器是如何工作的？
详见 [Java垃圾回收机制](http://www.baidu.com)

## 初始化

### 成员初始化
尽量在生命变量的时候，即去初始化变量，防止出现”未初始化“状态，引发程序错误。


### 构造器初始化

在构造器中，初始化成员变量。

#### 初始化顺序

&nbsp &nbsp 在类的内部，定义变量的先后顺序决定了初始化的顺序。

静态数据的初始化只在Class对象首次加载的时候进行一次。



- - -
总结一下对象的创建过程。 Dog类

1. 即使没有显示地使用static关键字，构造器实际上也是静态方法，因此当首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
2. 然后载入Dog.class(此时会一个Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行。
3. 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的内存空间。
4. 这块内存空间会被清零，自动的将Dog对象中的所有基本类型数据都设置成了默认值，数字为0，引用设置null；
5. 执行所有出现与字段定义处的初始化动作。
6. 执行构造器。
- - -

显示的静态初始化

Java允许将多个静态初始化动作组支撑一个特殊的”静态子句“（夜叫做”静态块“）。

```java
 public class Spoon{
     static int i;
     static{
        i = 47;
     }
 }
 
 public class JNITest{
     static{
         System.loadLibrary("library_name");
     }
 }
```

static句块与其他静态初始化动作一样，这段代码仅执行一次；
>当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便是从未生成过那个类的对象）。



非静态实例初始化：
 Java中也有被称为实例初始化的类似的语法，用来初始化每一个对象的非静态变量。

```java
Class Cup{
    Cup(int maker){
        print("Cup(" + maker + ")");
    }
    void f(int maker){
        print("f(" + maker + ")");
    }
}

public class Cups{
  static Cup cup1;
  static Cup cup2;
  //静态初始化代码块
  static{
      cup1 = new Cup(1);
      cup2 = new Cup(2);
      print("cup1 & cup2 initialized");
  }

  Cups(){
    print("Cups()");
  }

  Cups(int i){
      print("Cups(int)");
  }

}

public c;ass ExplicitStatic{

  public static void main(String[] args){
      print("Inside main()");
      Cups.cup1.f(99);// (1)
  }
  //static Cups cups1 = new Cups(); //(2)
  //static Cups cups2 = new Cups();//(2)
}
/**outPut:
 * Inside main()
 * Cup(1)
 * Cup(2)
 * cup1 & cup2 initialized
 * f(99)
 * //被注释的代码结果
 * Cup(1)
 * Cup(2)
 * cup1 & cup2 initialized
 * Cups()
 * //cup1 cup2只会被初始化一次
 * Cups()
 */
```

- - -


```java
Class Mug{
    Mug(int maker){
        print("Mug(" + maker + ")");
    }
    void f(int maker){
        print("f(" + maker + ")");
    }
}

public class Mugs{
  Mug mug1;
  Mug mug2;
  //非静态实例初始化
  {
      mug1 = new Mug(1);
      mug2 = new Mug(2);
      print("mug1 & mug2 initialized");
  }

  Mugs(){
    print("Mugs()");
  }

  Mugs(int i){
      print("Mugs(int)");
  }
  public static void main(String[] args){
      print("Inside main()")
      new Mugs();
      print("new Mugs() completed");
      new Mugs(1);
      print("new Mugs(1) completed");
  }
}

/**outPut:
 * Inside main()
 * Mug(1)
 * Mug(2)
 * mug1 & mug2 initialized
 * Mugs();
 * new Mugs() completed
 * Mug(1)
 * Mug(2)
 * mug1 & mug2 initialized
 * Mugs(int)
 * new Mugs(1) completed
 */
```
>你可以看见它与静态初始化语句一模一样，只不过少了static关键字。这种语法对于支持”匿名内部类“的初始化是必须的，但是它也使得你可以保证无论掉哦你给那个显示构造器，这些操作都会发生。从输出可以看出，实例初始化子句是在两个构造器之前执行的。



### 数组初始化
数组只是相同类型、用同一个标识符名称封装到一起的一个对象序列或基本类型数据序列。
数组是通过方括号下表操作符[]来定以和使用的。

`int[] a1;`
方括号也可以置于标识符后米娜：
`int a1[];`

两种格式的含义是一样的，后一中格式符合C和C\+\+程序员的习惯。

编译器是不允许制定数组的大小。因为现在只是对数组的一个引用，已经为该引用分配了内存空间，但是没有给数组对象本身分配任何空间，必须初始化表达式。

`int[] a1 = {1,2,3,4,5};`
在Java中可以将一个数组赋值给另一个数组，可以这样。
`a2 = a1`
但是这其实只是复制了一个引用。
所有数组都有一个固定的成员：`length`

也可以使用new来初始化数组大小，数组元素值为默认。

`int[] a = new int[10];`
也可以用花括号扩起来的列表来初始化对象数组

```java
 Integer[] a = new Integer[]{
     new Integer(1),
     new Integer(2),
     new Integer(3),
     //...
     new Integer(100)
 }
```

可变参数列表
可应用于参数个数或类型未知的场合

```java
//Using arrya syntax to create variable argument lists

public class NewVarArgs{
    static void printArray(Object... args){
        for(Object obj : args){
            System.out.println(obj + "");
        } 
    }
    public static void main(String[] args){
        printArray(enw Integer(47),new Float(3.14),new Double(11.11));
        printArray(47,1.14F,11.11);
        printArray("one","two","three");
        printArray(new A(),new A());
        //or and array
        printArray((Object[])new Integer[]{1,2,3,4});
        //or empty
        printArray();
    }
}
```
有了可变参数，就再也不用显示地编写数组语法，当制定参数时，编译器会为你填充数组。你获取的仍旧是一个数组。

## 枚举类型

`enum 关键字`

```java
public enum Spiciness{
  NOT, MILD, MEDIUM, HOT, FLAMING
}
```
这里创建了一个名为`Spiciness`的枚举类型，它具有5个具名值。由于枚举类型的实例是常量，因此按照命名管理他们都用大写字母表示。
为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。

```java
public class SimpleEnumUse{
    public static void main(String[] args){
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}
/** out put
 * MEDIUM
 */
```

在你创建enum时，编译器会自动添加一些有用的特性。toString()方法，编译器还会出创建ordinal()方法，用来表示某个特定enum常亮的生命顺序，以及static values()方法，用来按照enum常亮的生命顺序，产生有这些常量值构成的数组。

```java
public class EnumOder{
    public static void main(String[] args){
        for(Spiciness s : Spiciness.values()){
            println(s + ",ordinal" + s.ordinal);
        }
    }
}

//out put
//NOT , ordinal 0
//...
//FLAMING , ordinal 4
```

尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应的类时，产生了某些编译器行为，因此在很大程度上，你可以将enum 当做其他任何类来处理，事实上，enum确实是类，并且具有自己的方法。

enum 有一个特别使用的特性，即它可以再switch语句内使用。



