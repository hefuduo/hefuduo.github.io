---
layout:     post
title:      "防御性编程"
subtitle:   "Java编程技巧"
date:       2017-02-14 17:09:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
    - 编程技巧
---



# 防御性编程

在讲防御性编程之前，我先讲一个故事。

爱德华墨菲是美国爱德华兹空军基地的上尉工程师。

1949年，他和上司斯塔普少校参加美国空军心境的MX981火箭减速超重实验。这个实验的目的是为了测定人类对加速度的承受极限。其中有一个实验项目是将16个火箭加速计悬空安装在受试者上方，当时有丽娜各种方法可以讲加速度计固定在支架上，而不可思议的是，竟然有人有条不紊地讲16个加速度计全部装在错误的位置上。

于是墨菲做出了这一著名的论断，如果某项工作有多种方法，而其中有一种方法将导致事故，那么一定有人会按照这种方法去做。

这就是著名的“墨菲定律”。

“墨菲定律”主要内容有四个方面

1. 任何事都没有表面看起来那么简单
2. 所有的事都会比你预计的时间长
3. 会出错的事总会出错
4. 如果你担心某种情况发生，那么它就更可能发生



好了，上面的故事告诉我们一个道理，凡是可能出错的事有很大几率会出错。在编程中，你也许听过这样一句话，没有任何系统是安全的，它总会有漏洞；没有任何软件是没有问题的，它总会存在一些Bug。

打个比方，我们要解析一段json，约定这个json的格式，只能是正常格式，或者是空，那么一旦返回json的方法返回了一个『既不是正常格式，又不是空的异常值』，程序该如何处理呢？

小花：一旦碰到约定异常，程序必须兼容处理，一定不能让程序Crash

小Fa：一旦碰到约定异常，就必须抛出去，告知约定有误，找出具体错误原因

这个问题，相信只要是程序猿基本都遇到过，举个最常见的栗子，NullPointerException，假如我们要从json中取一个字段，突然发现发生了NullPointerException，一些开发者认为是数据问题，那么把json中的这个字段改正确就行了；还有一些开发者认为是程序问题，认为程序需要做非空判断，再去使用。我相信这两种程序猿都有自己的理由，第一种程序简洁明了，代码逻辑干净，但一旦出错，就会崩溃，第二种程序耐操，随你数据怎么错，我都能不Crash，但代码中到处存在非空判断，臃肿、重复。

因此，我们需要一个防御式的编程。就是不要信任任何人，对于程序任何可能错误的输入，都要做出兼容。

那什么是防御性编程呢？



防御性编程是一种细致、谨慎的编程方法。为了开发可靠的软件，我们要设计系统中的每个组件，以使其尽可能的“保护”自己。我们通过明确地在代码中对设想进行检查，击碎了未记录下来的设想。这是一种努力，防止我们的代码以将会展现错误行为的方式被调用。

防御性编程并不能排除所有的程序错误。但是相应的问题所带来的麻烦将会减少，并且易于修改。
<p color="red">防御性程序员只是抓住飘落的雪花，而不是被埋葬在错误的雪崩中。</p>



讲完了上面的概念性的东西，下面来点干货。Show me the code！

1.为了防止偶发性的NullPointException异常，我们通常将String放置在equals()函数的左边来实现比较：

```java
if(var.equals("literal")){
  //this is bad because var may be null
}

if("literal".equals(var)){
  //good code
}
```

2.不要永远相信别人提供的SDK，可能是大坑。看早起的Java api

```java
String[] files = file.list();
//watch out
if(files != null){
  for(int i = 0; i < files.length; i++){
    //....
  }
}
//如果这个虚拟路径不表示一个文件夹目录，则此方法返回null。否则将会返回一个
//字符串数据，字符串表示目录中的文件或文件夹。所以应该添加一些校验

if(files.isDirectory()){
  String[] files = file.list();
  
  //watch out
  if(files != null){
    for(int i = 0; i < files.length; i++){
      //.....
    }
  }
}
```

3.不要相信“-1”

javadoc中对String.indexOf()方法明确指出：对象内第一次出现制定字符的位置索引，如果为-1则表示该字符不在字符序列中。举个🌰

```java
if(string.indexOf(charactor) != -1){
  //bad 
}

if(string.indexOf(charactor) >= 0){
  //good
}
```

4.避免意外赋值

```java
if(var = 5){
  //....
}
//a better way

if(5 = var){
  //
}
if(5 === var){
  //Ooops
}
//所以你可以讲比较常量放在左侧，这样就不会发生意外的赋值错误了
```

5.检查Null和Length

只要有数组和集合等，请确保它存在，并且不为空。

```java
if(array.length > 0){
  //...bad
}
if(array != null && array.length > 0){
  //good
}
```

6.对于那些意义明确的方法要严格使用fina标识

```java
public void boom(){
  //bad
}

public final void dontTouch(){
  //good
}
```



7.所有变量和参数都是final

我不相信我自己（不要意外覆盖我的值）。

```java
//bad
void input(String importantMessage){
  String answer = "...";
  answer = importantMessage = "LoL accident";
}

//good
final void input(final String importantMessage){
  final String answer = "...";
}
```



8.重载时不要相信泛型

```java
//bad
void bad(T value){
  bad(Collections.singletonList(value));
}
void bad(List values){
  //....
}

void bad(List values){
  
}

//good 

final void good(final T value){
  if(value instance of List){
    good(List<?> value)
  }
  else{
    good(Collections.singletonList(value));
  }
}

final void good(final List values){
  
}

//this library sucks
@SuppressWarning("all")
Object t = (Object)(List)Arrays.asList("abc");
bad(t);
```





结束语：

防御性编程并不能完全防止程序中出现的bug问题，但是他会大大降低软件崩溃的几率，尽管可能要多些几行代码，但是对于大型软件来说，可靠性才是第一位的不是吗？一个软件的鲁棒性（谁翻译的鲁棒？音译好难听！）是至关重要的。并且，防御性编程的程序在后期的维护中也更加方便。

推荐，在写程序的时候，注意防御性编程。
