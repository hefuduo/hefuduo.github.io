---
layout:     post
title:      "Template"
subtitle:   "template"
date:       2016-12-21 19:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java	
---

[TOC]

# 第20章 注解

> 注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻非常方便地使用这些数据。

## 20.1 基本语法

### 20.1.1 定义注解

样例：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
}
```

注解的定义看起来很像接口的定义。事实上，与其他任何Java接口一样，注解也会编译成class文件

除了一个`@`符号以外，`@Test`的定义很像一个空的接口。定义注解时，会需要一些**元注解**。例如`@Target`用来定义你的注解将应用在什么地方比如，一个方法或者是一个域和`@Retention`用来定义该注解在哪一个级别可用，在源代码中`SOURCE`,类文件中`CLASS`或者是运行时`RUNTIME`。

在注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。注解的元素看起来就像接口方法，唯一的区别是你可以为其指定默认的值。

没有元素的注解称为**标记注解**，例如上诉例子中的`@Test`

下面一个例子是一个简单注解，用来跟踪项目中的用例。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UserCase {
    public int id();
    public String description() default "no description";
}
```

注意，id和description类似方法定义，由于编译器会对id进行类型检查，因此将用力文档的追踪数据库与源代码关联是可靠的。`description`有一个default值，如果在注解某个方法时，没有给出`description`的值，则该注解的处理器就会使用此元素的默认值。

```java
public class AnnoactionTest {
    
    @UseCase(id = 47,description = "password must contain at least one numeric")
    public boolean validatePassword(String password){
        return password.matches("\\w*\\d\\w*");
    }
    
    @UseCase(id = 48, description = "new password can't equal previousy used ones")
    public String encryptPassword(String password){
        return new StringBuilder(password).reverse().toString();
    }
    
    @UseCase(id = 49, description = "new password can't equal previousy used ones")
    public boolean checkForNewPassword(List<String> prevPassword,String password){
        return !prevPassword.contains(password);
    }
    
    public static void main(String[] args){
    }
}
```



注解的元素在使用时表现为名-值对的形式，并需要置于`@UseCase`声明之后的括号内。在`encryptPassword()`方法的注解中，并没有给出description元素的值，因此，在UseCase的注解处理器分析处理这个类时，会使用该元素的默认值。

### 20.1.2 元注解

Java目前只内置了三种标准注解，以及这四种元注解。元注解专门负责注解其他的注解：

- `@Target` 标识该注解可以用于什么地方，可能的ElementType参数包括：

  | CONSTRUCTOR    | 构造器          |
  | -------------- | ------------ |
  | FIELD          | 域声明包括enum实例  |
  | LOCAL_VARIABLE | 局部变量声明       |
  | METHOD         | 方法声明         |
  | PACKAGE        | 包声明          |
  | TYPE           | 类接口声明或enum声明 |
  |                |              |

- `@Retention` 表示需要在什么级别保存该注解信息，可选的RetentionPolicy参数包括：

  | SOURCE  | 注解将被编译器丢弃                       |
  | ------- | ------------------------------- |
  | CLASS   | 注解在class文件中可用，但是会被VM丢弃          |
  | RUNTIME | VM将在运行期也保留该注解，因此可以通过反射机制获取注解的信息 |

- `@Documented` 此注解将包含在JavaDoc中

- `@Inherited`  允许子类继承父类中的注解

大多数时候，程序员主要的工作是定义自己的注解，并且编写自己的处理器来处理它们。



## 20.2 编写注解处理器

如下，是编写注解解析器的工具类，用来检测是否有标注的类。

```java
public class UseCaseTracker {
    public static void trachUseCases(List<Integer> useCases, Class<?> cl){
        for (Method m : cl.getDeclaredMethods()){
            UseCase useCase = m.getAnnotation(UseCase.class);
            if (useCase!= null){
                System.out.println("Found use Case " + useCase.id()
                + " " + useCase.description());
                useCases.remove(new Integer(useCase.id()));
            }
        }
        
        for (int i : useCases){
            System.out.println("warning : missing use case " + i);
        }
        
        
    }
    
    public static void main(String[] args){
        List<Integer> usecases = new ArrayList<Integer>();
        Collections.addAll(usecases,47,48,49,50);
        trachUseCases(usecases,AnnoactionTest.class);
    }
}
```

### 20.2.1 注解元素

`@UseCase`由`UseCase.java`定义，其中包含int元素id，以及一个String元素description，注解元素可以用的类型如下所示：

- 所有基本类型（int，float，boolean等）
- String
- Class
- enum
- Annotation
- 以上类型的数组

### 20.2.2 默认值限制

编译器对元素的默认值有些过分的挑剔，首先元素不能有不缺性的默认值，也就是元素必须要么具有默认值，要么在使用注解时，提供元素的值。

其次，对于非基本类型的元素，无论是在源代码中声明时，或者是在注解接口中定义默认值时，都不能以null作为其值。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且都具有相应的值。为了绕开这个约束，只能自己定义一些特殊的值，例如空字符串或者是负数，以表示某个元素不存在。

```java
@Target(ElementTyoe.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SimulatingNull{
  public String name() default "";
}
```

在`@Target`注解中指定的每一个ElementType就是一个约束，它告诉编译器，这个自定义的注解只能应用于该类型，程序员可以指定enum ElementType中的一个值，或者是以逗号分隔的形式指定多个值。如果想要将注解应用于所有的ElementType，那么可以省去`@Target`元注解，不过这并不常见。

### 20.2.4 注解不支持继承

不能使用关键字`extends`来继承某个`@interface`。

### 20.2.5 实现处理器

例子：读取一个类文件，检查骑上的数据库注解，并生成用来创建数据库的SQL命令

```java
@Target(ElementType.TYPE) //applies to calsses only
@Retention(RetentionPolicy.Runtime)
public @interface DBTable{
  public String name() default "";
}
```

//TO



## 20.3 使用apt处理注解

**注解处理工具**

通过使用AnnotationProcessorFactory，apt能够为每一个它发现的注解生成一个正确的注解处理器。当你使用apt的时候，必须指明一个工厂类，或者指明能找到apt所需要的工厂类的路径。

使用apt生成注解处理器时，我们无法利用Java的反射机制，因为我们操作的是源代码，而不是编译后的类。使用mirror API就能够解决这个问题，它使我们能够在未经编译的源代码中查看方法，域以及类型。

下面是一个自定义的注解，使用它可以把一个类中的public方法提取出来，构造成一个新的接口：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface ExtractInterface{
  public String value();
}
```

