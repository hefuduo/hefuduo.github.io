---
layout:     post
title:      "java学习笔记9"
subtitle:   "接口"
date:       2016-12-20 15:21:20
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java
---



[TOC]

# 第九章 接 口

> 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法
>
> 



## 抽象类和抽象方法



Java提供一个叫做 *抽象方法* 的机制，这种方法是不完整的，仅有方法声明，但是并没有方法体，目的是为子类型建立一个通用的接口。

抽象方法：`abstract void f()`

包含抽象方法的类叫做抽象类（如果一个类包含一个或者多个抽象方法，那么必须将其声明为abstract）。

抽象类不能被实例化。

```java
public abstract class Instrument{
  public abstract void play();
}

public class StringInstrument extends Instrument{
  //this method must be overrided by the subclass
  @Override
  public void play(){
    //statement
  }
}

public class Guitar extends StringInstrument{
  @Override
  public void play(){
    //statement
  }
}

```

---



## 接口

interface的关键字使得抽象更进一步，在抽象类中，可以有非抽象的方法，在接口（interface）中，所有的方法都是抽象的，所以interface是一个*完全抽象的类* 。

一个接口表示：*所有实现了该特定接口的类看起来都是这样* 。因此，任何使用某种特定接口的代码都可以知道该接口有哪些方法（必须覆写这些方法，否则编译时报错）。接口建立的类与类之间的协议（面向接口编程）。

```java
/**
* 所有接口的方法都是public的，接口内部允许有变量，但是都是const常量（static final）
*/
public interface Instrument{
  void play();
  void adjust();
}

public class StringInstrument implements Instrument{
  @Override
  public void play(){
    //statement
  }
  @Override
  public void adjust(){
    //statement
  }
}
```

 ---

## 完全解耦



参考

[设计模式之策略模式](http://blog.chinaunix.net/uid-29140694-id-4102757.html)

[设计模式之适配器模式](http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html)

---



## Java中的多重继承

接口不仅仅是一种更纯粹形式的抽象类，因为Java没有多重继承这种属性（参考C++多重继承），接口本身没有任何的实现，也就是没有任何与*接口相关的存储* ；因此，允许多个接口的组合。从而实现了Java的*“多重继承”* 。C++的多重继承会很麻烦，如果类设计的不好，会造成歧义。

---

## 通过继承来扩展接口

通过继承，可以向原本的接口中添加新的方法声明，从而扩展接口。也可以通过继承多个接口，组合两个接口。

> 注意，组合接口时，很可能会遇到一个陷阱，就是名字的冲突问题。

```java
interface I1{
  void f();
}
interface I2{
  int f(int);
}
interface I3{
  int f(int)
}

class C implements I1, I2{
  public void f(){
    
  }
  public int f(int i){
    return 1;
  }
}


```

---

## 适配接口

> 接口最引人的原因是允许同一个接口具有多个不同的实现。

## 再谈接口中域

因为放入接口中的任何域都自动是static和final的，所以接口就成为了一种非常便捷的创建常量组的工具。（在Java SE5之前是没有enum的，因此可以用接口来创建美剧类型。）

```java
public interface Months{
  int JANUARY = 1, FEBRUARY = 2, MARCH = 3,
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
    AUGEST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11,DECEMBER = 12;
}
```

接口中的域是常量，因此在声明时候就要被初始化，这点要注意。

---

## 嵌套接口

接口可以嵌套在类或者其他接口中。

```java
package interfaces.nesting
class A{
	interface B{
      	void f();
	}
  
    public class BImp implements B{
        public void f(){}
    }

    private class BImp implements B{
        public void f(){}
    }


    public interface C{
        public void f(){}
    }
    class CImp implements C{
        public void f(){}
    }
    private class CImp2 implements C{
        public void f(){}
    }

    private interface D{
        void f();
    }
  	private class DImp implements D{
      	public void f(){}
    }
  	public class DImp implements D{
      	public void f(){}
  	}
  	
  	public D getD(){
      	return new DImp2()
  	}
  	
  	private D dRef;
  
  	public void receiveD(D d){
      	dRef = d;
      	dRef.f();
    }
}

interface E{
  interface G{
	void f();
  }
  
  // Redundant "public"
  public interface H{
    void f();
  }
  
  void g();
  //cannot be private with in an interface;
  // ! private interface I{}
}

// the class to test.
public class NestingInterfaces{
  public class BImp implements A.B{
    public void f(){}
  }
  public class CImp implements A.C{
    public void f(){}
  }
  // cannot implements a private interface except
  // within that interface's defining class;
  /**
  *class DImp implements A.D{
    //this is wrong.
  }
  */
  
  class EImp implements E{
    public void g(){}
  }
  class EGImp implements E.G{
    public void f(){}
  }
  class EImp implements E{
    public void g(){}
    
    class EG implements E.G{
      public void f(){};
    }
  }
  
  public static void main(String args[]){
    A a  = new A();
    //can't access A.D
    //!A.D ad = a.getD();
    //Doesn't return anything but A.D
    //！A.DImp2 di2 = a.getD();
    //Cannot access a member of the interface
    //! a.getD().f();
    //Only another A can do anything with getD();
    A a2 = new A();
    a2.receiverD(a.getD);
  }
}

```



综上，总结：

1. 在类中嵌套接口，可以拥有public和protected包访问权限两种可视性。

2. 类中的接口也可以声明为private，可以被内部类实现。但是只能用于本身。

3. 接口与接口可以嵌套，但是嵌套类型都是public的。

4. 当实现某个接口时，并不需要实现嵌套在其内部的任何接口。private接口不能定义它的类之外被实现。

   ​

---

## 接口与工厂

接口时实现多重继承的重要途径，而生成遵循某个接口的对象的典型方式就是工厂设计模式。

[Java设计模式之工厂模式](http://www.baidu.com/)

工厂的设计模式的好处就是代码将完全与实现分离，可以很好的将一个实现替换成另一个实现。

```java
interface Service{
  void method1();
  void method2();
}
interface ServiceFactory{
  Service getService();
}

class Implementaton1 implements Service{
  //statement to impl the Service
}
class Implementaton2 implements Service{
  //statement to impl the Service
}

class Implementtation1Factory1 implements ServiceFactory{
  public Service getService(){
    return new Implementation1();
  }
}

class Implementtation1Factory2 implements ServiceFactory{
  public Service getService(){
    return new Implementation2();
  }
}

public class Factories{
  public static void ServiceConsumer(ServiceFactory fact){
    Service s = fact.getService();
    s.method1();
    s.method2();
  }
}

//todo test
```

