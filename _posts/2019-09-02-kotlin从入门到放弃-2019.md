---
layout:     post
title:      "Kotlin学习笔记5"
subtitle:   "Functions And Lambdas"
date:       2019-09-02 19:19:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin
---

[TOC]

# Lambdas

## Higer-oder Functions and Lambdas

Kotlin functions are [*first-class*](https://en.wikipedia.org/wiki/First-class_function), which means that they can be stored in variables and data structures, passed as arguments to and returned from other [higher-order functions](https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions). You can operate with functions in any way that is possible for other non-function values.

To facilitate this, Kotlin, as a statically typed programming language, uses a family of [function types](https://kotlinlang.org/docs/reference/lambdas.html#function-types) to represent functions and provides a set of specialized language constructs, such as [lambda expressions](https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions).

### Higher-Order Functions

A high-order function is a function that takes functions as parameters, or returns a function

函数式编程

```kotlin
fun<T, R> Collection<T>.fold(
initial: R,
combine: (acc: R, nextElemen: T) -> R): R {
  var accumulator: R = initial
  for(element: T in this) {
    accumulator = combine(accumulator, element)
  }
  return accumulator
}
```

`combine` has a `function type`

call it 

```kotlin
val items = listOf(1,2,3,4,5)
items.fold(0, {
  //when a lambda has paramters, they go first, followed by '->'
acc: Int, i: Int -> 
	print("acc = $acc, i = $i")
  val result = acc + i
  println("result = $result")
  result // the last expression in a lambda is considered the return value: 
})

val joinedString = items.fold("Elements:", {acc, i -> acc + " " + i})

val product = items.fold(1, Int::times)
```

The following sections explain in more detail the concepts mentioned so far.



### Function Types

Kotlin uses a family of function types likle `(Int) -> String` for declarations that deal with functions: `val onClick: ()-> Unit = ...`

hese types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:

- All function types have a parenthesized parameter types list and a return type: `(A, B) -> C`denotes a type that represents functions taking two arguments of types `A` and `B` and returning a value of type `C`. The parameter types list may be empty, as in `() -> A`. The [`Unit` return type](https://kotlinlang.org/docs/reference/functions.html#unit-returning-functions)cannot be omitted.
- Function types can optionally have an additional *receiver* type, which is specified before a dot in the notation: the type `A.(B) -> C` represents functions that can be called on a receiver object of `A`with a parameter of `B` and return a value of `C`. [Function literals with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) are often used along with these types.
- [Suspending functions](https://kotlinlang.org/docs/reference/coroutines.html#suspending-functions) belong to function types of a special kind, which have a *suspend* modifier in the notation, such as `suspend () -> Unit` or `suspend A.(B) -> C`.

The function type notation can optionally include names for the function parameters: `(x: Int, y: Int) -> Point`. These names can be used for documenting the meaning of the parameters.

To specify that a function type is [nullable](https://kotlinlang.org/docs/reference/null-safety.html#nullable-types-and-non-null-types), use parentheses: `((Int, Int) -> Int)?`.

Function types can be combined using parentheses: `(Int) -> ((Int) -> Unit)`

The arrow notation is right-associative, `(Int) -> (Int) -> Unit` is equivalent to the previous example, but not to `((Int) -> (Int)) -> Unit`.

推荐使用这种方式给函数类型命名一个别名, 更方便确认.

You can also give a function type an alternative name by using [a type alias](https://kotlinlang.org/docs/reference/type-aliases.html):

```kotlin
typealias ClickHandler = (Button, ClickEvent) -> Unit
```



### 函数类型实例化

1. 使用函数字面值的代码块

   1. lambda表达式 `{a,b -> a +b }`

   2. 匿名函数: `fun(s: String): Int{return s.toIntOrNull() ?: 0}`

      带有接受者参数的函数字面值.

2. 使用已有声明的可调用引用:

   1. 顶部局部成员扩展函数: ::isOdd, String::toInt
   2. 顶层成员扩展属性 `List<Int>::size`
   3. 构造函数: `::Regex`
   4. 这包括指向特定实例成员的绑定的可调用引用: `foo::toString`

3. 使用实现函数类型接口的自定义类的实例:

   ```kotlin
   //这个类实现了函数类型的接口(默认有一个方法invoke操作符重载)
   class IntTransformer: (Int) -> Int {
     override operator fun invoke(x: Int): Int = TODO()
   }
   val intFunction: (Int)-> Int = InitTransformer(); //实例化
   ```

   ```kotlin
   //一个自己写的例子
   typealias AddInterface = (Int, Int) -> Int
   class AddImpl : AddInterface{
       override fun invoke(p1: Int, p2: Int): Int {
           return p1 + p2
       }
   }
   
   fun test () {
       val add = AddImpl()
       val result = add(10, 200)
   }
   ```

   编译器能够自行推断函数类型如果有足够多的信息

   ```kotlin
   val a ={ i: Int -> i + 1} //The inferred type is (Int) -> Int
   ```

   *Non-literal* values of function types with and without receiver are interchangeable, so that the receiver can stand in for the first parameter, and vice versa. For instance, a value of type `(A, B) -> C` can be passed or assigned where a `A.(B) -> C` is expected and the other way around:

   ```kotlin
   val repeatFun: String.(Int)  -> String = {times -> this.repeat(times)}
   val twoParamters: (String, Int) -> String = repeatFun //OK
   //接受者就是第一个参数
   fun runTransformation(f: (String, Int) -> String): String {
     return f("hello", 3)
   }
   val result = runTransformation(repeatFun)
   
   //类似的 (A,B) ->C 类型的值也可以直接赋值给A.(B)->C的地方,反之亦然
   ```

   


### Involking a function type instance

   A value of a function type can be invoked by using its [`invoke(...)` operator](https://kotlinlang.org/docs/reference/operator-overloading.html#invoke): `f.invoke(x)` or just `f(x)`.

   If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an [extension function](https://kotlinlang.org/docs/reference/extensions.html): `1.foo(2)`, 

如果有接受者 那么接受者对象必须被作为第一个参数, 另外一种方式是扩展函数类型

 例如

```kotlin
val stringPlus: (String, String) -> String = String::plus
val intPlus: Int.(Int) -> Int = Int::plus

println(stringPlus.invoke("<-", "->"))
println(stringPlus("Hello, ", "world!"))

println(intPlus.invoke(1, 1))
println(intPlus(1, 2))
println(2.intPlus(3)) //extention-like call
```



### inline functions

内联函数



### lambda表达式

完整的表达式如下

```kotlin
val sum: (Int, Int) -> Int = {x: Int, y: Int -> x + y}
```

lambda表达式被`{}`包裹.如果省略类型

```kotlin
val sum = {x, y -> x + y}
```

### 传递lambda作为最后一个参数

如果lambda作为函数最后一个参数,那么可以放在括号外面,设置可以省略括号

```kotlin
val product = items.fold(1) {acc, e -> acc * e}
```

Such syntax is also known as *trailing lambda*.
如果lambda是唯一的参, 那么圆括号可以完全的省略

```kotlin
run {
  println("...")
}
```

```kotlin
//这种情况就不能省略括号了, 要不残生了歧义.    
println({ x: Int, y: Int ->
        x + y
    }(10, 20))
```

```kotlin
    val r = run {
        { x: Int, y: Int ->
            x + y
        }(10,20)
    }
    println(r)
```



### it : 单个参数的隐式名称

如果`lambda`只有一个参数, 那么 `it`可以隐式的指向这个参数

```kotlin
ints.filter{
  it > 0 //this literal is of type '(it: Int) -> Boolean'
}
//可以直接省略it: Int -> 这些编译器可以自行理解推断的参数
```



### Returning a value from a lambda expression

 

我们可以使用限定的返回从lambda显式的返回一个值, 否则将返回最后一个表达式的值

```kotlin
//implicit the last expression as the value of the lambda
ints.filter {
  val shouldFilter = it > 0
  shouldFilter
}

//explicit return the qualified return value same as above
ints.filter {
  val shouldFilter = it > 0
  return@filter shouldFilter
}
```

这一约定连同在圆括号外传递lambda表达式一起支持`LINQ-风格`的代码

```kotlin
strings.filter{it.length == 5}.sortedby{it}.map{it.toUpperCase()}
```



### 使用下划线站位不使用的变量(since 1.1)

```kotlin
map.forEach {
  -, value -> println("$value")
}
```

### lambda表达式中的解构

```kotlin
map.mapValues{
  entry -> "${entry.value!}"
}

map.mapValues{
  (key, value) -> "$value"
}
```

```kotlin
{ a -> ... } // one parameter
{ a, b -> ... } // two parameters
{ (a, b) -> ... } // a destructured pair
{ (a, b), c -> ... } // a destructured pair and another parameter
```

If a component of the destructured parameter is unused, you can replace it with the underscore to avoid inventing its name:

可以使用占位符

You can specify the type for the whole destructured parameter or for a specific component separately:

```kotlin
map.mapValues { (_, value): Map.Entry<Int, String> -> "$value!" }

map.mapValues { (_, value: String) -> "$value!" }
```



### 匿名函数

One thing missing from the lambda expression syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an *anonymous function*.

```kotlin
fun(x: Int, y: Int): Int = x + y
```

The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:

```kotlin
ints.filter(fun(item) = item > 0)
```





### Closures 闭包

lambda表达式或者是匿名函数可以访问其闭包. 即在外部作用域中声明的变量, 与Java不同的是可以修改闭包中捕获的变量

```kotlin
var sum = 0
ints.filter{it > 0}.forEach{
  sum+=it
}
println(sum)
```



### 带有接受者的函数字面值

匿名函数语法允许你直接指定函数字面值的接受者类型.



```kotlin
val sum: Int.(Int) -> Int = {other -> plus(other)}//在接受者对象上调用了plus
```



```kotlin
val sum = fun Int.(other: Int) = this + other
```

当接收者类型可以从上下文推断时, lambda 表达式可以用作带接收者的函数字面值

一个非正常重要的例子是类型安全的builder

PS: 类型安全的构建器可以参考Other章节

```kotlin
class HTML{
  fun body(){
    
  }
}


fun html(init: HTML.() -> Unit) : HTML {  //参数是一个带接受类型的匿名函数
  val html = HTML()
  html.init()
  return html
}

//dsl
html {  //带有接收者的lambda由此开始
  body()
}
```



### 内联函数

使用高阶函数会带来一些运行时的效率损失: 每个函数都是一个对象, 并且会捕获一个闭包. 即那些在函数体内会访问到的变量不会别释放. 内存分配.

在大多数情况下, 可以内联化lambda表达式可以消除这种开销

```kotlin
lock(l) {
  foo()
}
```

编译器没有为参数创建一个函数对象并生成一个调用, 编译器经过优化会生成下面的代码

```kotlin
l.lock()
try {
  foo()
}
finally {
  l.unlock()
}
```

为了显式的告诉编译器将函数内联, 可以使用inline修饰符修饰标记`lock()`函数


```kotlin
inline fun <T> lock(lock: Lock, body: ()  -> T): T {}
```

The `inline` modifier affects both the function itself and the lambdas passed to it: all of those will be inlined into the call site `inline`可以修饰函数以及传递给函数的参数(lambda)

注意, 内联函数会增加编译后的代码



### noinline

禁用内联

如果你只想一些传递给内联函数的lambda是inline的, 那么可以手动禁用inline

```kotlin
inline fun foo(inlined: ()-> Unit, noinline notInlined: () -> Unit) {
  
}
```



注意

可以内联的lambda表达式只能在内联函数内部调用或者作为可内联的参数传递, 但是`noinline` 的可以以热河我们喜欢的方式操作: 存储在字段中,传送它等.

慎用 内联



### 非局部返回

在Kotlin中, 我们必须使用一个标签退出lambda表达式. lambda表达式不能包含函数的返回

```kotlin
fun foo() {
  ordinaryFunciton{
    return //ERROR, forbidden return here
  }
}
```

但是如果lambda表达式传给的函数时内联的, 该return也可以内联, 所以它是允许的

```kotlin
inline fun inlined(block: () -> Unit) {
  println("hi")
}
```

```koltin
fun foo(){
	inlined{
		return //ok 该lambda表达式是内联的
	}
}
```

这种返回称为非局部返回 

```kotlin
fun hasZero(ints: List<Int>) : Boolean {
	ints.forEach {
    if(it == 0) return true
  }
  return false
}
```



### 具体化的参数类型(reified)



### 内联属性

