---
layout:     post
title:      "Java学习笔记15"
subtitle:   "泛型"
date:       2016-12-21 19:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java	
---

# 第15章 泛型

> 一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义类型的类。如果要编写可以用于多种类型的代码，这种方式对于代码的束缚就会很大。

写在开头：

泛型的出现一个是可以在编译时就进行类型检查，避免了运行时的错误的类型转换抛出异常，此外，Java支持泛型也同时提高了编程效率，可以使用类似C++ 模板类的机制编写代码。



Java SE5的新特性就是泛型的概念。泛型实现了**参数化类型**的概念，使得代码可以用于多种类型。



### 15.1 与C++的比较

Java的泛型能做到什么，不能做到什么（Java泛型的边界是什么）？与C++ 的模板类相比较，Java的泛型优缺点是什么？什么是纯粹的泛型？



### 15.2 简单泛型

泛型的出现->创造**容器类（Collections）**



```java
//不使用泛型
public class Holer{
  private Object[] element;
  private int size;
  
  Holder(){
    
  }
  
  Holder(int size){
    this.size = size;
  }
  public void add(Object obj){
  	//add
  }
  
  public Object get(int position){
    //get;
  }
} 

public class Main{
  public static void main(String[] args){
    Holer h = new Holder();
    h.add(new Something1());
    //need to cast;
    Somthing1 some = (Something1)h.get(0);
  }
}


//使用泛型

public class Holder<T>{
  private T element;
  //something
}

//也许上面的例子没有足够的说服力，后面的例子也许会更清晰些
```





#### 元组

> 仅一次方法调用就能返回多个对象，但是return语句只允许返回单个对象，因此，解决办法就是创建一个对象，用它来持有想要返回的多个对象。当然，可以再每次需要的时候专门创建一个类来完成这个工作。但是有了泛型没我们就能够一次性的解决该问题。同时在编译时保证类型安全



定义：

**将一组对象直接打包存储于其中一个对象中，这个容器对象允许读取其中的元素，但是不允许向其中放入新的对象（这个概念也称为数据传送对象或信使），这个概念就是元组（tuple）**

示例：二维元组

```java
public class TwoDimenTuple<T,K>{
  public final T t;
  public final K k;
  
  TwoDimenTuple(T t, K k){
    this.t = t;
    this.k = k;
  }
}
```

安全性分析：客户端可以随意的使用t和k，但是已经初始化就无法改变t和k的值。因为final声明使得t和k是安全的，而且格式更加简单，因此不必要使用getter和setter，也不用讲域声明为private的。

当然你还可以声明三维元组或者更多维的元组。



> 为了使用元组，可以定义一个长度何时的元组，将其作为方法的返回值，然后在return语句中创建元组返回即可。



```java
public class Traffic<Vehicle,String,Integer>{
  //,,,,,
  
  public Traffic<Vehicle,String,Integer>)(Parameters...){
    return new Traffic<Vehicle,String,Integer>(.....);
  }
}
```





### 15.3 泛型接口

泛型也可以用于接口。例如生成器，这是一种专门负责创建对象的类，实际上这是一种工厂方法设计模式的一种应用。



```java
package net.mindview.util;

public interface Generator<T>{
  T next();
}
```



### 15.4 泛型方法

> 泛型方法使得该方法能够独立于类而产生变化。
>
> 指导原则：
>
> 无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说吗如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。
>
> 此外，对于一个static的方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力，就必须使其称为泛型方法。



```java
public class GenericMethods{
  public <T> void f(T t){
  	System.out.println(t.getClass().getName());  
  }
  
  public static void main(String[] args){
    GenericMethods gm = new GenericMethods();
    gm.f("");
    gm.f(1);
    gm.f(1.0);
    gm.f(1.0f);
    gm.f(gm);
  }
  
}
```



GenericMethods 并不是参数化的，尽管这个类和其内部的方法可以被同时参数化，但是在这个例子中，只有方法f是参数化的。



==当使用泛型类时，必须在创建对象的时候就指定类型参数的值，而使用泛型方法时，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这个被称为**类型推断**。==

如果调用方法f()传入的是基本类型，自动装箱就会介入其中，将基本类型装箱为对应的对象。



#### 杠杆利用参数类型推断

类型推断只是对赋值操作有效，其他时候并不一定生效。如果你是将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断。在这种情况下，编译器认为：调用泛型方法后，其返回值被赋给一个Object类型的变量，如下。



```java
public class LimitsOfInference{
  static void f(Map<SPerson, List <? extends Pet>> petPeople){
    
  }
  public static void main(String[] args){
    //f(New.map()); 这个无法被编译器编译通过
  }
}

//注：New.map()
public class New{
  public static <K,V> map<K,V> map(){
  return new HashMap<K,V>();
}
}
```



#### 显示的类型说明

在泛型方法中，可以显示的指明类型，不过这种语法很少使用。

```java
/要显示的指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static方法，必须在点的操作符之前加上类名。
/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        LimitsOfInterface.f(New.<Person, List<Pet>>map());
    }
}


class Person{
    
}

class Pet{
    
}

class LimitsOfInterface{
    static void f(Map<Person, List<Pet>> map){
        
    }
}

class New{
    public static <K,V> Map<K,V> map(){
        return new HashMap<K, V>();
    }
}
```

### 15.5 匿名内部类

泛型还可以应用于内部类和匿名内部类。示例展示使用匿名内部类实现Generator接口



```java
public interface Generator<T>{
  T next();
}


class Customer{
  private static long counter = 1;
  private final long id = counter++;
  private Customer(){}
  
  public String toString(){
    return "Customer " + id;
  }
  
  public static Generator<Customer> generator(){
    return new Generoator<Customer>(){
      public Customer next(){
        return new Customer();
      }
    }
  }
}
```



### 15.6 构建复杂的模型

泛型的一个重要好处就是能够简单而安全的构建复杂的模型。



```java
public class TupleList<A,B,C> extends ArrayList<FourTuple<A,B,C,D>> {
  public static void main(String[] args){
    TupleList<Vehicle,Amphibian,String,Integer> t1 = new TupleList<>();
    
    t1.add(TupleTest.h());
    t2.add(TupleTest.h());
    for(FourTuple<Vehicle,Amphibian,String,Integer>() i : t1){
     System.out.println(i); 
    }
  }
}
```





### 15.7 类型擦除

> 当你开始更深入地钻研泛型时，会发现大量的东西初看起来是没有意义的。例如，尽管可以生命ArrayList.class，但是不能生命ArrayList<Integer>.class



```java
public class EraseTypeEquivalence{
  public static void main(String[] args){
    Class c1 = new ArryaList<Integer>.getClass();
    Class c2 = new ArrayList<String>.getClass();
    System.out.println(c1==c2);
  }
}
//output ： true

ArrayList<Integer> 和 ArrayList<String>很容易被认为是两种不同的类型。
```



下面一个例子

```java
import java.io.ByteArrayOutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {

        List<Frob> list = new ArrayList<Frob>();
        Map<Frob,Fnorkle> map = new HashMap<Frob, Fnorkle>();
        Quark<Fnorkle> quark = new Quark<Fnorkle>();
        Particle<Long,Double> p = new Particle<Long, Double>();

        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));

        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
    }
}


class Frob{
    
}

class Fnorkle{
    
}

class Quark<Q>{
}

class Particle<POSITION,MOMENTUM>{}



//output 
[E]
[K, V]
[Q]
[POSITION, MOMENTUM]

Process finished with exit code 0

```



Class.getTypeParameters将返回一个TypeVariable的对象数组，表示有反省生命所生命的参数类型。这像是在暗示你可能发现参数类型的信息。

然而，正如从输出中你所看到的，你能够发现的只是用作参数占位符的标识符，这并非有用的信息。

因此得出的残酷结论是：

==在泛型代码内部，无法获得任何有关泛型参数类型的信息==

因此，你可以知道注入类型参数标识符和泛型参数边界这类的的信息-但是你却无法知道用来创建某讴歌特定实例的实际的参数类型。



Java的泛型是使用擦除来实现的，**这意味着当你使用泛型的时候，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象**。因此，`List<Integer>`和`List<String>`*在运行时*事实上是相同的类型，这两种形式都会被擦除成他们的原生类型，即List。



#### 与C++的对比

```c++
#include <iostream>
using namespace std;


template <class T> class Manipulator{
    T Obj;
public:
    Manipulator(T x){
        this->Obj = x;
    }

    void manipulate(){
        Obj.f();
    }

};

class Hasf{
public:
    void f(){
        cout<<"Hasf::f()"<<endl;
    }
};

int main() {
    Hasf hasf;
    Manipulator<Hasf> manipulator(hasf);
    manipulator.manipulate();

}

//output
Hasf::f()
```



Manipulator类存储了一个类型T的对象，有意思的地方时manipulate()方法，它在obj上调用方法f()。但是它怎么能知道f()方法是为类型参数T而存在的呢？

当你实例化这个模板时，C++编译器将进行检查，因此在`Manipulator<HasF>`被实例化的这一刻，它看到HasF拥有一个方法f(),如果情况并非如此，就会得到一个编译期错误，这样类型安全就可以保证了。

用C++编写这种类型的代码非常简单，因为当模板被实例化时，模板代码知道其模板*参数的类型*，Java泛型就不可以了。

如果将上面这个实例，换成Java代码，那么这些代码将无法通过编译。

```java
class Manipulator<T>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
       //Error: can't resolve method 'f()'
        obj.f();
    }
}
```





由于有了类型擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF拥有f()这一事实上，为了调用f()，我们就必须协助泛型类，给定泛型类的==边界==，以此告诉编译器只能接受遵循这个边界的类型。这里重用了extends关键字。由于有了边界，下面的代码就可以编译了。



```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        Manipulator<HasF> manipulator = new Manipulator<HasF>(new HasF());
        manipulator.manipulate();
    }
}


class Manipulator<T extends HasF>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}
```



==边界`<T extends HasF>`声明了T必须具有类型HasF或者从HasF导出的类型。如果情况确实如此，那么就可以安全的在obj上调用f()了==。

我们说泛型类型参数将*擦除到它的第一个边界（可能会有多个边界）*，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例一样，T擦除到了HasF，就好像在累的生命中用HasF替换了T一样。



上面的代码中，泛型实际上没有贡献任何好处，只需很容易地自己去执行擦除，就可以创建出没有泛型的类。

```java
class Manipulator{
  private HasF obj;
  public Manipulator(HasF x){
    obj = x;
  }
  public void manipulate(){
    obj.f();
  }
}
```



这提出了很重要的一点：

只有当你希望使用的类型参数比某个具体类型（以及所有它的子类型）更加“泛化”时，也就是希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，类型参数和他们在有用的泛型代码中的应用，通常比简单的类替换要更复杂。但是，不能因此而认为`<T extends HasF>`形式的任何东西都是有缺陷的。

例如，如果某个类有一个返回T的方法，那么泛型就有所帮助，因为他们之后将返回确切的类型。

```java
public class Main {
    public static void main(String[] args) {
        Manipulator<HasF> manipulator = new Manipulator<HasF>(new HasF());
        manipulator.manipulate();
        HasF hasF = manipulator.get();
    }
}


class Manipulator<T extends HasF>{
    private T obj;
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}
```



#### 迁移兼容性

为了减少潜在的关于擦除的混淆，你必须清楚的认识到这不是一个语言特性，它是Java泛型实现的一种折中，因为泛型不是Java语言出现时就有的组成部分，所以这种折中是必须的。折中折中会让你痛苦，因此你需要习惯它并了解为什么它会是这样。

如果泛型在Java1.0的版本上 就实现了，那么这个特性就不会使用擦除来实现，它将使用*具体化*（就像C++ 示例中那样），是类型参数保持为第一类试题，因此能够在类型参数上执行基于类型的语言操作和反射操作。

类型擦除减少了泛型的泛化性，泛型在Java中仍旧是有用的，只是不如本来设想的那么好，而原因就是擦除。（C++中的模板类是一种更好的实现。）



在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文环境细中使用的类型，泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界，例如`List<T>`这样的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下江北擦除为Object。



擦除的核心动机是，它是的繁华的客户端可以使用非泛化的库来使用，反之亦然。这经常被称为*“迁移兼容性”*。



```java
class Manipulator<T extends HasF>{
    private T obj;
    
    Manipulator(){
        
    }
    
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
        obj.f();
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}

class Manipulator2 extends Manipulator{
    Manipulator2(){
        
    }

  	//继承后的类型擦除，到HasF
    @Override
    public HasF get() {
        return super.get();
    }
} 
```

```java
class Manipulator<T>{
    private T obj;
    
    Manipulator(){
        
    }
    
    public Manipulator(T x){
        obj = x;
    }
    public void manipulate(){
    }
    public T get(){
        return obj;
    }
}

class HasF{
    public void f(){
        System.out.println("method f() called");
    }
}

class Manipulator2 extends Manipulator{
    Manipulator2(){
        
    }

  //类型擦除为Object
    @Override
    public Object get() {
        return super.get();
    }
} 
```





#### 类型擦除问题

因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会突然间破坏所有的代码。

擦除的代价也是显著的，泛型不能用于显示的引用运行时类型的操作中，例如转型，instanceof和new表达式。因为所有关于参数的类型信息都在运行时丢失了，无论何时，当你编写泛型代码的时候。==注意，你只是*看起来好像拥有有关参数的类型信息*而已==。

如果你写了下面的代码：

```java
class Foo<T>{
  T var;
}

//那么，看起来当你在创建Foo的实例时：
Foo<Cat> f = new Foo<Cat>();
```



class Foo的代码应该知道现在工作于Cat之上，而泛型语法也在强烈暗示：整个类的各个地方，类型T都在被替换。但是事实并非如此，无论何时，当你在编写这个类的代码时，必须提箱自己：==“不，它只是一个Object！”==

```java
class GenericBase<T>{
    private T element;
    private void set(T arg){
        element = arg;
    }
    public T get(){
        return element;
    }
}

class Derived1<T> extends GenericBase<T>{
    
}

class Derived2 extends GenericBase{
//no warnings    
}

class Derived3 extends GenericBase<?>{
    //no wild card expected
    //required class or interface without bounds
}



public class Main {
    public static void main(String[] args) {
        Derived2 derived2 = new Derived2();
        Object object = derived2.get(); //继承擦除了类型
        derived2.set(object);//warning: unchecked call to set(T) as a member of raw type GenericBase
    }
} 
```



当你希望将类型参数不要仅仅的当做Object处理时，你需要付出额外的努力来管理边界，并且与在C++等这样的语言中获得的参数化类型相比，你需要付出多得多的努力来获取少的少的汇报。



#### 边界处的动作

正是因为有了擦除，泛型最令人困惑的方面源自这样一个事实，即可以表示没有任何意义的事物。

```java
public class ArrayMaker<T>{
	private Class<T> kind;
  
  public ArrayMaker(Class<T> kind){
    this.kind = kind;
  }
  
  T[] create(int size){
    //warning unchecked cast. 
    reutnr (T[])Array.newInstance(kind,size);
  }
  
  public static void main(String[] args){
    ArrayMaker<String> stringMaker = new ArrayMaker<String>();
    String[] stringArray = stringMaker.create(9);
    System.out.println(Arrays.toString(stringArray));
  }
}

//output 

//[null,null,...,null]
```

即使，kind被存储为`Class<T>`，擦除也意味着它实际将被存储为Class，没有任何参数。因此每当你在使用它时，例如在创建数组的时候，`Array.newInstance()`实际上并未拥有kind所蕴含的类型信息，因此这不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告。

如果要创造一个容器而不是数组，情况就有所不同。

```java
public class ListMaker<T>{

  List<T> create(){
    return new ArrayList<T>();
  }
  
  public static void main(String[] args){
    ListMaker<String> stringMaker = new ListMaker<String>();
    List<String> stringList = stringMaker.create();
  }
}
```

 

编译器不会给出任何的警告，尽管我们（从擦除中）可以知道create()内部的`new ArrayList<T>()`中的`<T>`会被擦除，在运行时，这个类的内部会有任何`<T>`，因此这看起来毫无意义。但是，如果遵循这种思路与，将这个表达式改为`new ArrayList()`，编译器就会给出警告。

在本例子中是否有意义呢？返回List之前将某些对象放入其中。



```java
public class Main {
    public static void main(String[] args) {
       FilledListMaker<String> listMaker = new FilledListMaker<String>();
       List<String> strings = listMaker.create("hellow",4);
        System.out.println(strings);
    }
}
 
class FilledListMaker<T>{
    List<T> create(T t,int n){
        List<T> result = new ArrayList<T>();
        for (int i = 0; i < n; i++){
            result.add(t);
        }
        return result;
    }
}
```

即使编译器无法知道有关create()中的T的任何信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其适合`ArrayList<T>`。因此，即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。



因为擦除在==方法体中移除了类型信息==，所以在运行时的问题就是*边界*：

即对象进入和离开方法的地点。这些正是编译器在编译期间执行类型检查并插入转型代码的地点。

```java
public class Main {
    public static void main(String[] args) {
        SimpleHolder holder = new SimpleHolder();
        holder.set("Item");
      //class字节码，将在这里进行强制类型转化与检查
        String s = (String)holder.get();
    }
}

class SimpleHolder{
    private Object obj;
    public void set(Object obj){
        this.obj = obj;
    }
    public Object get(){
        return this.obj;
    }
}
```



如果反编译`SimpleHolder`这个类，得到内容解释：

```
class SimpleHolder {
  SimpleHolder();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void set(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return

  public java.lang.Object get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
}

 Fri 19 May - 01:55  ~/IdeaProjects/GradleJava 
 @hefuduo  javap -c build.cjavap -c build.classes.main.Main 
警告: 二进制文件build.classes.main.Main包含Main
Compiled from "Main.java"
public class Main {
  public Main();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class SimpleHolder
       3: dup
       4: invokespecial #3                  // Method SimpleHolder."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String Item
      11: invokevirtual #5                  // Method SimpleHolder.set:(Ljava/lang/Object;)V
      14: aload_1
      15: invokevirtual #6                  // Method SimpleHolder.get:()Ljava/lang/Object;
      18: checkcast     #7                  // class java/lang/String
      21: astore_2
      22: return
}

```



set()和get()方法将直接存储和生产值，而转型是在调用`get()`方法时接受检查的。

```java
class GenericHolder<T>{
  private T obj;
  public void set(T obj){
    this.obj = obj;
  }
  
  public T get(){
    return obj;
  }
}
public class Main {
    public static void main(String[] args) {
		GenericHolder<String> holder = new GenericHolder<String>();
      holder.set("Item");
      String s = holder.get();
    }
}

```

```
警告: 二进制文件build.classes.main.GenericHolder包含GenericHolder
Compiled from "Main.java"
class GenericHolder<T> {
  GenericHolder();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void set(T);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return

  public T get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
}

 Fri 19 May - 01:57  ~/IdeaProjects/GradleJava 
// @hefuduo  javap -c build.cjavap -c build.classes.main.Main 
警告: 二进制文件build.classes.main.Main包含Main
Compiled from "Main.java"
public class Main {
  public Main();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class GenericHolder
       3: dup
       4: invokespecial #3                  // Method GenericHolder."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String Item
      11: invokevirtual #5                  // Method GenericHolder.set:(Ljava/lang/Object;)V
      14: aload_1
      15: invokevirtual #6                  // Method GenericHolder.get:()Ljava/lang/Object;
      18: checkcast     #7                  // class java/lang/String
      21: astore_2
      22: return
}

```



对于进入set操作进行的检查是不需要的，因为这将由编译器执行。而对从get返回的值进行转型仍旧是需要的，但是这与你自己必须执行的操作是一样的，此处是由编译器自动插入的，因此写入和读取的代噪声（所谓噪声就是指你要写一些冗余的代码）将更小。

由于所产生的get和set的字节码相同，所以在泛型中的所有动作都发生在边界出----

对于传递进来的值进行额外的编译器检查，并插入对传递出去的值得转型。



### 15.8 擦除的补偿

> 正如我们所看到的，擦除丢失了在泛型代码中执行某些操作的能力，任何在运行时需要知道确切类型信息的操作都将无法工作。

```java
public class Erased<T>{
  private final int SIZE = 100;
  public static vodi f(Object arg){
    if(arg instance of T){   //Error
      T var = new T();   //Error;
      T[] array = new T[SIZE]; //Error
      T[] array = (T) new Object[size]; // unchecked warning
    }
  }
}
```



偶尔可以绕过这些问题来编程，==但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显示的传递你的Class对象，以便你可以在类型表达式中使用它==

例如，前面中的例子使用instanceof的尝试失败了，因为类型信息被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();

注意了，注意了，干货到了。

```java
import java.util.List;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        ClassTypeCapture<Building> cct1 = new ClassTypeCapture<Building>(Building.class);
        System.out.println(cct1.f(new Building()));
        System.out.println(cct1.f(new Mouse()));
        
        ClassTypeCapture<Mouse> cct2  = new ClassTypeCapture<Mouse>(Mouse.class);
        System.out.println(cct2.f(new Building()));
        System.out.println(cct2.f(new Mouse()));
    }
}

class Building{}
class Mouse extends Building{}

class ClassTypeCapture<T>{
    Class<T> kind;
    public ClassTypeCapture(Class<T> t){
        kind = t;
    }
    public boolean f(Object arg){
        return kind.isInstance(arg);
    }
}

//out put 
//true
//true
//false
//true
```





#### 创建类型实例

Erase.java创建一个new T()无法实现，原因一部分是因为擦除，另一部分是因为编译器不能验证T具有默认的(无参)构造函数。

但是这在C++中,这种操作是很自然的,很直观,也很安全(它是在编译期受到检查的)

```c++
template<class T> class Foo{
  T x;
  T *y;
  public:
  	Foo(){
      y = new T();
  	}
};

class Bar{};

int main(){
  Foo<Bar> fb;
  Foo<int> fi; // 
  return 0;
}
```

Java中解决这种问题的方案是传递一个工厂对象，并使用它来创建新的实例，最便利的工厂对象就是Class，因此如果使用类型标签，那么就可以使用`newInstance()`来创建这个类型的新对象。



```java


/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        ClassAsFactory<Employee> cf = new ClassAsFactory<Employee>(Employee.class);
        System.out.println("success");
        System.out.println(cf.x);
        
        ClassAsFactory<Integer> cf1 = new ClassAsFactory<Integer>(Integer.class);
    }
}

class ClassAsFactory<T>{
    T x;
    public ClassAsFactory(Class<T> kind){
        try {
            x = kind.newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Employee{
    
}
```

   然后该段代码的输出是

```
java.lang.InstantiationException: java.lang.Integer
	at java.lang.Class.newInstance(Class.java:427)
	at ClassAsFactory.<init>(Main.java:20)
	at Main.main(Main.java:12)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.lang.NoSuchMethodException: java.lang.Integer.<init>()
	at java.lang.Class.getConstructor0(Class.java:3082)
	at java.lang.Class.newInstance(Class.java:412)
	... 7 more
success
Employee@511d50c0

Process finished with exit code 0
```

创建`ClassAsFactory<Integer>`而失败，是因为Integer没有任何默认的构造器。因为这个错误不是在编译器被捕获的。

Sun建议使用显式的工厂，并将限制其类型，只能接受实现了这个工厂的类。



                                                                                                                                                                                                                                                            ```java

/**
*  Created by hefuduo on 2017/5/4.
   */
   public class Main {
    public static void main(String[] args) {
        new Foo2<Integer>(new IntegerFactory());
        new Foo2<Widget>(new Widget.Factory());
    }
   }

interface FactoryI<T>{
    T create();
}

class Foo2<T>{
    private T x;
  //<F extends FactoryI<T>>把这个放在构造函数的签名是为了什么？
    public <F extends FactoryI<T>> Foo2(F factory){
        x = factory.create();
    }
}


class IntegerFactory implements FactoryI<Integer>{

    public Integer create() {
        return new Integer(0);
    }
}

class Widget{
    public static class Factory implements FactoryI<Widget>{

        public Widget create() {
            return new Widget();
        }
    }
}
                                                                                                                                                                                                                                                            ```



1. ==为什么这么做？好处是什么？为什么通过这种方式就补偿了类型擦除的问题？==
2. ==`Class<T>`这是用来干嘛的呢？==



注意，这确实只是船体`Class<T>`的一种变体。两种方式都传递了工厂对象，`Class<T>`碰巧是内建的工厂对象，而上面的方式创建了一个显示的工厂对象，但是你却获得了编译期间的检查。

另一种方式是*模板方法*设计模式。

如下示例：`get()`是模板方法，而`create()`是在子类中，定义的、用来产生子类类型的对象。



```java
/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        Creator creator = new Creator();
        creator.f();
    }
}

abstract class GenericWithCreate<T>{
    final T element;
    GenericWithCreate(){
        element = create();
    }
    abstract T create();
}

class X {}

class Creator extends GenericWithCreate<X>{

    X create() {
        return new X();
    }
    void f(){
        System.out.println(element.getClass().getSimpleName());
    }
}
```

#### 泛型数组

> 泛型数组的知识是非常重要的！非常重要的。

==正如你在Erase.java中所见，不能创建泛型数组。一般的解决方案是在任何想要创建泛型数组的地方使用ArrayList.==

但是有时你需要创建泛型类型的数组，例如ArrayList内部就是使用的数组。又去的是你可以按照编译器喜欢的方式来定义一个引用



```java
class Generic<T>{}

public cass ArrayOfGenericReference{
  static Generic<Integer>[] gia;
}
```

编译器会接受这个程序，也不会产生任何警告。但是，永远都不能创阿金这个确切类型的数组，包括类型参数，因此这有一点令人困惑。既然所有数组无论他们持有的类型如何，都具有相同的结构，那么看起来你应该可以创爱你一个Object数组，并将其转型为希望的数组类型，事实上这个是可以编译通过的，但是不能运行，他将产生ClassCastException

```java
public class ArrayOfGeneric{
  static final int SIZE = 100;
  static Generic<Integer>[] gia;
  public static void main(String[] args){
    //compile ClassCastException
    gia = (Generic<Integer>[])new Object[SIZE];
    
    //runtime is the raw type (erased)
	gia = (Generic<Integer>[])new Generic[size];
    
    System.out.println(gia,.getClass().getSimpleName());
  
    gia[0] = new Generic<Integer>();
    //! gia[1] = new Object(); //compile error
    
    //! gia[2] = new Generic<Double>();
  }
} 
```



问题在数组将跟踪他们的实际类型，而这个类型是在数组被创建时确定的， 因此，及时git已经被转型为`Generic<Integer>[]`，但是这个信息只存在于编译期。在运行时，它仍旧是Object数组。

```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArray<Integer> gi = new GenericArray<Integer>(10);
        Integer[] ia = gi.rep();
        Object[] ia1 = gi.rep();
    }
}

class GenericArray<T>{
    private T[] array;
    public GenericArray(int size){
        array = (T[])new Object[size];
    }
    public void put(int index,T t){
        array[index] = t;
    }
    public T get(int index){
        return array[index];
    }
    public T[] rep(){
        return array;
    }
}

//out put 
Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
	at Main.main(Main.java:8)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)

```



`rep()`方法将会返回T[]，它在main()中将用于gi，因此应该是Integer[],但是如果调用它，并尝试着将结果作为Integer[]引用来捕获，就是得到`ClassCastException`，这还是因为实际的运行时类型是Object数组。



因为有了擦除，数组的运行时类型只能是Object[],如果我们立即将其转型为T[],那么就会在编译期该数组的实际类型就将丢失，而编译器可能会错过某些潜在的错误检查，正是因为这样，最好在集合的内部使用Object[]，然后当你使用该数组元素的时，添加一个对T的转型。

```java

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArray<Integer> gi = new GenericArray<Integer>(10);
        for (int i = 0; i < 10; i++) {
            gi.put(i,i);
        }

        for (int i = 0; i < 10; i++) {
            System.out.print(gi.get(i)+ "   ");
        }
        
        Integer[] ia = gi.rep();
    }
}

class GenericArray<T>{
    private Object[] array;
    public GenericArray(int size){
        array = new Object[size];
    }
    public void put(int index,T t){
        array[index] = t;
    }
    public T get(int index){
        return (T)array[index];
    }
    public T[] rep(){
        return (T[])array;
    }
}
```

控制台如下：

```
Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
0   1   2   3   4   5   6   7   8   9   	at Main.main(Main.java:16)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)

Process finished with exit code 1
```



初看起来，这好像没多大变化，只是转型换了地方。以上的代码内部标识是Object[]而不是T[]。当get被调用是，它将独享转型为T，这实际上发是正确的类型，因此这是安全的。然而，如果你小勇rep，它还是尝试着将Object[]转型为T[]，这仍旧不是正确的，将在编译期产生警告，但在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[]，在内部将array当做Object数组而不是T[]数组处理的优势是，我们不太可能忘记这个数组的运行时类型，而意外地引入缺陷。

对于新代码，应该传递一个标记类型，在这种情况下，GenericArray看起来会像下面这样。

```java
import java.lang.reflect.Array;

/**
 * Created by hefuduo on 2017/5/4.
 */
public class Main {
    public static void main(String[] args) {
        GenericArrayWithTypeToken<Integer> gai = new GenericArrayWithTypeToken<Integer>(Integer.class,10);
        Integer[] ia = gai.rep();
    }
}

class GenericArrayWithTypeToken<T>{
    private T[] array;
    public GenericArrayWithTypeToken(Class<T> type,int size){
        array  = (T[]) Array.newInstance(type,size);
    }
    
    public void put(int index, T item){
        array[index] = item;
    }
    
    public T get(int index){
        return array[index];
    }
    
    public T[] rep(){
        return array;
    }
}
```

类型标记`Class<T>`被传递到构造器中，以便从擦除中恢复，使得我们可以创建需要的实际类型的数组，尽管从转型中产生的警告必须用`@Suppress Warnings`压制，一旦我们获得了实际类型，就可以返回它，并获得想要的结果，就像在main中看到的那样，该数组运行时类型是确切类型T[];



Java类库中（SE5）的标准类库源代码。你可以看到Object数组到参数化数组的类型的转换导出都是。

```java
//例如
public ArrayList(Collection c){
  size = c.size;
  elementData = (E[])new Object[size];
  c.toArray(elementData);
}
```



### 15.9   边界

> 边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这使得你可以强制规定泛型可以应用的类型。
>
> 因为擦除移除了类型信息，所以，可以使用误解反省参数调用的方法只是哪些可以用Objetct调用的方法。但是没如果能够将这个参数限制为某个类型的自己，那么就可以用这些类型自己来调用方法，为了执行这种限制，Java泛型重用了extends关键字。extends关键字在泛型边界的上下文环境中和在普通情况下所具有的意义是完全不同的。



【关于边界的概念，可以参考Java基础教程的泛型相关章节】



### 15.10  通配符

> 一些通配符的使用，例如在泛型参数表达式中的问号。



展示数组的一种特殊行为的例子：



```java
class Fruit{}
class Apple extends Fruit{}
class Jonathan extends Apple{}
class Orange extends Fruit{}

```

