---
layout:     post
title:      "Kotlin学习笔记1"
subtitle:   "Basic"
date:       2019-08-20 16:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin	
---

[TOC]

# Kotlin学习笔记1

## Basic

### Basic Types

#### 数字

| 类型   | 大小Bit | Min   | Max    |
| :----- | :------ | ----- | ------ |
| Byte   | 8       | -128  | 127    |
| Short  | 16      | -2^16 | 2^16-1 |
| Int    | 32      | -     | -      |
| Long   | 64      | -     | -      |
| Float  | 32      | -     | -      |
| Double | 64      | -     | -      |



##### Literal constants

- Decimals `123 or L for Long  123L`
- Hexadecimals `0x0F`
- Binaries `0b00001010`
- Double is default `1.1111`
- Float is use f `123.5f`



##### Underscores in numeric literals (since 1.1)

使用下划线格式化数字

```kotlin
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

##### Representation

在JVM平台, 数字被存储为JVM基本类型, 除非使用一个空类型number的引用, e.g. `Int?` 或者是泛型, 数字类型会被装箱,变为一个对象.

被装箱的数字不再是原始类型, 变成了对象, 因此不再相等.

`===` : 代表比较两个对象的地址是否一致.

```kotlin
val a: Int = 10000
println(a === a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
println(boxedA === anotherBoxedA) // !!!Prints 'false'!!!			
```

但是这两个对象的值还是相等的.

```kotlin
val a: Int = 10000
println(a == a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
println(boxedA == anotherBoxedA) // Prints 'true'
```

##### <font color="red">隐式转换</font>

因为不同的类型系统, 较小的类型转换为较大的类型,会出现问题.如下.

```kotlin
// Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)
print(b == a) // Surprise! This prints "false" as Long's equals() checks whether the other is Long as well
```

​	可以看出 `a`和`b`的值并不相等.

因此得出结论, 较小类型是不能隐式转换为较大类型的,这就意味着我们不能把一个`Byte`类型的值赋给`Int`类型的变量.

```kotlin
val b: Byte = 1 //OK 
val c: Int = b // ERROR
```

使用显示转换

```kotlin
val i : Int = b.toInt()
```

每个数字类型都支持下列的显式转换方法

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`
- `toChar(): Char`



##### 位操作

```kotlin
val x = (1 shl 2) and 0x000ff000
```

- `shl(bits)` – 带符号左移
- `shr(bits)` –  带符号右移
- `ushr(bits)` – 无符号右移
- `and(bits)` –  按位与
- `or(bits)` –  按位或
- `xor(bits)` –  按位亦或 同为1 不同为0
- `inv()` – 按位取反



##### <font color="red">浮点数的比较</font>

PS: 一定要使用compareTo相比较, 是不能直接用`= > < `这些符号比较的. 

- `NaN` 与自己不相等
- `NaN`  既不大于也不小于 更不等于 `POSITIVE_INFINITY`  or `NEGATIVE_INFINIZTY` 
- `-0.0` is considered less than `0.0`

```kotlin
val a = -0.0
    val b = 0.0
    val c = Double.NaN
    val d = Double.POSITIVE_INFINITY
    val e = Double.NEGATIVE_INFINITY
    println(a.compareTo(b))  //-1
    println(c.compareTo(c))  //0
    println(d.compareTo(d))   //0
    println(c.compareTo(d))   //1
```



#### 字符

字符使用`Char`表示, 无法直接当成数字

```kotlin
fun check(c: Char) {
  if (c == 1) { //ERROR: incompatible types
    
  }
}
```

字符常量使用单引号, 特殊字符需要使用反斜杠表示

`'1'`

```kotlin
'\t'
'\b'
'\n'
'\"'
'\$'
unicode 字符
'\uFF00'
```

可以显式的将字符转换成整型

```kotlin
fun decimalDigitValue(c : Char): Int{
  if (c !in '0'..'9'){
    throw IllegalArgumentException("$c is out of range")
  }
  return c.toInt() - '0'.toInt() // explicit conversions to number
}
```



#### 布尔

使用 `Boolean`表示布尔值

#### 数组

Arrays in Kotlin are represented by the `Array` class, that has `get` and `set` functions (that turn into `[]` by operator overloading conventions), and `size` property, along with a few other useful member functions:

创建一个Array

```kotlin
val a = arrayOf(1, 2, 3)
```

或者使用构造函数创建

```kotlin
 val b = Array(5) { i ->
        (i * i).toString()
    }
arrayofNulls create an empty araray.
```



##### 基本类型的数组

kotlin 还可以指定使用特殊的类表示基础类型的数组而非装箱类型的数组

```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
val arr = IntArray(5, { 42 })// 5个42
val arr = IntArray(5, {it * 1})
```



#### 无符号整型

- `kotlin.UByte`: an unsigned 8-bit integer, ranges from 0 to 255
- `kotlin.UShort`: an unsigned 16-bit integer, ranges from 0 to 65535
- `kotlin.UInt`: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1
- `kotlin.ULong`: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1

##### 特殊的类

- `kotlin.UByteArray`: an array of unsigned bytes
- `kotlin.UShortArray`: an array of unsigned shorts
- `kotlin.UIntArray`: an array of unsigned ints
- `kotlin.ULongArray`: an array of unsigned longs

Same as for signed integer arrays, they provide similar API to `Array` class without boxing overhead.

Also, [ranges and progressions](https://kotlinlang.org/docs/reference/ranges.html) supported for `UInt` and `ULong` by classes `kotlin.ranges.UIntRange`, `kotlin.ranges.UIntProgression`, `kotlin.ranges.ULongRange`, `kotlin.ranges.ULongProgression`



##### 表达式

```kotlin
val b: UByte = 1u
val s: UShort = 1u
val l: ULong = 1u
val a1 = 42u
val a2 = 0xFFFF_FFFF_FFFFu
```



使用`uL`或者`UL`表示无符号浮点数

```kotlin
val a = 1UL
```



#### 字符串

字符串不可变, 可当成为一个字符数组, 可被索引, 可悲foreach循环

```kotlin
for(c in str) {
  println(c)
}
```

使用`+`号连接字符串





##### 字符串常量

```kotlin
val text = """
|Tell me and i forget.
|Teach me and I remember.
|Involve me and I learn.
|(Benjamin Franklin)
""". trimMargin()
//去掉头部的空格
```



##### 字符串模板

使用`$` 来标识字符串模板

```kotlin
val i = 10
println("i = $i")
```



### Package and Imports

#### Pacakges

一个源文件可能开始与一句包声明

#### Imports

import either  a single name

```kotlin
import org.example.Message //import a class with it full path name
```

or all the accessible contents of a scop(package, class, object etc)

```kotlin
import org.example.* //import everyting from the path
```

If there is a name clash, we can disambiguate by using `as` keywrod to locally rename the clashing entity.

```kotlin
import org.example.Message
import org.test.Message as testMessage //重新命名.
```



The `import` keyword is not restricked to importing classes; you can also use it to import other declarations:

- top-level funcitons and properties
- functions and properties declared in object declarations
- enum constants

### Control Flow : if when for while

#### If Expresssion

```kotlin
var max = a
if (a < b ) max = b
//with else
var max: Int 
if(a > b) {
 	max = a   
 }else {
  max = b
}

// As expression if表达式, 表达式是有值的
val max = if (a > b) a else b

```

#### When Expression

like switch in c

```kotlin
when(x){
  1 -> print("x == 1")
  2 -> print("x == 2 ")
}
```

可当做表达式也可以是一个声明

当作为一个表达式的时候.else是被强制需要的(防止出现when没有命中任何条件的情况下), 除非编译器能够证明所有的条件都被每条分支覆盖了, 例如枚举类型

```kotlin
when (x) {
  0, 1 -> print("x == 0 or x ==1")
  else -> print("otherwise")
}
```

使用任意表达式 作为分支条件

```kotlin
when(x) {
  parseInt(s) -> print("s encodes x")
  else -> print("s does not encode x")
}
```

使用range

```kotlin
when(x) {
  in 1..10 -> print("x is in the range")
  in validNumbers -> print("x is valid")
  !in 10..20 -> print("x is outside the range")
  else -> print("none of the above")
}
```

判断particular type, [smart casts]

```kotlin
fun hasPrefix(x: Any) = when(x) {
  is String -> x.startsWith("prefix") 
  else -> false
}
```



`when` 也能够当做`if-else if`的判断链使用.每个分支都是简单的`booelean`表达式. 当分支为true的时候被执行

```kotlin
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

从kotlin1.3 开始, 可以能够捕获when中的临时变量:

```kotlin
fun Request.getBody() = 
	when(val response = executeReqeust()) {
    is Success -> response.body
    is HttpError -> throw HttpExcetpion(response.status)
  }
```

Scope of variable, introduced in *when* subject, is restricted to *when* body.



#### For 循环



```kotlin
for(item in collection) print(item)
```

代码块

```kotlin
for (item: Int in ints) {
  //...
}
```

for range

```kotlin
for(i in 1..3) {
  println(i)
}

for(i in 6 downTo 0 step 2) {
  
}

for(i in array.indices) {
  println(array[i])
}

for((index, value) in array.withIndex()) {
  println("the element at $index is $value")
}
```

#### While Loops

`while` and `do while` work as usual



#### Returns and Jumps

- *return*. By default returns from the nearest enclosing function or [anonymous function](https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions).
- *break*. Terminates the nearest enclosing loop.
- *continue*. Proceeds to the next step of the nearest enclosing loop.

所有的这些表达式能够被用到更大的表达式中

```kotlin
val s = person.name ?: return
```

The type of these expression is the Nothing Type.

##### Break and Continue Labels

任何一个表达式能够使用<font color="blue">label</font>标记.

```kotlin
loop@ for(i in 1..100) {
  //...
}
```

qualify a *break* or a *continue* with a label:

```kotlin
loop@ for(i in 1..100) {
  for(j in 1..100) {
    if(...) 
    	break@loop
  }
}
```



##### Return at Labels

考虑这种情况, return直接返回到函数调用处,如果想从`lambda`表达式返回呢

```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // non-local return directly to the caller of foo()
        print(it)
    }
    println("this point is unreachable")
}
```

可以使用label标记

```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop
        print(it)
    }
    print(" done with explicit label")
}
```

也可以使用隐式的label

```kotlin
//the label has the same name as the fu nciton to which the lambda is passed
fun foo() {
  listOf(1, 2, 3, 4, 5).forEach {
    if(it == 3) return@forEach //local return to the caller of the lambda, i.e. the foreach loop
    print(it)
  }
  print("doen with implicit label")
}
```

此外我们也可以使用匿名函数, return将在匿名函数处返回(而不会从外部函数直接返回)

```kotlin
fun foo() {
  listOf(1, 2, 3, 4, 5).forEach(fun(value: Int){
    if(value == 3) return //local return to the caller of the anonymous fun.
    print(value)
  })
  print("done with the anonymous function")
}
```

```kotlin
fun foo() {
	run loop@{
		listOf(1, 2, 3, 4, 5).forEach {
      if(it == 3) return@loop //non-local return form the lambda passed to run
      print(it)
    }
	}
  print("done with nested loop")
}
```

when returning a value , the parser gives preference to the qualified return, i.e.

```kotlin
return@a 1
```

在标签名为`a`处返回值为`1`

