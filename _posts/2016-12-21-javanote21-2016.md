---
layout:     post
title:      "Java学习笔记21"
subtitle:   "Java多线程"
date:       2016-12-21 19:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java	
---

[TOC]

# 21 并发

## 21.1 Thread类

将Runnable对爱那个转变为工作任务的传统方式是把它提交给一个Thread构造器。

```java
public class BasicThreads{
  public static void main(String[] args){
    Thread t = new Thread(new Runnable(){
      @Override
      public void run(){
        //TODO 
      }
    });
    
    t.start();
  }
}
```

Thread 构造器只需要一个Runnable对象。调用Thread对象的`start()`方法为该线程执行必须的初始化操作，然后调用Runnable的run方法，以便在这个新县城中启动该任务。

## 21.2 使用Executor

java se5 可以使用Excutor为你管理Thread对象，从而简化了并发编程。

```java
public class SingleThreadExecutor{
  public static void main(String[] args){
    ExecutorService es = new Executors.newSingleThreadExcutor();
    es.execute(new Runnable(){
      //////
    });
    
    es.shutdonw();
  }
}
```

## 21.3 从任务中产生返回值

`Runnable`是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回同一个值，那么可以实现`Callable`接口，Java se5引入的`Callable`是一种具有类型参数的泛型，它的类型参数表示的是从方法`call()`中返回的值，并且必须使用`ExcutorService#submit()`方法调动它。

```java
public class CallableDemo {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        ArrayList<Future<String>> results = new ArrayList<Future<String>>();
        for (int i = 0; i < 10; i++) {
            results.add(service.submit(new TaskWithResult(i)));
        }
        for (Future<String> fs : results) {
            try {
                System.out.println(fs.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            } finally {
                service.shutdown();
            }
        }
        System.out.println("currentThread = " + Thread.currentThread().getName());
    }
}


class TaskWithResult implements Callable<String> {

    private int id;

    public TaskWithResult(int id) {
        this.id = id;
    }

    public String call() throws Exception {
        System.out.println("currentThread = " + Thread.currentThread().getName());
        return "result of taskwithresult " + id;
    }
}
```



### 21.2.5 休眠

影响任务行为的一种简单方法是调用`sleep()`，这将是任务中止执行给定的事件。

### 21.2.6 优先级

线程的*优先级*将该线程的重要性传递给了调度器。在绝大多数时间里，所有线程都应该以默认的优先级运行。试图操纵线程优先级通常是一种错误。

### 21.2.7 让步

如果知道已经完成了在`run()`方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：工作已经完成，让出CPU。方法是调用`#yield()`方法。这只是一个暗示，但是并没有机制保证它一定会被采纳。

### 21.2.8 后台线程

所谓后台(`daemmon`)线程，是指在程序运行的时候在后台提供的一种通用服务的线程，并且这种线程并不属于程序中不可获取的部分。因此，当所有的*非后台线程*结束时，程序也就终止了，同时会杀死进程中的所有后台线程，反过来说，只要有任何非后台线程在运行，程序就不会终止。比如`main()`就是一个非后台线程。

```java
public class DaemonTest implements Runnable{
    public void run() { 
        try {
            while (true){
                TimeUnit.MICROSECONDS.sleep(100);
                System.out.println(Thread.currentThread() + " " + this);
            }
        } catch (InterruptedException e) {
            System.out.println("sleep() interrupted");
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args){
        for (int i = 0; i < 10 ; i++){
            Thread daemon  = new Thread(new DaemonTest());
            daemon.setDaemon(true);
            daemon.start();
        }
        System.out.println("all daemon started");
        try {
          //TimeUnit.MICROSECONDS.sleep(175);
            TimeUnit.MICROSECONDS.sleep(5000); //改变这个主线程睡眠的时间，如果很短，那么你只能看到部分线程被创建并运行。如果是长一些的，那么你应该能够看见所有的10个后台线程在运行。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

一旦`main()`完成其工作，就没什么能组织程序终止了，因为除了后台线程之外，已经没有线程在运行了。

ps:

如果是一个后台线程，那么它创建的任何线程将被自动设置为后台线程。

## 21.3 锁同步

#### 隐式锁

synchronized 关键字

#### 显示锁

Java SE5的java.util.cocurrent类库还包含有定义在java.util.concurrent.locks中的显示的互斥机制。

`Lock`对象必须被显示的创建锁定与释放。虽然代码缺乏优雅性。但是，对于解决某些类型的问题来说，它更加灵活。比如条件锁。



#### 原子性与易变性

volatile关键字确保了应用中的可视性。如果讲一个域生命为`volatile`的，那么只要对这个域产生了写操作，那么所有的读操作就可以看到这个修改。即便使用了本地的缓存，情况也确实如此，`volatile`域会立即被写入到主存中，而读取操作就是发生在主存中。

#### 原子类

Java SE5 一如了诸如`AtomicInteger,AtomicLong,AtomicReference,AtomicBoolean`等特殊的原子性变量类。他们提供下面形式的原子性条件更新操作:

```java
boolean compareAndSet(expectedValue,updateValue);
```

这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性，因此对于使用他们无须担心，这些原子类在性能调优上非常有用。

#### 临界区

防止多个线程同事访问方法内部的布恩代码而不是防止访问整个方法：

```java
public void method(){
  //this can be access
  //
  //this only one task a time
  synchronized(some object){
    //同步的
  }
}
```



#### 生产者与消费者

#### 死锁

当下列四个条件同时满足时，就会发生死锁：

1. 互斥条件。任务使用的资源中至少有一个是不能共享的。
2. 至少有一个任务它必须有一个资源且正在等待获取一个当前被别的任务持有的资源。
3. 资源不能被任务抢占，任务必须把资源释放当做普通事件。
4. 必须有循环等待，这时，一个任务等其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，知道有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。

因为要发生死锁的话，所有这些条件必须全部满足：所以要防止死锁的话，只需要破坏其中一个即可。在程序中，**防止死锁发生最容易的方法是破坏第四个条件**

## 21.7 新类库中的构建

Java SE5 cocurrent包下面引入了大量涉及用来解决并发问题的新类。

例如：`CountDownLatch,CylicBarrier,Semaphore,ConcurrentHashMap,BlockingQueue`。

//TODO Java并发编程 单独出一份笔记吧

