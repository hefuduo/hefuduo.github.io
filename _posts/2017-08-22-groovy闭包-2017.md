---
layout:     post
title:      "Groovy之闭包"
subtitle:   "Closure"
date:       2017-08-22 17:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Groovy	
---

[TOC]

# 闭包

闭包是一种可执行的代码块的方法，闭包也是对象，可以想方法一样传递参数。由于闭包是代码块，因此也可以在需要时执行。定义闭包的时候可以使用一个或者多个参数。闭包可以访问属性信息，意味着可以访问并修其作用于内的所有变量值。

## 闭包

```groovy
def greeting = 'hello'
def clos = {
    param ->
        println "$greeting $param"
}

clos.call("world")

greeting = 'welcome'
clos.call('world')

def demo(clos){
    def greeting = 'Bonjour'//this will not affect closure
    clos.call('ken')
}

demo(clos)   //output welcome ken
```

以上代码说明，只有闭包被定义且存在，而不是在被调用时，可以访问其状态值。

 闭包也常用在集合中。使用闭包可以更高效的遍历元素。

```groovy
1.upto(10,{
    println it 
})
//或者你也可以这么写
1.upto(10){
    println it
}
```

```groovy
//阶乘
def fac = 1
1.upto(5){
    num ->
        fac *= num
}

println "Factorical : $fac"
```

## 闭包与集合和字符串

常用each方法来遍历。

`find()返回第一个满足条件的元素，findAll()返回所有满足条件的元素`

```groovy
def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
list.findAll {
    it > 5
}.each {
    println it
}
```



`any() and every()`

```groovy
def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def anyEle = list.any {
    it > 5
}
println anyEle //true

def everyEle = list.every {
    it > 5
}

println everyEle  //false
```



`collect() and inject`

collect用来遍历集合并且返回一个集合

```groovy

def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

//collect 返回一个由closure转换后的集合
def newlist = list.collect {
    it * it
}

println newlist

//collect 的高级范例
def doubles = {
    item ->
        2 * item
}

def triples = {
    item ->
        3 * item
}

def isEven = {
    item -> 
        item%2 == 0
}
def map(clos,list){
    return list.collect(clos)
}
```



`inject用来遍历集合，首先将需要传递的值和集合项目传递给必报，此时其传递的值将作为处理结果，然后再和下一个集合项目一起传递给闭包，以此类推`

```groovy
def factorial = [2, 3, 4, 5]
        .inject(1) {
    previous, element ->
        previous * element
}

println factorial
//=====
def list = [2, 3, 4, 5]
factorial = list.inject(1) {
    prviouse, element ->
        prviouse * element
}
println factorial
//=====
def list = [2, 3, 4, 5]
def closure = {
    previous, element ->
        previous * element
}

def factorial = list.inject (1,closure)
println factorial
```



## 闭包的其他特性

由于闭包也是一个对象，因此它可以作为方法的参数，同时也可以作为另一个闭包的参数。

### 作为方法的参数

```groovy
def filter(list, predict) {
    return list.findAll(predict)
}

def isEven = {
    x ->
        return x % 2 == 0
}

def isOdd = {
    x ->
        return !isEven(x)
}

def table = [11, 12, 13, 14]

def evens = filter(table,isEven)
println evens

def odds = filter(table,isOdd)
println odds
```



### 作为另一个闭包的参数

```groovy
def takewhile = {
    predicate, list ->
        def result = []
        for (element in list) {
            if (predicate(element)) {
                result << element
            } else {
                return result
            }
        }
}

def isEven = {
    x ->
        return x % 2 == 0
}

def isOdd = {
    x ->
        return !isEven(x)
}

def table1 = [12, 14, 15, 18]
def table2 = [11, 13, 15, 16, 18]

def evens = takewhile.call(isEven,table1)
println evens
```



### 作为返回值

```groovy
def multiply(x){
    return {
        y->
            return x * y
    }
}

def twice = multiply(2)

println twice(4)
```



### 嵌套闭包

#### 选择性排序

