---
layout:     post
title:      "Groovy之闭包"
subtitle:   "Closure"
date:       2017-08-22 17:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Groovy	
---

[TOC]

# 闭包

闭包是一种可执行的代码块的方法，闭包也是对象，可以想方法一样传递参数。由于闭包是代码块，因此也可以在需要时执行。定义闭包的时候可以使用一个或者多个参数。闭包可以访问属性信息，意味着可以访问并修其作用于内的所有变量值。

## 闭包

```groovy
def greeting = 'hello'
def clos = {
    param ->
        println "$greeting $param"
}

clos.call("world")

greeting = 'welcome'
clos.call('world')

def demo(clos){
    def greeting = 'Bonjour'//this will not affect closure
    clos.call('ken')
}

demo(clos)   //output welcome ken
```

以上代码说明，只有闭包被定义且存在，而不是在被调用时，可以访问其状态值。

 闭包也常用在集合中。使用闭包可以更高效的遍历元素。

```groovy
1.upto(10,{
    println it 
})
//或者你也可以这么写
1.upto(10){
    println it
}
```

```groovy
//阶乘
def fac = 1
1.upto(5){
    num ->
        fac *= num
}

println "Factorical : $fac"
```

## 闭包与集合和字符串

常用each方法来遍历。

`find()返回第一个满足条件的元素，findAll()返回所有满足条件的元素`

```groovy
def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
list.findAll {
    it > 5
}.each {
    println it
}
```



`any() and every()`

```groovy
def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def anyEle = list.any {
    it > 5
}
println anyEle //true

def everyEle = list.every {
    it > 5
}

println everyEle  //false
```



`collect() and inject`

collect用来遍历集合并且返回一个集合

```groovy

def list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

//collect 返回一个由closure转换后的集合
def newlist = list.collect {
    it * it
}

println newlist

//collect 的高级范例
def doubles = {
    item ->
        2 * item
}

def triples = {
    item ->
        3 * item
}

def isEven = {
    item -> 
        item%2 == 0
}
def map(clos,list){
    return list.collect(clos)
}
```



`inject用来遍历集合，首先将需要传递的值和集合项目传递给必报，此时其传递的值将作为处理结果，然后再和下一个集合项目一起传递给闭包，以此类推`

```groovy
def factorial = [2, 3, 4, 5]
        .inject(1) {
    previous, element ->
        previous * element
}

println factorial
//=====
def list = [2, 3, 4, 5]
factorial = list.inject(1) {
    prviouse, element ->
        prviouse * element
}
println factorial
//=====
def list = [2, 3, 4, 5]
def closure = {
    previous, element ->
        previous * element
}

def factorial = list.inject (1,closure)
println factorial
```



## 闭包的其他特性

由于闭包也是一个对象，因此它可以作为方法的参数，同时也可以作为另一个闭包的参数。

### 作为方法的参数

```groovy
def filter(list, predict) {
    return list.findAll(predict)
}

def isEven = {
    x ->
        return x % 2 == 0
}

def isOdd = {
    x ->
        return !isEven(x)
}

def table = [11, 12, 13, 14]

def evens = filter(table,isEven)
println evens

def odds = filter(table,isOdd)
println odds
```



### 作为另一个闭包的参数

```groovy
def takewhile = {
    predicate, list ->
        def result = []
        for (element in list) {
            if (predicate(element)) {
                result << element
            } else {
                return result
            }
        }
}

def isEven = {
    x ->
        return x % 2 == 0
}

def isOdd = {
    x ->
        return !isEven(x)
}

def table1 = [12, 14, 15, 18]
def table2 = [11, 13, 15, 16, 18]

def evens = takewhile.call(isEven,table1)
println evens
```



### 作为返回值

```groovy
def multiply(x){
    return {
        y->
            return x * y
    }
}

def twice = multiply(2)

println twice(4)
```



### 嵌套闭包

#### 选择排序算法的实现

```groovy
def selection = {
    list ->
  //交换两个位置的数
        def swap = {
            sList, p, q ->
                def temp = sList[p]
                sList[p] = sList[q]
                sList[q] = temp
        }
  //找出最小数位置
        def minimumPosition = {
            pList, from ->
                def mPos = from
                def nextFrom = 1 + from
                for (j in nextFrom..<pList.size) {
                    if (pList[j] < pList[mPos]) {
                        mPos = j
                    }
                }
                return mPos
        }
        def size = list.size() - 1
        for (k in 0..<size) {
            def minPos = minimumPosition(list, k)
            swap(list, minPos, k)
        }
        return list
}

def table = [13, 14, 12, 11, 14]
def sorted = selection(table)
println sorted
```



# 关于闭包的更多信息

## 闭包和不确定性

先看一个例子，闭包在实参列表外部。如果方法的最后一个参数是闭包，那么可以将它从实参列表中删除，并放在气候的括号后面。

`demo(closure) 变为 demo closure`

```groovy
def greeting = 'Hello'
def clo = {
    param ->
        println "$greeting $param"
}

def demo(clos) {
    def greeting = 'Bonjour'
    clos.call('Ken')
}
//demo()clo error null point exception,解释见后。
 
demo clo

demo() {
    param ->
        println "welcome $param"
}


```



假设`clos`是一个闭包变量，`{...}`是一个闭包体。假设`x`和`y`是两个随意设置的值，则查看如下不同的方法调用语句：

```groovy
method(x,y,{...}) //ok
method(x,y){...} //ok
method(x,y,clos) //ok
method(x,y)clos //error no such method
```



第二行代码把闭包体直接放在调用参数的后面。第四行代码说明，同样的做法也许不适用闭包变量。Groovy解释器无法忍冬clos标识符是该方法的调用的一部分，因此Groovy解释器就会报错，说明找不到只有具有两个参数的method方法。

如果method标识具有一个参数的方法：

```groovy
def method(c){
  ...
}
```

则clos是个闭包变量，{…}是闭包体，如下调用语句

```groovy
method({...})  //ok
method(){...}  //ok
method{...}    //ok	
method(clos)   //ok
method()clos   //error null point exception 
method clos    //ok
```

第五行代码中，调用方法时不适用任何实参，在该方法体中，形参将被初始化为null，在这个方法中使用闭包变量将会导致系统错误。



## 闭包和方法

对于如下两个结构

```groovy
def mDouble = {
    n ->
  		return 2*n
}

def mDouble(n){
    return 2*n
}
```

前者是一个闭包定义，后者是一个方法定义。注意，任何闭包引用肯定有固定的作用域。不能出现同名的闭包变量，但是可以出现同名方法（方法重载）



## 默认参数

像方法一样，闭包也可以被分配带默认值的参数。

```groovy
def greeting = {
    msg, name = "leo" ->
        println "$msg $name"
}

greeting("hello ")
greeting("hello", "julia")
```

## 闭包和作用域

上面讲到的局部闭包实现的选择性排序算法。下面讲一个使用冒泡算法排序。

```groovy
def bubbleSort = {
    list ->
        def swap = {
            sList, p, q ->
                def temp
                temp = sList[q]
                sList[q] = sList[p]
                sList[p] = temp
        }

        def size = list.size()
        def sortedPosition = 0

        while (sortedPosition < size) {
            for (index in 1..<(size - sortedPosition)) {
                if (list[index] < list[index - 1])
                    swap(list, index, index - 1)
            }
            sortedPosition ++ 
        }
        return list
}

def list = [1,5,4,6,2,7,0,78,54,23]
bubbleSort(list)
println list
```

需要注意的是，闭包只能由语句组成，这意味着闭包中不能有方法定义，因此局部闭包swap不能使用方法定义来替代。

## 递归闭包

用递归的方法求`n!`

```groovy
def factorial = {
    n ->
        return n == 0 ? 1 : n * call(n - 1)
}

println factorial(5)
```

## 状态类型

可以使用参数和返回值的动态类型来定义闭包。这个特性使得闭包更加通用。

### 闭包的动态类型

```groovy
def times = {
    x, y ->
        return x * y
}

def times = {
    x, y ->
        return x * y
}

println times(3,4)
println times(3.2,4.15)
println times('hello',4)
```

在调用时，才确定x和y的类型

```console
12
13.280
hellohellohellohello
```

### 静态指定参数类型的闭包

```groovy
def times = {
    Number x, Number y ->
        return x * y
}
```

这种方式就限定了闭包的参数类型，不能是Number及其子类意外的其他类型。



## 有关实参的约定

在调用闭包时，实参的数量必须严格匹配闭包定义时的形参数量。否则，Groovy解释器就会报错，指示参数不正确。

```groovy
def clos = {
    a,b,c ->
   "clos($a$b$c)"
}

clos(1,2,3) //ok
clos(1) //error
clos(1,2,3,4) //error
```



## 闭包、集合、范围

列表、映射、和范围等类型提供很多实用闭包作为参数的方法，这有利于迭代处理集合或者范围中的每个元素，并执行指定的任务。

迭代器方法

| 方法名称          | 说明   |
| ------------- | ---- |
| any\*         |      |
| collect\*     |      |
| collect\*     |      |
| each\*        |      |
| every\*       |      |
| find\*        |      |
| findAll\*     |      |
| findIndexOf\* |      |
| inject\*      |      |
| reverseEach\* |      |
| sort\*        |      |



## Return 语句

我们先看一个代码范例：

```groovy
def isMemberA(item, list) {
    def size = list.size()
    for (index in 0..<size) {
        if (list[index] == item)
            return true
    }
    return false
}

def isMemberB(item, list) {
    list.each {
        if (it == item)
            return true
    }
    return false
}
def numbers = [11, 12, 13, 14]

println isMemberA(15,numbers)
println isMemberA(13,numbers)

println isMemberB(15,numbers)
println isMemberB(13,numbers)  //这个有问题
```

输出为：

```console
false
true
false
false
```

显然，Groovy方式的返回是有问题的。这个是为什么呢？

在我们的范例中，作为实参的闭包包含一个return语句。闭包返回true，就会导致while循环继续处理列表中的下一个项目。

可以看一下`each`的实现方式

```groovy
    public static <T> Iterator<T> each(Iterator<T> self, @ClosureParams(FirstGenericType.class) Closure closure) {
        while(self.hasNext()) {
            Object arg = self.next();
            closure.call(arg);
        }

        return self;
    }
```

可以看到return是指返回的`closure.call()`但是外层循环还是在的，并不能直接终止循环，因此最终所有的数都会跑一边，这个是一个比较需要注意的地方，在使用`each`进行迭代的时候一定要注意哦！

