---
layout:     post
title:      "Java集合分析2"
subtitle:   "表/栈/队列"
date:       2019-09-26 19:00:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Data Structure
---

[TOC]

# 表

## ArrayList

### 简介

ArrayList实现了List的接口, 是一个顺序存储的容器, 允许放入`null`元素,底层通过*数组实现*, 线程非安全.ArrayList有一个capacity表示容量, 如果在向容器中添加元素且容量不足的时候, 容器会自增大底层数组的大小.

### 源码剖析

#### 成员变量

```java
//默认的初始化容量
private static final int DEFAULT_CAPACITY = 10;
//空表实例的默认元素
private static final Object[] EMPTY_ELEMENTDATA = {};
//空实例的默认大小空数组. 和上面的EMPTY_ELEMENTDATA甲乙区分是为了当添加第一个元素的时扩容多大.
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//存储表对象的数组
transient Object[] elementData;
//表的大小
private int size
//最大容量
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
```



#### 方法分析



```java
//构造函数1
    public ArrayList() {
      //将内部的数组初始化空数组.
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
//构造函数2
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
          //以initialCapacity初始化数组大小
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
          //如果传参为0 则初始化一个空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
          // 非法草书抛出异常.
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
//构造函数3
//直接使用一个集合初始化一个ArrayList.
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

```



##### 增删改查

###### 扩容相关函数

```java
// 增大容量来容纳指定数量的元素
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
      //新的数组长度是旧数组长度的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
      //如果新的数组长度小于传入参数的最小容量,那么以最小容量为新的数组大小
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
      //如果新的数组容量大于了最大数组大小.
      //
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
      //拷贝数组. 最终调用的是System.arrayCopy
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
	//大容量
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
      //if 大于最大容量 = Integer.MAX_VALUE
      //else 等于最大的数组大小.
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

	//
   private void ensureCapacityInternal(int minCapacity) {
     //如果ElementData恒等于默认的空数组.
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
          // 取最大的值作为容量.
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
				//扩容. 
        ensureExplicitCapacity(minCapacity);
    }
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++; //更改++
				
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
          //如果需求组的容量大于数组的长度, 那么要扩容.
            grow(minCapacity);
    }



```

###### 增

```java
    //直接增加.
		public boolean add(E e) {
      //检查容量及扩容
        ensureCapacityInternal(size + 1);  // Increments modCount!!
      //提那家元素
        elementData[size++] = e;
      //添加成功返回true
        return true;
    }
//插入
//检查范围
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
			
//
	    public void add(int index, E element) {
        //检查范围 
        rangeCheckForAdd(index);
				//检查容量
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //拷贝移动数组
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        //向目标位置插入元素
        elementData[index] = element;
        //size自增
        size++;
    }
//将一个集合直接添加到ArrayList
    public boolean addAll(Collection<? extends E> c) {
      //转为数组
        Object[] a = c.toArray();
      //集合的长度
        int numNew = a.length;
      // 检查容量
        ensureCapacityInternal(size + numNew);  // Increments modCount
      //拷贝
        System.arraycopy(a, 0, elementData, size, numNew);
      //size增加numNew
        size += numNew;

        return numNew != 0;
    }

//向指定位置直接插入集合
public boolean addAll(int index, Collection<? extends E> c) {
  // 检查范围
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
  //移动数组
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }
```

###### 查找

```java
//指定位置索引
    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }
//直接索引第一个可以找到的对象
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
```



###### 删除

```java
//直接清除
    public void clear() {
        modCount++;
				//大量的数据并且频繁操作可能引发频繁GC
        // clear to let GC do its work
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }
```

```java
//删除指定位置元素
    public E remove(int index) {
      //范围检查
        rangeCheck(index);
//操作数自增
        modCount++;
      // 保存这个被删除的元素 后续会返回
        E oldValue = elementData(index);
	//  要移动的元素个数
        int numMoved = size - index - 1;
      //移动元素
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
      //尾部的元素置null
        elementData[--size] = null; // clear to let GC do its work
//将被删除的元素返回
        return oldValue;
    }

//删除第一个能找到的指定元素
//快速移除, 不检查边界, 并且不返回被移除的对象.
    private void fastRemove(int index) {
      //修改计数+1;
        modCount++;
      //计算要移动的数量.
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
      //末尾元素释放.
        elementData[--size] = null; // clear to let GC do its work
    }

public boolean remove(Object o) {
  //如果指定的恒等于null
        if (o == null) {
          //找到这个null元素
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                  //快速移动
                    fastRemove(index);
                    return true;
                }
        } else {
          //找到这个非null元素, 并移除
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

        protected void removeRange(int fromIndex, int toIndex) {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
            parent.removeRange(parentOffset + fromIndex,
                               parentOffset + toIndex);
            this.modCount = parent.modCount;
            this.size -= toIndex - fromIndex;
        }

//AbstractList
/*
Overriding this method to take advantage of
     * the internals of the list implementation can <i>substantially</i>
     * improve the performance of the {@code clear} operation on this list
     * and its subLists.
     */
    protected void removeRange(int fromIndex, int toIndex) {
        ListIterator<E> it = listIterator(fromIndex);
        for (int i=0, n=toIndex-fromIndex; i<n; i++) {
            it.next();
            it.remove();
        }
    }

//implementation improve the performance
//为什么这个方法是protected 可以参考Effective Java一书中所述.
//TODO 解释为什么
//这个方法是给subList用的
    protected void removeRange(int fromIndex, int toIndex) {
        // Android-changed: Throw an IOOBE if toIndex < fromIndex as documented.
        // All the other cases (negative indices, or indices greater than the size
        // will be thrown by System#arrayCopy.
        if (toIndex < fromIndex) {
            throw new IndexOutOfBoundsException("toIndex < fromIndex");
        }

        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }


//移除所有C集合中包括的对象
    public boolean removeAll(Collection<?> c) {
      //检查非空
        Objects.requireNonNull(c);
      //
        return batchRemove(c, false);
    }

//这个方法设计的是在太妙了
		private boolean batchRemove(Collection<?> c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r < size; r++)
                if (c.contains(elementData[r]) == complement)
                  //在这里实际上用了个双指针, 将后面的元素移动到被删除的元素上, 这样做的目的是一边删除(占位置)一边移动元素, 效率更高
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
          //这里可能是为了做一些防御
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
          
            if (w != size) {
                // clear to let GC do its work
              //将w后续的元素释放
                for (int i = w; i < size; i++)
                    elementData[i] = null;
              //修改操作数
                modCount += size - w;
              //
                size = w;
                modified = true;
            }
        }
        return modified;
    }

//将不属于C中的元素移除.
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
      //参考上述的描述, 这里complement = true, 刚好和removeAll相反.
      //这个方法设计的非常巧妙
        return batchRemove(c, true);
    }
```



###### 改

```java
//这个没啥说的 非常简单,直接数组赋值就行了,注意不要越界的检查.
		public E set(int index, E element) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
    }
```



#### SubList以及迭代器



##### 迭代器

先看几个方法

```java
    /**
     * Returns an iterator over the elements in this list in proper sequence.
     *
     * <p>The returned iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
     *
     * @return an iterator over the elements in this list in proper sequence
     */
    public Iterator<E> iterator() {
      //返回了Itr实例, 看ArrayList怎么实现的
        return new Itr();
    }

 /**
     * An optimized version of AbstractList.Itr
     这里说的是一个优化过的AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        // Android-changed: Add "limit" field to detect end of iteration.
        // The "limit" of this iterator. This is the size of the list at the time the
        // iterator was created. Adding & removing elements will invalidate the iteration
        // anyway (and cause next() to throw) so saving this value will guarantee that the
        // value of hasNext() remains stable and won't flap between true and false when elements
        // are added and removed from the list.
        protected int limit = ArrayList.this.size;

        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor < limit;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            int i = cursor;
            if (i >= limit)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
                limit--;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;

            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
```



## LinkedList

# 栈

# 队列

