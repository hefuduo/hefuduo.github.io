---
layout:     post
title:      "Java持有引用"
subtitle:   "四种引用类型"
date:       2016-12-21 19:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Java	
---

[TOC]

## 持有引用

`java.lang.ref`类库包含了一组类，这些类为垃圾回收提供了更大的灵活性。当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。有三个继承自抽象类`Reference`的类；

`SoftReference,WeakReference,PhantomReference`

### Strong Reference

强引用，一般性的对象引用。如果一个对象具有强引用，垃圾回收器不会回收它。

软引用，如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收，该对象就可以被使用。

### 软引用`SoftReference`

**软引用可用来实现内存高速缓存**

```java
if(jvm low memo){
  str = null; //change to softreference.
  System.gc();
}
```

虚引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建.

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

这时候就可以使用软引用.

```java
Browser prev = new Browser();
SoftReference sr = new SoftReference(prev);
if(sr != null){
  prev = (Browser)sr.get();
}else{
  prev = new Browser();
  sr = new SoftReference(prev);
}
```

软引用可以和一个引用队列`ReferenceQueue`联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这些软引用加入到与之关联的引用队列中。



### 弱引用 `WeakReference`

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

```java
WeakReference<String> stringWeakReference  = new WeakReference<String>("llllll");
String sr = stringWeakReference.get();
```

如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中



### 虚引用 `PhantomReference`

虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

```java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference pr = new PhantomReference(object,queue);
```



### 为什么要这么用？

如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:

```java
ReferenceQueue queue = new
ReferenceQueue();

SoftReference
ref= new
SoftReference(aMyObject, queue); 
```

那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。
在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:

```java
SoftReference ref = null;

while ((ref = (EmployeeRef) q.poll()) != null) {

// 清除ref

}
```





| 引用类型 | 被垃圾回收时间    | 用途     | 生存时间       |
| ---- | ---------- | ------ | ---------- |
| 强引用  | 从来不会       | 对象一般态  | JVM生命周期    |
| 软引用  | Low Memory | 高速对象缓存 | Low Memory |
| 弱引用  | 在垃圾回收时     | 对象缓存   | gc运行后终止    |
| 虚引用  | 任何时候       | 任何     | 任何         |



ps ：题外话，关于这些引用在Android中的应用

可以看一下LeakCanary的源码





### `WeakHashMap`

容器类中有一种特殊的`Map`，即`WeakHashMap`，它被用来保存`WeakReference`。



