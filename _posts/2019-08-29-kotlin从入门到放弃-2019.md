---
layout:     post
title:      "Kotlin学习笔记3"
subtitle:   "Nested and Inner Classes,Enum,Objects"
date:       2019-08-29 16:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin	
---

[TOC]

# Nested and Inner Classes

 类能够相互嵌套

```kotlin
class Outer {
  private val bar: Int = 1
  class Nested {
    fun foo() = 2
  }
}

val demo = Outer.Nested().foo() // == 2
```

## Inner classes

内部类

```kotlin
class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1
```



## Anonymous inner classes 

匿名内部类

匿名内部类使用使用对象表达式创建

```kotlin
window.addMouseListener(object : MouseAdapter() {

    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
})
```

*Note*: on the JVM, if the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface

在JVM上如果一个Java Interface只有一个抽象方法, 可以使用lambda表达式创建一个对象

```kotlin
val listener = ActionListener {
  println("clicked")
}
```

# Enum Classes

The most basic usage of enum classes is implementing type-safe enums:

```kotlin
enum class Direction {
  NORTH, SOUTH, WEST, EAST
}
```

Each enum constant is an object. Enum constants are separated with commas.

## Initialization 初始化

Since each enum is an instance of the enum class, they can be initialized as:

```kotlin
enum class Color(val rgb: Int) {
  RED(0xFF0000),
  GREEN(0x00FF00),
  BLUE(0x0000FF)
}
```

 ## Anonymous Classes

Enum constants can also declare their own anonymous classes with their corresponding methods, as well as overriding base methods.

```kotlin
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };

    abstract fun signal(): ProtocolState
}
```



