---
layout:     post
title:      "Kotlin学习笔记3"
subtitle:   "Nested and Inner Classes,Enum,Objects"
date:       2019-08-29 16:38:00
author:     "LeoHe"
header-img: "img/post-bg-2015.jpg"
tags:
    - Kotlin
---

[TOC]

# Nested and Inner Classes

 类能够相互嵌套

```kotlin
class Outer {
  private val bar: Int = 1
  class Nested {
    fun foo() = 2
  }
}

val demo = Outer.Nested().foo() // == 2
```

## Inner classes

内部类

```kotlin
class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1
```



## Anonymous inner classes 

匿名内部类

匿名内部类使用使用对象表达式创建

```kotlin
window.addMouseListener(object : MouseAdapter() {

    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
})
```

*Note*: on the JVM, if the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface

在JVM上如果一个Java Interface只有一个抽象方法, 可以使用lambda表达式创建一个对象

```kotlin
val listener = ActionListener {
  println("clicked")
}
```

# Enum Classes

The most basic usage of enum classes is implementing type-safe enums:

```kotlin
enum class Direction {
  NORTH, SOUTH, WEST, EAST
}
```

Each enum constant is an object. Enum constants are separated with commas.

## Initialization 初始化

Since each enum is an instance of the enum class, they can be initialized as:

```kotlin
enum class Color(val rgb: Int) {
  RED(0xFF0000),
  GREEN(0x00FF00),
  BLUE(0x0000FF)
}
```

 ## Anonymous Classes

Enum constants can also declare their own anonymous classes with their corresponding methods, as well as overriding base methods.

```kotlin
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };

    abstract fun signal(): ProtocolState
}
```



If the enum class defines any members, separate the enum constant definitions from the member definitions with a semicolon.

Enum entries cannot contain nested types other than inner classes (deprecated in Kotlin 1.2).



## Implementing  Interfaces in Enum Classes

An enum class may implement an interface (but not derive from a class), providing either a single interface members implementation for all of the entries, or separate ones for each entry within its anonymous class. This is done by adding the interfaces to the enum class declaration as follows:



```kotlin
enum class IntArtithmetics : BinaryOperator<Int>, IntBinaryOperator {
  PLUS {
    override fun apply(t: Int, u: Int) : Int = t + u
  },
  TIMES {
    override fun apply(t: Int, u: Int) : Int = t * u
  };
  override fun applyAsInt(t: Int, u: Int) = apply(t, u)
}
```

## 	Working with Enum Constants

Enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is `EnumClass`):

```kotlin
EnumClass.valueOf(value: String): EnumClass
EnumClass.values(): Array<EnumClass>
```



The `valueOf()` method throws an `IllegalArgumentException` if the specified name does not match any of the enum constants defined in the class.

Since Kotlin 1.1, it's possible to access the constants in an enum class in a generic way, using the `enumValues<T>()` and `enumValueOf<T>()` functions:

```kotlin
enum class RGB { RED, GREEN, BLUE }

inline fun <  T : Enum<T>> printAllValues() {
    print(enumValues<T>().joinToString { it.name })
}

printAllValues<RGB>() // prints RED, GREEN, BLUE
```



Every enum constant has properties to obtain its name and position in the enum class declaration:

```kotlin
val name: String
val ordinal: Int
```





# Object Expressions and Declarations 对象表达式与声明

Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it. Kotlin handles this case with *object expressions* and *object declarations*.

Object expression: 对象表达式, Object declarations : 对象声明

## Object expressions

创建匿名类

```kotlin
window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { /*...*/ }

    override fun mouseEntered(e: MouseEvent) { /*...*/ }
})
```

If a supertype has a constructor, appropriate constructor parameters must be passed to it. Many supertypes may be specified as a comma-separated list after the colon:

```kotlin
open class A(x: Int) {
    public open val y: Int = x
}

interface B { /*...*/ }

val ab: A = object : A(1), B {
    override val y = 15
}
```

If, by any chance, we need "just an object", with no nontrivial supertypes, we can simply say:

直接声明一个对象

```kotlin
fun foo() {
  val adHoc = object {
    var x = 0
    var y = 0
  }
  print(adHoc.x + adHoc.y)
}
```

Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a return type of a public function or the type of a public property, the actual type of that function or property will be the declared supertype of the anonymous object, or `Any` if you didn't declare any supertype. Members added in the anonymous object will not be accessible.

匿名对象当成类型使用只是在局部和私有声明处. 如果将匿名对象当成共有方法的返回值或者让共有属性的公共属性, 方法和属性的实际类型将是匿名对象的超类型, 或者是`Any`如果你没生命任何超类型. 在匿名对象添加的成员不能被访问.

```kotlin
class C {
    // Private function, so the return type is the anonymous object type
    private fun foo() = object {
        val x: String = "x"
    }

    // Public function, so the return type is Any
    fun publicFoo() = object {
        val x: String = "x"
    }

    fun bar() {
        val x1 = foo().x        // Works
        val x2 = publicFoo().x  // ERROR: Unresolved reference 'x'
    }
}
```

The code in object expressions can access variables from the enclosing scope.

对象表达式能够访问闭包的变量

```kotlin
fun countClicks(window: JComponent) {
    var clickCount = 0
    var enterCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }

        override fun mouseEntered(e: MouseEvent) {
            enterCount++
        }
    })
    // ...
}
```



## Object Declarations

[Singleton](http://en.wikipedia.org/wiki/Singleton_pattern) may be useful in several cases, and Kotlin (after Scala) makes it easy to declare singletons:

使用Object 声明单例

```kotlin
objec DataProviderManager {
   fun registerDataProvider(provider: DataProvider) {
        // ...
    }

    val allDataProviders: Collection<DataProvider>
        get() = // ...
}
```

This is called an *object declaration*, and it always has a name following the *object* keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.

Object declaration's initialization is thread-safe.

To refer to the object, we use its name directly:

```kotlin
DataProviderManager.registerDataProvider(...)
```

Such objects can have supertypes:

这样的对象可以有超类型

```kotlin
object DefaultListener : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
}
```

**NOTE**: object declarations can't be local (i.e. be nested directly inside a function), but they can be nested into other object declarations or non-inner classes.

注意: 对象声明不能是局部的(否则就是对象表达式了)



## Companion Objects

伴生对象

kotlin类内部没有类似Java静态方法一说, 因此可以使用伴生对象定义静态方法或静态属性.

An object declaration inside a class can be marked with the *companion* keyword:

```kotlin
class MyClass {
  companion object Factory {
    fun create(): MyClass = MyClass()
  }
}
```

Members of the companion object can be called by using simply the class name as the qualifier:

```kotlin
val instance = MyClass.create(); //就好像调用静态方法一样
```

The name of the companion object can be omitted, in which case the name `Companion` will be used:

```kotlin
class MyClass {
  companion object {}
}

val x = MyClass.Companion
```

The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):

可以给伴生对象命名

```kotlin
class MyClass1 {
    companion object Named { }
}

val x = MyClass1

class MyClass2 {
    companion object { }
}

val y = MyClass2
```

Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces:

注意看起来类似静态成员,但是实际上仍然是真实对象的实例成员, 并且能够实现接口

```kotlin
interface Factory<T> {
  fun create() : T
}

class MyClass {
  companion object : Factory<MyClass> {
    override fun create(): MyClass = MyClass();
  }
}

val f : Factory<MyClass> = MyClass
```

注意与Java的互操作性,如下描述:

However, on the JVM you can have members of companion objects generated as real static methods and fields, if you use the `@JvmStatic` annotation. See the [Java interoperability](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-fields) section for more details.



## Semantic difference between object expressions and declarations

There is one important semantic difference between object expressions and object declarations:

- object expressions are executed (and initialized) **immediately**, where they are used;
- object declarations are initialized **lazily**, when accessed for the first time;
- a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer.





# Type aliases

类型别名(特别像C++ 的typedefine)

Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.

It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:

```kotlin
typealias NodeSet = Set<Network.Node>

typealias FileTable<K> = MutableMap<K, MutableList<File>>
```

You can have new names for inner and nested classes:

```kotlin
class A {
  inner class Inner
}
class B {
  inner class Inner
}

typealias AInner = A.Inner
typealias BInner = B.Inner
```

Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add `typealias Predicate<T>` and use `Predicate<Int>` in your code, the Kotlin compiler always expands it to `(Int) -> Boolean`. Thus you can pass a variable of your type whenever a general function type is required and vice versa:

```kotlin
typealias Predicate<T> = (T) -> Boolean

fun foo(p: Predicate<Int>) = p(42)

fun main() {
  var f: (Int) -> Boolean = { it > 0}
  println(foo(f)) //prints "true"
  
  val p: Predicate<Int> = { it> 0}
  println(listOf(1, -2).filter(p)) //prints "[1]"
}
```



## Inline classes

内联类

:warning: Inline classes are available only since Kotlin 1.3 and currently are *experimental*. See details 

暂时不介绍了, 稳定后再添加





## Delegation 委托

### Property Delegation

见下一章

### Implementation by Delegation

The [Delegation pattern](https://en.wikipedia.org/wiki/Delegation_pattern) has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class `Derived` can implement an interface `Base`by delegating all of its public members to a specified object

```kotlin
interface Base {
  fun print()
}

class BaseImpl(val x: Int) : Base {
  override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main() {
  val b = BaseImpl(10)
  Derived(b).print()
}
```

The *by*-clause in the supertype list for `Derived` indicates that `b` will be stored internally in objects of `Derived` and the compiler will generate all the methods of `Base` that forward to `b`.



### Overriding a member of an interface implemented by delegation

[Overrides](https://kotlinlang.org/docs/reference/classes.html#overriding-methods) work as you might expect: the compiler will use your `override` implementations instead of those in the delegate object. If we were to add `override fun printMessage() { print("abc") }` to`Derived`, the program would print "abc" instead of "10" when `printMessage` is called:

编译器将使用覆写的实现,而不是代理对象的function.

```kotlin
interface Base {
    fun printMessage()
    fun printMessageLine()
}

class BaseImpl(val x: Int) : Base {
    override fun printMessage() { print(x) }
    override fun printMessageLine() { println(x) }
}

class Derived(b: Base) : Base by b {
    override fun printMessage() { print("abc") }
}

fun main() {
    val b = BaseImpl(10)
    Derived(b).printMessage()
    Derived(b).printMessageLine()
}
//使用override function而不是使用委托中定义的function 这个要注意.
```

Note, however, that members overridden in this way do not get called from the members of the delegate object, which can only access its own implementations of the interface members:

注意!然而, 以这种方式覆写的成员不能从代理对象的成员被调用, 只能访问接口成员的自己的实现.(好绕啊)



总结, 代理类对象只能访问到代理类的属性, 而不能访问继承对象的实现;

如下, `Baseimpl`代理类的对象只能访问`BaseImpl`的属性, 而不能访问`Derived`这个派生类对象的属性`message`.

```kotlin
interface Base {
  val message: String
  fun print()
}

class BaseImpl(val x: Int) : Base {
  override val message = "BaseImpl : x = $x"
  override fun print() {println(message)}
}

class Derived(b: Base) : Base by b {
  //This property is not accessed from b's implementation of `print`
  override val message = "Message of Derived"
}

fun main() {
  val b = BaseImpl(10)
  val derived = Derived(b)
  derived.print() 
  println(derived.message)
}

//output 
/*
BaseImpl: x = 10
Message of Derived
*/
```





# Delegated Properties 属性代理

There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:

- lazy properties: the value gets computed only upon first access;
- observable properties: listeners get notified about changes to this property;
- storing properties in a map, instead of a separate field for each property.

To cover these (and other) cases, Kotlin supports *delegated properties*:

1.  延迟加载
2. 可监听
3. 将属性存储在map结构中

```kotlin
class Example {
  val p: String by Delegate()
}
```

The delegated property syntax is :

```
val/var <property name>: <Type> by <expression>
```

he expression after *by* is the *delegate*, because `get()` (and `set()`) corresponding to the property will be delegated to its `getValue()` and `setValue()` methods. Property delegates don’t have to implement any interface, but they have to provide a `getValue()` function (and `setValue()` — for *var*s). For example:

```kotlin
import kotlin.reflect.KProperty

class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }
 
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}
```

When we read from `p` that delegates to an instance of `Delegate`, the `getValue()` function from `Delegate` is called, so that its first parameter is the object we read `p` from and the second parameter holds a description of `p` itself (e.g. you can take its name). For example:

```kotlin
val e = Example()
println(e.p)
```

Similarly, when we assign to `p`, the `setValue()` function is called. The first two parameters are the same, and the third holds the value being assigned:

```kotlin
e.p = "NEW"
```

```
NEW has been assigned to ‘p’ in Example@33a17727.
```

The specification of the requirements to the delegated object can be found [below](https://kotlinlang.org/docs/reference/delegated-properties.html#property-delegate-requirements).

Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find [the example](https://kotlinlang.org/docs/reference/delegated-properties.html#local-delegated-properties-since-11).



## Standard Delegates

The Kotlin standard library provides factory methods for several useful kinds of delegates.

### Lazy

[`lazy()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html) is a function that takes a lambda and returns an instance of `Lazy<T>` which can serve as a delegate for implementing a lazy property: the first call to `get()` executes the lambda passed to `lazy()` and remembers the result, subsequent calls to `get()` simply return the remembered result.

```kotlin
val lazyValue: String by lazy {
	println("computed!")
	"hello"
}

fun main() {
  println(lazyValue)
  println(lazyValue)
}

output=>

computed!
hello
hello
```

By default, the evaluation of lazy properties is **synchronized**: the value is computed only in one thread, and all threads will see the same value. If the synchronization of initialization delegate is not required, so that multiple threads can execute it simultaneously, pass `LazyThreadSafetyMode.PUBLICATION` as a parameter to the `lazy()` function. And if you're sure that the initialization will always happen on the same thread as the one where you use the property, you can use `LazyThreadSafetyMode.NONE`: it doesn't incur any thread-safety guarantees and the related overhead.

默认线程安全



### Observable

[`Delegates.observable()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) takes two arguments: the initial value and a handler for modifications. The handler gets called every time we assign to the property (*after* the assignment has been performed). It has three parameters: a property being assigned to, the old value and the new one:

```kotlin
import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
}

fun main() {
    val user = User()
    user.name = "first"
    user.name = "second"
}
```

```kotlin
typealias Listener = (property: KProperty<*>, olderValue: String, newValue: String) -> Unit
class User(private val listener: Listener) {
    var name: String by Delegates.observable("<no name>", listener)
}

fun main() {
    val listener: Listener = { _, old, new ->
        println("old is $old and new is $new")
    }
    val user = User(listener)
    user.name = "hefuduo"
}

```

If you want to be able to intercept an assignment and "veto" it, use [`vetoable()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html) instead of `observable()`. The handler passed to the `vetoable` is called *before* the assignment of a new property value has been performed.

veto: 否定;

只有设置的值满足条件的时候, 才能成功

```kotlin
class BUser {
    var name: String by Delegates.vetoable("<no name>", { _, old, new ->
        println("the value set")
        new.length > old.length
    })
}
```

## Storing Properties in a Map

One common use case is storing the values of properties in a map. This comes up often in applications like parsing JSON or doing other “dynamic” things. In this case, you can use the map instance itself as the delegate for a delegated property.

```kotlin
class User(val map: Map<String, Any?>) {
  val name: String by map
  val age: Int by map
}
```

In this example, the constructor takes a map:

```kotlin
val User = User(mapOf(
  "name" to "John Doe",
  "age" to 25
))
```

Delegated properties take values from this map (by the string keys –– names of properties):

```kotlin
println(user.name) // Prints "John Doe"
println(user.age)  // Prints 25
```

This works also for *var*’s properties if you use a `MutableMap` instead of read-only `Map`:

```kotlin
class MutableUser(val map: MutableMap<String, Any?>) {
    var name: String by map
    var age: Int     by map
}
```



## Local Delegated Properties (since 1.1) 

You can declare local variables as delegated properties. For instance, you can make a local variable lazy:

```kotlin
fun example(computeFoo: () -> Foo) {
    val memoizedFoo by lazy(computeFoo)

    if (someCondition && memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}
```



## Properties Delegate Requirements

属性代理的            一些要求

Here we summarize requirements to delegate objects.

For a **read-only** property (i.e. a *val*), a delegate has to provide a function named `getValue` that takes the following parameters:

- `thisRef` — must be the same or a supertype of the *property owner* (for extension properties — the type being extended);
- `property` — must be of type `KProperty<*>` or its supertype.

this function must return the same type as property (or its subtype).

For a **mutable** property (a *var*), a delegate has to *additionally* provide a function named `setValue` that takes the following parameters:

- `thisRef` — same as for `getValue()`;
- `property` — same as for `getValue()`;
- `new value` — must be of the same type as the property or its subtype.

`getValue()` and/or `setValue()` functions may be provided either as member functions of the delegate class or extension functions. The latter is handy when you need to delegate property to an object which doesn't originally provide these functions. Both of the functions need to be marked with the `operator` keyword.

The delegate class may implement one of the interfaces `ReadOnlyProperty` and `ReadWriteProperty`containing the required `operator` methods. These interfaces are declared in the Kotlin standard library:

```kotlin
interface ReadOnlyProperty<in R, out T> {
    operator fun getValue(thisRef: R, property: KProperty<*>): T
}

interface ReadWriteProperty<in R, T> {
    operator fun getValue(thisRef: R, property: KProperty<*>): T
    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)
}
```

## Translation Rules

Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property `prop` the hidden property `prop$delegate` is generated, and the code of the accessors simply delegates to this additional property:

```kotlin
class C {
  var prop: Type by MyDelegate()
}

//this code is generated by the compiler instead
class C {
  private val prop$delegate = MyDelegate()
  var prop: Type 
  		get() = prop$delegate.getValue(this, this::prop)
  		set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}	
```

The Kotlin compiler provides all the necessary information about `prop` in the arguments: the first argument `this` refers to an instance of the outer class `C` and `this::prop` is a reflection object of the `KProperty` type describing `prop` itself.

```kotlin
        val a = this::name
        val b = this.name

```

Note that the syntax `this::prop` to refer a [bound callable reference](https://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11) in the code directly is available only since Kotlin 1.1.



## Providing a delegate (since 1.1)

By defining the `provideDelegate` operator you can extend the logic of creating the object to which the property implementation is delegated. If the object used on the right hand side of `by` defines `provideDelegate` as a member or extension function, that function will be called to create the property delegate instance.

One of the possible use cases of `provideDelegate` is to check property consistency when the property is created, not only in its getter or setter.

For example, if you want to check the property name before binding, you can write something like this

```kotlin
class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {
    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }
}
    
class ResourceLoader<T>(id: ResourceID<T>) {
    operator fun provideDelegate(
            thisRef: MyUI,
            prop: KProperty<*>
    ): ReadOnlyProperty<MyUI, T> {
        checkProperty(thisRef, prop.name)
        // create delegate
        return ResourceDelegate()
    }

    private fun checkProperty(thisRef: MyUI, name: String) { ... }
}

class MyUI {
    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }

    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}
```

The parameters of `provideDelegate` are the same as for `getValue`:

- `thisRef` — must be the same or a supertype of the *property owner* (for extension properties — the type being extended);
- `property` — must be of type `KProperty<*>` or its supertype.

The `provideDelegate` method is called for each property during the creation of the `MyUI` instance, and it performs the necessary validation right away.

Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:

```kotlin
// Checking the property name without "provideDelegate" functionality
class MyUI {
    val image by bindResource(ResourceID.image_id, "image")
    val text by bindResource(ResourceID.text_id, "text")
}

fun <T> MyUI.bindResource(
        id: ResourceID<T>,
        propertyName: String
): ReadOnlyProperty<MyUI, T> {
   checkProperty(this, propertyName)
   // create delegate
}
```

In the generated code, the `provideDelegate` method is called to initialize the auxiliary `prop$delegate` property. Compare the generated code for the property declaration `val prop: Type by MyDelegate()` with the generated code [above](https://kotlinlang.org/docs/reference/delegated-properties.html#translation-rules) (when the `provideDelegate` method is not present):

```kotlin
class C {
    var prop: Type by MyDelegate()
}

// this code is generated by the compiler 
// when the 'provideDelegate' function is available:
class C {
    // calling "provideDelegate" to create the additional "delegate" property
    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)
    var prop: Type
        get() = prop$delegate.getValue(this, this::prop)
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
```

Note that the `provideDelegate` method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter.





